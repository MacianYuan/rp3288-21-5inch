/* WARNING ! UNQUALIFIED DATA ! NO REVISION CONTROL AT ALL ! DO NOT USE ! WARNING !*/
/* Created by user koehler on Thu Jun 20 14:30:54 CEST 2013
*/
/*****************************************************************************
* This is an unpublished work, the copyright in which vests in DreamChip Technologies .
*
* The information contained herein is the property of DreamChip Technologies and is
* supplied without liability for errors or omissions. No part may be
* reproduced or used except as authorised by contract or other written
* permission.
*
* Copyright (c) 2013 DreamChip Technologies . All rights reserved.
*
*****************************************************************************/
/*
* NOTE: This file is automaticaly generated by sig of theflow Rev.: 1.1_dev_koehler.
*       Modifications can be lost.
*
*****************************************************************************/
/**
*-----------------------------------------------------------------------------
* $HeadURL$
* $Author$
* $Rev$
* $Date$
*-----------------------------------------------------------------------------
* @file mrv_all_regs.h
*
* <pre>
*
* Description:
*   This header file exports the module register structure and masks. 
*	It should not be included directly by your driver/application, it will be  
*   exported by the <TOP>_regs_io.h header file. 
*
* </pre>
*/
/*****************************************************************************/

#ifndef _MRV_ALL_REGS_H
#define _MRV_ALL_REGS_H


// Definitions of block register sizes
#define DEGAMMA_R_Y_BLOCK_ARR_SIZE 17
#define DEGAMMA_G_Y_BLOCK_ARR_SIZE 17
#define DEGAMMA_B_Y_BLOCK_ARR_SIZE 17
#define CROSS_TALK_COEF_BLOCK_ARR_SIZE 9
#define GAMMA_OUT_Y_BLOCK_ARR_SIZE 17
#define HISTOGRAM_MEASUREMENT_RESULT_ARR_SIZE 16
#define NLF_LOOKUP_TABLE_BLOCK_ARR_SIZE 17
#define WDR_TONE_MAPPING_CURVE_Y_BLOCK_ARR_SIZE 33
#define WDR_TONE_MAPPING_CURVE_Y_SHD_BLOCK_ARR_SIZE 33
#define AWB_MEAS_ACCU_ARR_SIZE 24
#define ISP64_HISTOGRAM_MEASUREMENT_RESULT_ARR_SIZE 32
//typedef unsigned int         uint32_t;


//! degamma_r_y_block register layout
typedef struct
{
  uint32_t isp_gamma_r_y; //!< De-Gamma Curve definition y red (rw) MRV_ISP_BASE + 0x448 + (n*0x4) (n=0..16)
} degamma_r_y_block_t;


//! degamma_g_y_block register layout
typedef struct
{
  uint32_t isp_gamma_g_y; //!< De-Gamma Curve definition y green (rw) MRV_ISP_BASE + 0x490 + (n*0x4) (n=0..16)
} degamma_g_y_block_t;


//! degamma_b_y_block register layout
typedef struct
{
  uint32_t isp_gamma_b_y; //!< De-Gamma Curve definition y blue (rw) MRV_ISP_BASE + 0x4D8 + (n*0x4) (n=0..16)
} degamma_b_y_block_t;


//! cross_talk_coef_block register layout
typedef struct
{
  uint32_t isp_ct_coeff; //!< cross-talk configuration register (color correction matrix) (rw) MRV_ISP_BASE + 0x7A0 + (n*0x4) (n=0..8)
} cross_talk_coef_block_t;


//! gamma_out_y_block register layout
typedef struct
{
  uint32_t isp_gamma_out_y; //!< Gamma Out Curve definition y_ (rw) MRV_ISP_BASE + 0x7F0 + (n*0x4) (n=0..16)
} gamma_out_y_block_t;


//! histogram_measurement_result register layout
typedef struct
{
  uint32_t isp_hist_bin; //!< histogram measurement result bin (r) MRV_HIST_BASE + 0x2428 + (n*0x4) (n=0..15)
} histogram_measurement_result_t;


//! nlf_lookup_table_block register layout
typedef struct
{
  uint32_t isp_dpf_nll_coeff; //!< Noise Level Lookup Coefficient (rw) MRV_DPF_BASE + 0x2840 + (n*0x4) (n=0..16)
} nlf_lookup_table_block_t;


//! wdr_tone_mapping_curve_y_block register layout
typedef struct
{
  uint32_t isp_wdr_tonecurve_ym; //!< Tonemapping curve coefficient Ym_ (rw) MRV_WDR_BASE + 0x2A28 + (n*0x4) (n=0..32)
} wdr_tone_mapping_curve_y_block_t;


//! wdr_tone_mapping_curve_y_shd_block register layout
typedef struct
{
  uint32_t isp_wdr_tonecurve_ym_shd; //!< Tonemapping curve coefficient shadow register (r) MRV_WDR_BASE + 0x2B60 + (n*0x4) (n=0..32)
} wdr_tone_mapping_curve_y_shd_block_t;


//! AWB_MEAS_ACCU register layout
typedef struct
{
  uint32_t awb_meas_accu; //!< AWB Accu Read (r) ISP_AWB_BASE + 0x2E90 + (n*0x4) (n=0..23)
} AWB_MEAS_ACCU_t;


//! isp64_histogram_measurement_result register layout
typedef struct
{
  uint32_t isp64_hist_bin; //!< histogram measurement result bin (sh_r) MRV_HIST_BASE + 0x2EA8 + (n*0x4) (n=0..31)
} isp64_histogram_measurement_result_t;

//! mipi interface
#define MIPI_ITF_ARR_SIZE   1
typedef struct
{
  uint32_t mipi_ctrl; //!< global control register (rw) MRV_MIPI_BASE + 0x00000000
  uint32_t mipi_status; //!< global status register (r) MRV_MIPI_BASE + 0x00000004
  uint32_t mipi_imsc; //!< Interrupt mask (rw) MRV_MIPI_BASE + 0x00000008
  uint32_t mipi_ris; //!< Raw interrupt status (r) MRV_MIPI_BASE + 0x0000000c
  uint32_t mipi_mis; //!< Masked interrupt status (r) MRV_MIPI_BASE + 0x00000010
  uint32_t mipi_icr; //!< Interrupt clear register (w) MRV_MIPI_BASE + 0x00000014
  uint32_t mipi_isr; //!< Interrupt set register (w) MRV_MIPI_BASE + 0x00000018
  uint32_t mipi_cur_data_id; //!< Current Data Identifier (r) MRV_MIPI_BASE + 0x0000001c
  uint32_t mipi_img_data_sel; //!< Image Data Selector (rw) MRV_MIPI_BASE + 0x00000020
  uint32_t mipi_add_data_sel_1; //!< Additional Data Selector 1 (rw) MRV_MIPI_BASE + 0x00000024
  uint32_t mipi_add_data_sel_2; //!< Additional Data Selector 2 (rw) MRV_MIPI_BASE + 0x00000028
  uint32_t mipi_add_data_sel_3; //!< Additional Data Selector 3 (rw) MRV_MIPI_BASE + 0x0000002c
  uint32_t mipi_add_data_sel_4; //!< Additional Data Selector 4 (rw) MRV_MIPI_BASE + 0x00000030
  uint32_t mipi_add_data_fifo; //!< Additional Data Fifo (r) MRV_MIPI_BASE + 0x00000034
  uint32_t mipi_add_data_fill_level; //!< Additional Data FIFO Fill Level (rw) MRV_MIPI_BASE + 0x00000038
  uint32_t mipi_compressed_mode; //!< controls processing of compressed raw data types (rw) MRV_MIPI_BASE + 0x0000003c
  uint32_t mipi_frame; //!< frame number from frame start and frame end short packets (r) MRV_MIPI_BASE + 0x00000040
  uint32_t mipi_gen_short_dt; //!< data type flags for received generic short packets (r) MRV_MIPI_BASE + 0x00000044
  uint32_t mipi_gen_short_8_9; //!< data field for generic short packets of data type 0x8 and 0x9 (r) MRV_MIPI_BASE + 0x00000048
  uint32_t mipi_gen_short_a_b; //!< data field for generic short packets of data type 0xA and 0xB (r) MRV_MIPI_BASE + 0x0000004c
  uint32_t mipi_gen_short_c_d; //!< data field for generic short packets of data type 0xC and 0xD (r) MRV_MIPI_BASE + 0x00000050
  uint32_t mipi_gen_short_e_f; //!< data field for generic short packets of data type 0xE and 0xF (r) MRV_MIPI_BASE + 0x00000054
  uint32_t _notused[(0x00000200-0x00000058)/4]; // gap in address space
} mipi_itf_t;
 
//! MrvAll Register layout 
typedef struct
{
  uint32_t vi_ccl; //!< Clock control register (rw) MRV_BASE + 0x00000000
  uint32_t _notused_0 [(0x00000008-0x00000004)/4]; // gap in address space
  uint32_t vi_id; //!< Revision identification register (r) MRV_BASE + 0x00000008
  uint32_t _notused_1 [(0x00000010-0x0000000c)/4]; // gap in address space
  uint32_t vi_iccl; //!< Internal clock  control register (rw) MRV_BASE + 0x00000010
  uint32_t vi_ircl; //!< Internal reset control register (rw) MRV_BASE + 0x00000014
  uint32_t vi_dpcl; //!< Data path control register (rw) MRV_BASE + 0x00000018
  uint32_t _notused_2 [(0x00000200-0x0000001c)/4]; // gap in address space
  uint32_t img_eff_ctrl; //!< Global control register (rw) MRV_IMGEFF_BASE + 0x00000000
  uint32_t img_eff_color_sel; //!< Color selection register (for color selection effect) (rw) MRV_IMGEFF_BASE + 0x00000004
  uint32_t img_eff_mat_1; //!< 3x3 matrix coefficients for emboss effect (1) (rw) MRV_IMGEFF_BASE + 0x00000008
  uint32_t img_eff_mat_2; //!< 3x3 matrix coefficients for emboss effect (2) (rw) MRV_IMGEFF_BASE + 0x0000000c
  uint32_t img_eff_mat_3; //!< 3x3 matrix coefficients for emboss(3) effect / sketch/sharpen(1) effect (rw) MRV_IMGEFF_BASE + 0x00000010
  uint32_t img_eff_mat_4; //!< 3x3 matrix coefficients for sketch/sharpen effect (2) (rw) MRV_IMGEFF_BASE + 0x00000014
  uint32_t img_eff_mat_5; //!< 3x3 matrix coefficients for sketch/sharpen effect (3) (rw) MRV_IMGEFF_BASE + 0x00000018
  uint32_t img_eff_tint; //!< Chrominance increment values of a tint (used for sepia effect) (rw) MRV_IMGEFF_BASE + 0x0000001c
  uint32_t img_eff_ctrl_shd; //!< Shadow register for control register (r) MRV_IMGEFF_BASE + 0x00000020
  uint32_t img_eff_sharpen; //!< Factor and threshold for sharpen effect (rw) MRV_IMGEFF_BASE + 0x00000024
  uint32_t _notused_3 [(0x00000300-0x00000228)/4]; // gap in address space
  uint32_t super_imp_ctrl; //!< Global control register (rw) MRV_SI_BASE + 0x00000000
  uint32_t super_imp_offset_x; //!< Offset x register (rw) MRV_SI_BASE + 0x00000004
  uint32_t super_imp_offset_y; //!< Offset y register (rw) MRV_SI_BASE + 0x00000008
  uint32_t super_imp_color_y; //!< Y component of transparent key color (rw) MRV_SI_BASE + 0x0000000c
  uint32_t super_imp_color_cb; //!< Cb component of transparent key color (rw) MRV_SI_BASE + 0x00000010
  uint32_t super_imp_color_cr; //!< Cr component of transparent key color (rw) MRV_SI_BASE + 0x00000014
  uint32_t _notused_4 [(0x00000400-0x00000318)/4]; // gap in address space
  uint32_t isp_ctrl; //!< global control register (rw) MRV_ISP_BASE + 0x00000000
  uint32_t isp_acq_prop; //!< ISP acquisition properties (rw) MRV_ISP_BASE + 0x00000004
  uint32_t isp_acq_h_offs; //!< horizontal input offset (rw) MRV_ISP_BASE + 0x00000008
  uint32_t isp_acq_v_offs; //!< vertical input offset (rw) MRV_ISP_BASE + 0x0000000c
  uint32_t isp_acq_h_size; //!< horizontal input size (rw) MRV_ISP_BASE + 0x00000010
  uint32_t isp_acq_v_size; //!< vertical input size (rw) MRV_ISP_BASE + 0x00000014
  uint32_t isp_acq_nr_frames; //!< Number of frames to be captured (rw) MRV_ISP_BASE + 0x00000018
  uint32_t isp_gamma_dx_lo; //!< De-Gamma Curve definition lower x increments (sampling points) (rw) MRV_ISP_BASE + 0x0000001c
  uint32_t isp_gamma_dx_hi; //!< De-Gamma Curve definition higher x increments (sampling points) (rw) MRV_ISP_BASE + 0x00000020
  degamma_r_y_block_t degamma_r_y_block_arr[DEGAMMA_R_Y_BLOCK_ARR_SIZE]; //!< degamma_r_y_block MRV_ISP_BASE + 36 + (n*0x4) (n=0..16)
  degamma_g_y_block_t degamma_g_y_block_arr[DEGAMMA_G_Y_BLOCK_ARR_SIZE]; //!< degamma_g_y_block MRV_ISP_BASE + 104 + (n*0x4) (n=0..16)
  degamma_b_y_block_t degamma_b_y_block_arr[DEGAMMA_B_Y_BLOCK_ARR_SIZE]; //!< degamma_b_y_block MRV_ISP_BASE + 172 + (n*0x4) (n=0..16)
  uint32_t _notused_5 [(0x00000510-0x000004f0)/4]; // gap in address space
  uint32_t isp_awb_prop; //!< Auto white balance properties (rw) MRV_ISP_BASE + 0x00000110
  uint32_t isp_awb_h_offs; //!< Auto white balance horizontal offset of measure window (rw) MRV_ISP_BASE + 0x00000114
  uint32_t isp_awb_v_offs; //!< Auto white balance vertical offset of measure window (rw) MRV_ISP_BASE + 0x00000118
  uint32_t isp_awb_h_size; //!< Auto white balance horizontal window size (rw) MRV_ISP_BASE + 0x0000011c
  uint32_t isp_awb_v_size; //!< Auto white balance vertical window size (rw) MRV_ISP_BASE + 0x00000120
  uint32_t isp_awb_frames; //!< Auto white balance mean value over multiple frames (rw) MRV_ISP_BASE + 0x00000124
  uint32_t isp_awb_ref; //!< Auto white balance reference Cb/Cr values (rw) MRV_ISP_BASE + 0x00000128
  uint32_t isp_awb_thresh; //!< Auto white balance threshold values (rw) MRV_ISP_BASE + 0x0000012c
  uint32_t _notused_6 [(0x00000538-0x00000530)/4]; // gap in address space
  uint32_t isp_awb_gain_g; //!< Auto white balance gain green (rw) MRV_ISP_BASE + 0x00000138
  uint32_t isp_awb_gain_rb; //!< Auto white balance gain red and blue (rw) MRV_ISP_BASE + 0x0000013c
  uint32_t isp_awb_white_cnt; //!< Auto white balance white pixel count (r) MRV_ISP_BASE + 0x00000140
  uint32_t isp_awb_mean; //!< Auto white balance measured mean value (r) MRV_ISP_BASE + 0x00000144
  uint32_t _notused_7 [(0x00000570-0x00000548)/4]; // gap in address space
  uint32_t isp_cc_coeff_0; //!< Color conversion coefficient 0 (rw) MRV_ISP_BASE + 0x00000170
  uint32_t isp_cc_coeff_1; //!< Color conversion coefficient 1 (rw) MRV_ISP_BASE + 0x00000174
  uint32_t isp_cc_coeff_2; //!< Color conversion coefficient 2 (rw) MRV_ISP_BASE + 0x00000178
  uint32_t isp_cc_coeff_3; //!< Color conversion coefficient 3 (rw) MRV_ISP_BASE + 0x0000017c
  uint32_t isp_cc_coeff_4; //!< Color conversion coefficient 4 (rw) MRV_ISP_BASE + 0x00000180
  uint32_t isp_cc_coeff_5; //!< Color conversion coefficient 5 (rw) MRV_ISP_BASE + 0x00000184
  uint32_t isp_cc_coeff_6; //!< Color conversion coefficient 6 (rw) MRV_ISP_BASE + 0x00000188
  uint32_t isp_cc_coeff_7; //!< Color conversion coefficient 7 (rw) MRV_ISP_BASE + 0x0000018c
  uint32_t isp_cc_coeff_8; //!< Color conversion coefficient 8 (rw) MRV_ISP_BASE + 0x00000190
  uint32_t isp_out_h_offs; //!< Horizontal offset of output window (rw) MRV_ISP_BASE + 0x00000194
  uint32_t isp_out_v_offs; //!< Vertical offset of output window (rw) MRV_ISP_BASE + 0x00000198
  uint32_t isp_out_h_size; //!< Output horizontal picture size (rw) MRV_ISP_BASE + 0x0000019c
  uint32_t isp_out_v_size; //!< Output vertical picture size (rw) MRV_ISP_BASE + 0x000001a0
  uint32_t isp_demosaic; //!< Demosaic parameters (rw) MRV_ISP_BASE + 0x000001a4
  uint32_t isp_flags_shd; //!< Flags (current status) of certain signals and Shadow regs for enable signals (r) MRV_ISP_BASE + 0x000001a8
  uint32_t isp_out_h_offs_shd; //!< current horizontal offset of output window (shadow register) (r) MRV_ISP_BASE + 0x000001ac
  uint32_t isp_out_v_offs_shd; //!< current vertical offset of output window (shadow register) (r) MRV_ISP_BASE + 0x000001b0
  uint32_t isp_out_h_size_shd; //!< current output horizontal picture size (shadow register) (r) MRV_ISP_BASE + 0x000001b4
  uint32_t isp_out_v_size_shd; //!< current output vertical picture size (shadow register) (r) MRV_ISP_BASE + 0x000001b8
  uint32_t isp_imsc; //!< Interrupt mask (rw) MRV_ISP_BASE + 0x000001bc
  uint32_t isp_ris; //!< Raw interrupt status (r) MRV_ISP_BASE + 0x000001c0
  uint32_t isp_mis; //!< Masked interrupt status (r) MRV_ISP_BASE + 0x000001c4
  uint32_t isp_icr; //!< Interrupt clear register (w) MRV_ISP_BASE + 0x000001c8
  uint32_t isp_isr; //!< Interrupt set register (w) MRV_ISP_BASE + 0x000001cc
  cross_talk_coef_block_t cross_talk_coef_block_arr[CROSS_TALK_COEF_BLOCK_ARR_SIZE]; //!< cross_talk_coef_block MRV_ISP_BASE + 464 + (n*0x4) (n=0..8)
  uint32_t isp_gamma_out_mode; //!< gamma segmentation mode register for output gamma (rw) MRV_ISP_BASE + 0x000001f4
  gamma_out_y_block_t gamma_out_y_block_arr[GAMMA_OUT_Y_BLOCK_ARR_SIZE]; //!< gamma_out_y_block MRV_ISP_BASE + 504 + (n*0x4) (n=0..16)
  uint32_t isp_err; //!< ISP error register (r) MRV_ISP_BASE + 0x0000023c
  uint32_t isp_err_clr; //!< ISP error clear register (w) MRV_ISP_BASE + 0x00000240
  uint32_t isp_frame_count; //!< Frame counter (r) MRV_ISP_BASE + 0x00000244
  uint32_t isp_ct_offset_r; //!< cross-talk offset red (rw) MRV_ISP_BASE + 0x00000248
  uint32_t isp_ct_offset_g; //!< cross-talk offset green (rw) MRV_ISP_BASE + 0x0000024c
  uint32_t isp_ct_offset_b; //!< cross-talk offset blue (rw) MRV_ISP_BASE + 0x00000250
  uint32_t _notused_8 [(0x00000660-0x00000654)/4]; // gap in address space
  uint32_t isp_flash_cmd; //!< Flash command (w) MRV_FLASH_BASE + 0x00000000
  uint32_t isp_flash_config; //!< Flash config (rw) MRV_FLASH_BASE + 0x00000004
  uint32_t isp_flash_prediv; //!< Flash Counter Pre-Divider (rw) MRV_FLASH_BASE + 0x00000008
  uint32_t isp_flash_delay; //!< Flash Delay (rw) MRV_FLASH_BASE + 0x0000000c
  uint32_t isp_flash_time; //!< Flash time (rw) MRV_FLASH_BASE + 0x00000010
  uint32_t isp_flash_maxp; //!< Maximum value for flash or preflash (rw) MRV_FLASH_BASE + 0x00000014
  uint32_t _notused_9 [(0x00000680-0x00000678)/4]; // gap in address space
  uint32_t isp_sh_ctrl; //!< mechanical shutter control (rw) MRV_SHUT_BASE + 0x00000000
  uint32_t isp_sh_prediv; //!< Mech. Shutter Counter Pre-Divider (rw) MRV_SHUT_BASE + 0x00000004
  uint32_t isp_sh_delay; //!< Delay register (rw) MRV_SHUT_BASE + 0x00000008
  uint32_t isp_sh_time; //!< Time register (rw) MRV_SHUT_BASE + 0x0000000c
  uint32_t _notused_10 [(0x00000800-0x00000690)/4]; // gap in address space
  uint32_t cproc_ctrl; //!< Global control register (rw) MRV_CPROC_BASE + 0x00000000
  uint32_t cproc_contrast; //!< Color Processing contrast register (rw) MRV_CPROC_BASE + 0x00000004
  uint32_t cproc_brightness; //!< Color Processing brightness register (rw) MRV_CPROC_BASE + 0x00000008
  uint32_t cproc_saturation; //!< Color Processing saturation register (rw) MRV_CPROC_BASE + 0x0000000c
  uint32_t cproc_hue; //!< Color Processing hue register (rw) MRV_CPROC_BASE + 0x00000010
  uint32_t _notused_11 [(0x00000880-0x00000814)/4]; // gap in address space
  uint32_t dual_crop_ctrl; //!< Global control register (rw) MRV_dual_crop_BASE + 0x00000000
  uint32_t dual_crop_m_h_offs; //!< Main Path Horizontal offset of output window (rw) MRV_dual_crop_BASE + 0x00000004
  uint32_t dual_crop_m_v_offs; //!< Main Path Vertical offset of output window (rw) MRV_dual_crop_BASE + 0x00000008
  uint32_t dual_crop_m_h_size; //!< Main Path Output horizontal picture size (rw) MRV_dual_crop_BASE + 0x0000000c
  uint32_t dual_crop_m_v_size; //!< Main Path Output vertical picture size (rw) MRV_dual_crop_BASE + 0x00000010
  uint32_t dual_crop_s_h_offs; //!< Self Path Horizontal offset of output window (rw) MRV_dual_crop_BASE + 0x00000014
  uint32_t dual_crop_s_v_offs; //!< Self Path Vertical offset of output window (rw) MRV_dual_crop_BASE + 0x00000018
  uint32_t dual_crop_s_h_size; //!< Self Path Output horizontal picture size (rw) MRV_dual_crop_BASE + 0x0000001c
  uint32_t dual_crop_s_v_size; //!< Self Path Output vertical picture size (rw) MRV_dual_crop_BASE + 0x00000020
  uint32_t dual_crop_m_h_offs_shd; //!< current horizontal offset of output window (shadow register) (r) MRV_dual_crop_BASE + 0x00000024
  uint32_t dual_crop_m_v_offs_shd; //!< current vertical offset of output window (shadow register) (r) MRV_dual_crop_BASE + 0x00000028
  uint32_t dual_crop_m_h_size_shd; //!< current output horizontal picture size (shadow register) (r) MRV_dual_crop_BASE + 0x0000002c
  uint32_t dual_crop_m_v_size_shd; //!< current output vertical picture size (shadow register) (r) MRV_dual_crop_BASE + 0x00000030
  uint32_t dual_crop_s_h_offs_shd; //!< current horizontal offset of output window (shadow register) (r) MRV_dual_crop_BASE + 0x00000034
  uint32_t dual_crop_s_v_offs_shd; //!< current vertical offset of output window (shadow register) (r) MRV_dual_crop_BASE + 0x00000038
  uint32_t dual_crop_s_h_size_shd; //!< current output horizontal picture size (shadow register) (r) MRV_dual_crop_BASE + 0x0000003c
  uint32_t dual_crop_s_v_size_shd; //!< current output vertical picture size (shadow register) (r) MRV_dual_crop_BASE + 0x00000040
  uint32_t _notused_12 [(0x00000c00-0x000008c4)/4]; // gap in address space
  uint32_t mrsz_ctrl; //!< global control register (rw) MRV_MRSZ_BASE + 0x00000000
  uint32_t mrsz_scale_hy; //!< horizontal luminance scale factor register (rw) MRV_MRSZ_BASE + 0x00000004
  uint32_t mrsz_scale_hcb; //!< horizontal Cb scale factor register (rw) MRV_MRSZ_BASE + 0x00000008
  uint32_t mrsz_scale_hcr; //!< horizontal Cr scale factor register (rw) MRV_MRSZ_BASE + 0x0000000c
  uint32_t mrsz_scale_vy; //!< vertical luminance scale factor register (rw) MRV_MRSZ_BASE + 0x00000010
  uint32_t mrsz_scale_vc; //!< vertical chrominance scale factor register (rw) MRV_MRSZ_BASE + 0x00000014
  uint32_t mrsz_phase_hy; //!< horizontal luminance phase register (rw) MRV_MRSZ_BASE + 0x00000018
  uint32_t mrsz_phase_hc; //!< horizontal chrominance phase register (rw) MRV_MRSZ_BASE + 0x0000001c
  uint32_t mrsz_phase_vy; //!< vertical luminance phase register (rw) MRV_MRSZ_BASE + 0x00000020
  uint32_t mrsz_phase_vc; //!< vertical chrominance phase register (rw) MRV_MRSZ_BASE + 0x00000024
  uint32_t mrsz_scale_lut_addr; //!< Address pointer of up-scaling look up table (rw) MRV_MRSZ_BASE + 0x00000028
  uint32_t mrsz_scale_lut; //!< Entry of up-scaling look up table (rw) MRV_MRSZ_BASE + 0x0000002c
  uint32_t mrsz_ctrl_shd; //!< global control shadow register (r) MRV_MRSZ_BASE + 0x00000030
  uint32_t mrsz_scale_hy_shd; //!< horizontal luminance scale factor shadow register (r) MRV_MRSZ_BASE + 0x00000034
  uint32_t mrsz_scale_hcb_shd; //!< horizontal Cb scale factor shadow register (r) MRV_MRSZ_BASE + 0x00000038
  uint32_t mrsz_scale_hcr_shd; //!< horizontal Cr scale factor shadow register (r) MRV_MRSZ_BASE + 0x0000003c
  uint32_t mrsz_scale_vy_shd; //!< vertical luminance scale factor shadow register (r) MRV_MRSZ_BASE + 0x00000040
  uint32_t mrsz_scale_vc_shd; //!< vertical chrominance scale factor shadow register (r) MRV_MRSZ_BASE + 0x00000044
  uint32_t mrsz_phase_hy_shd; //!< horizontal luminance phase shadow register (r) MRV_MRSZ_BASE + 0x00000048
  uint32_t mrsz_phase_hc_shd; //!< horizontal chrominance phase shadow register (r) MRV_MRSZ_BASE + 0x0000004c
  uint32_t mrsz_phase_vy_shd; //!< vertical luminance phase shadow register (r) MRV_MRSZ_BASE + 0x00000050
  uint32_t mrsz_phase_vc_shd; //!< vertical chrominance phase shadow register (r) MRV_MRSZ_BASE + 0x00000054
  uint32_t _notused_13 [(0x00001000-0x00000c58)/4]; // gap in address space
  uint32_t srsz_ctrl; //!< global control register (rw) MRV_SRSZ_BASE + 0x00000000
  uint32_t srsz_scale_hy; //!< horizontal luminance scale factor register (rw) MRV_SRSZ_BASE + 0x00000004
  uint32_t srsz_scale_hcb; //!< horizontal chrominance scale factor register (rw) MRV_SRSZ_BASE + 0x00000008
  uint32_t srsz_scale_hcr; //!< horizontal chrominance scale factor register (rw) MRV_SRSZ_BASE + 0x0000000c
  uint32_t srsz_scale_vy; //!< vertical luminance scale factor register (rw) MRV_SRSZ_BASE + 0x00000010
  uint32_t srsz_scale_vc; //!< vertical chrominance scale factor register (rw) MRV_SRSZ_BASE + 0x00000014
  uint32_t srsz_phase_hy; //!< horizontal luminance phase register (rw) MRV_SRSZ_BASE + 0x00000018
  uint32_t srsz_phase_hc; //!< horizontal chrominance phase register (rw) MRV_SRSZ_BASE + 0x0000001c
  uint32_t srsz_phase_vy; //!< vertical luminance phase register (rw) MRV_SRSZ_BASE + 0x00000020
  uint32_t srsz_phase_vc; //!< vertical chrominance phase register (rw) MRV_SRSZ_BASE + 0x00000024
  uint32_t srsz_scale_lut_addr; //!< Address pointer of up-scaling look up table (rw) MRV_SRSZ_BASE + 0x00000028
  uint32_t srsz_scale_lut; //!< Entry of up-scaling look up table (rw) MRV_SRSZ_BASE + 0x0000002c
  uint32_t srsz_ctrl_shd; //!< global control shadow register (r) MRV_SRSZ_BASE + 0x00000030
  uint32_t srsz_scale_hy_shd; //!< horizontal luminance scale factor shadow register (r) MRV_SRSZ_BASE + 0x00000034
  uint32_t srsz_scale_hcb_shd; //!< horizontal Cb scale factor shadow register (r) MRV_SRSZ_BASE + 0x00000038
  uint32_t srsz_scale_hcr_shd; //!< horizontal Cr scale factor shadow register (r) MRV_SRSZ_BASE + 0x0000003c
  uint32_t srsz_scale_vy_shd; //!< vertical luminance scale factor shadow register (r) MRV_SRSZ_BASE + 0x00000040
  uint32_t srsz_scale_vc_shd; //!< vertical chrominance scale factor shadow register (r) MRV_SRSZ_BASE + 0x00000044
  uint32_t srsz_phase_hy_shd; //!< horizontal luminance phase shadow register (r) MRV_SRSZ_BASE + 0x00000048
  uint32_t srsz_phase_hc_shd; //!< horizontal chrominance phase shadow register (r) MRV_SRSZ_BASE + 0x0000004c
  uint32_t srsz_phase_vy_shd; //!< vertical luminance phase shadow register (r) MRV_SRSZ_BASE + 0x00000050
  uint32_t srsz_phase_vc_shd; //!< vertical chrominance phase shadow register (r) MRV_SRSZ_BASE + 0x00000054
  uint32_t _notused_14 [(0x00001400-0x00001058)/4]; // gap in address space
  uint32_t mi_ctrl; //!< Global control register (rw) MRV_MI_BASE + 0x00000000
  uint32_t mi_init; //!< Control register for address init and skip function (w) MRV_MI_BASE + 0x00000004
  uint32_t mi_mp_y_base_ad_init; //!< Base address for main picture Y component, JPEG or raw data (rw) MRV_MI_BASE + 0x00000008
  uint32_t mi_mp_y_size_init; //!< Size of main picture Y component, JPEG or raw data (rw) MRV_MI_BASE + 0x0000000c
  uint32_t mi_mp_y_offs_cnt_init; //!< Offset counter init value for main picture Y, JPEG or raw data (rw) MRV_MI_BASE + 0x00000010
  uint32_t mi_mp_y_offs_cnt_start; //!< Offset counter start value for main picture Y, JPEG or raw data (r) MRV_MI_BASE + 0x00000014
  uint32_t mi_mp_y_irq_offs_init; //!< Fill level interrupt offset value for main picture Y, JPEG or raw data (rw) MRV_MI_BASE + 0x00000018
  uint32_t mi_mp_cb_base_ad_init; //!< Base address for main picture Cb component ring buffer (rw) MRV_MI_BASE + 0x0000001c
  uint32_t mi_mp_cb_size_init; //!< Size of main picture Cb component ring buffer (rw) MRV_MI_BASE + 0x00000020
  uint32_t mi_mp_cb_offs_cnt_init; //!< Offset counter init value for main picture Cb component ring buffer (rw) MRV_MI_BASE + 0x00000024
  uint32_t mi_mp_cb_offs_cnt_start; //!< Offset counter start value for main picture Cb component ring buffer (r) MRV_MI_BASE + 0x00000028
  uint32_t mi_mp_cr_base_ad_init; //!< Base address for main picture Cr component ring buffer (rw) MRV_MI_BASE + 0x0000002c
  uint32_t mi_mp_cr_size_init; //!< Size of main picture Cr component ring buffer (rw) MRV_MI_BASE + 0x00000030
  uint32_t mi_mp_cr_offs_cnt_init; //!< Offset counter init value for main picture Cr component ring buffer (rw) MRV_MI_BASE + 0x00000034
  uint32_t mi_mp_cr_offs_cnt_start; //!< Offset counter start value for main picture Cr component ring buffer (r) MRV_MI_BASE + 0x00000038
  uint32_t mi_sp_y_base_ad_init; //!< Base address for self picture Y component ring buffer (rw) MRV_MI_BASE + 0x0000003c
  uint32_t mi_sp_y_size_init; //!< Size of self picture Y component ring buffer (rw) MRV_MI_BASE + 0x00000040
  uint32_t mi_sp_y_offs_cnt_init; //!< Offset counter init value for self picture Y component ring buffer (rw) MRV_MI_BASE + 0x00000044
  uint32_t mi_sp_y_offs_cnt_start; //!< Offset counter start value for self picture Y component ring buffer (r) MRV_MI_BASE + 0x00000048
  uint32_t mi_sp_y_llength; //!< Line length of self picture Y component (rw) MRV_MI_BASE + 0x0000004c
  uint32_t mi_sp_cb_base_ad_init; //!< Base address for self picture Cb component ring buffer (rw) MRV_MI_BASE + 0x00000050
  uint32_t mi_sp_cb_size_init; //!< Size of self picture Cb component ring buffer (rw) MRV_MI_BASE + 0x00000054
  uint32_t mi_sp_cb_offs_cnt_init; //!< Offset counter init value for self picture Cb component ring buffer (rw) MRV_MI_BASE + 0x00000058
  uint32_t mi_sp_cb_offs_cnt_start; //!< Offset counter start value for self picture Cb component ring buffer (r) MRV_MI_BASE + 0x0000005c
  uint32_t mi_sp_cr_base_ad_init; //!< Base address for self picture Cr component ring buffer (rw) MRV_MI_BASE + 0x00000060
  uint32_t mi_sp_cr_size_init; //!< Size of self picture Cr component ring buffer (rw) MRV_MI_BASE + 0x00000064
  uint32_t mi_sp_cr_offs_cnt_init; //!< Offset counter init value for self picture Cr component ring buffer (rw) MRV_MI_BASE + 0x00000068
  uint32_t mi_sp_cr_offs_cnt_start; //!< Offset counter start value for self picture Cr component ring buffer (r) MRV_MI_BASE + 0x0000006c
  uint32_t mi_byte_cnt; //!< Counter value of JPEG or RAW data bytes (r) MRV_MI_BASE + 0x00000070
  uint32_t mi_ctrl_shd; //!< global control internal shadow register (r) MRV_MI_BASE + 0x00000074
  uint32_t mi_mp_y_base_ad_shd; //!< Base address shadow register for main picture Y component, JPEG or raw data ring buffer (r) MRV_MI_BASE + 0x00000078
  uint32_t mi_mp_y_size_shd; //!< Size shadow register of main picture Y component, JPEG or raw data (r) MRV_MI_BASE + 0x0000007c
  uint32_t mi_mp_y_offs_cnt_shd; //!< Current offset counter of main picture Y component, JPEG or raw data ring buffer (r) MRV_MI_BASE + 0x00000080
  uint32_t mi_mp_y_irq_offs_shd; //!< Shadow register of fill level interrupt offset value for main picture Y component, JPEG or raw data (r) MRV_MI_BASE + 0x00000084
  uint32_t mi_mp_cb_base_ad_shd; //!< Base address shadow register for main picture Cb component ring buffer (r) MRV_MI_BASE + 0x00000088
  uint32_t mi_mp_cb_size_shd; //!< Size shadow register of main picture Cb component ring buffer (r) MRV_MI_BASE + 0x0000008c
  uint32_t mi_mp_cb_offs_cnt_shd; //!< Current offset counter of main picture Cb component ring buffer (r) MRV_MI_BASE + 0x00000090
  uint32_t mi_mp_cr_base_ad_shd; //!< Base address shadow register for main picture Cr component ring buffer (r) MRV_MI_BASE + 0x00000094
  uint32_t mi_mp_cr_size_shd; //!< Size shadow register of main picture Cr component ring buffer (r) MRV_MI_BASE + 0x00000098
  uint32_t mi_mp_cr_offs_cnt_shd; //!< Current offset counter of main picture Cr component ring buffer (r) MRV_MI_BASE + 0x0000009c
  uint32_t mi_sp_y_base_ad_shd; //!< Base address shadow register for self picture Y component ring buffer (r) MRV_MI_BASE + 0x000000a0
  uint32_t mi_sp_y_size_shd; //!< Size shadow register of self picture Y component ring buffer (r) MRV_MI_BASE + 0x000000a4
  uint32_t mi_sp_y_offs_cnt_shd; //!< Current offset counter of self picture Y component ring buffer (r) MRV_MI_BASE + 0x000000a8
  uint32_t _notused_15 [(0x000014b0-0x000014ac)/4]; // gap in address space
  uint32_t mi_sp_cb_base_ad_shd; //!< Base address shadow register for self picture Cb component ring buffer (r) MRV_MI_BASE + 0x000000b0
  uint32_t mi_sp_cb_size_shd; //!< Size shadow register of self picture Cb component ring buffer (r) MRV_MI_BASE + 0x000000b4
  uint32_t mi_sp_cb_offs_cnt_shd; //!< Current offset counter of self picture Cb component ring buffer (r) MRV_MI_BASE + 0x000000b8
  uint32_t mi_sp_cr_base_ad_shd; //!< Base address shadow register for self picture Cr component ring buffer (r) MRV_MI_BASE + 0x000000bc
  uint32_t mi_sp_cr_size_shd; //!< Size shadow register of self picture Cr component ring buffer (r) MRV_MI_BASE + 0x000000c0
  uint32_t mi_sp_cr_offs_cnt_shd; //!< Current offset counter of self picture Cr component ring buffer (r) MRV_MI_BASE + 0x000000c4
  uint32_t mi_dma_y_pic_start_ad; //!< Y component image start address (rw) MRV_MI_BASE + 0x000000c8
  uint32_t mi_dma_y_pic_width; //!< Y component image width (rw) MRV_MI_BASE + 0x000000cc
  uint32_t mi_dma_y_llength; //!< Y component original line length (rw) MRV_MI_BASE + 0x000000d0
  uint32_t mi_dma_y_pic_size; //!< Y component image size (rw) MRV_MI_BASE + 0x000000d4
  uint32_t mi_dma_cb_pic_start_ad; //!< Cb component image start address (rw) MRV_MI_BASE + 0x000000d8
  uint32_t _notused_16 [(0x000014e8-0x000014dc)/4]; // gap in address space
  uint32_t mi_dma_cr_pic_start_ad; //!< Cr component image start address (rw) MRV_MI_BASE + 0x000000e8
  uint32_t _notused_17 [(0x000014f8-0x000014ec)/4]; // gap in address space
  uint32_t mi_imsc; //!< Interrupt Mask (1: interrupt active, 0: interrupt masked) (rw) MRV_MI_BASE + 0x000000f8
  uint32_t mi_ris; //!< Raw Interrupt Status (r) MRV_MI_BASE + 0x000000fc
  uint32_t mi_mis; //!< Masked Interrupt Status (r) MRV_MI_BASE + 0x00000100
  uint32_t mi_icr; //!< Interrupt Clear Register (w) MRV_MI_BASE + 0x00000104
  uint32_t mi_isr; //!< Interrupt Set Register (w) MRV_MI_BASE + 0x00000108
  uint32_t mi_status; //!< MI Status Register (r) MRV_MI_BASE + 0x0000010c
  uint32_t mi_status_clr; //!< MI Status Clear Register (w) MRV_MI_BASE + 0x00000110
  uint32_t mi_sp_y_pic_width; //!< Y component image width (rw) MRV_MI_BASE + 0x00000114
  uint32_t mi_sp_y_pic_height; //!< Y component image height (rw) MRV_MI_BASE + 0x00000118
  uint32_t mi_sp_y_pic_size; //!< Y component image size (rw) MRV_MI_BASE + 0x0000011c
  uint32_t mi_dma_ctrl; //!< DMA control register (rw) MRV_MI_BASE + 0x00000120
  uint32_t mi_dma_start; //!< DMA start register (w) MRV_MI_BASE + 0x00000124
  uint32_t mi_dma_status; //!< DMA status register (r) MRV_MI_BASE + 0x00000128
  uint32_t mi_pixel_cnt; //!< Counter value for defect pixel list (r) MRV_MI_BASE + 0x0000012c
  uint32_t mi_mp_y_base_ad_init2; //!< Base address 2 (ping pong) for main picture Y component, JPEG or raw data (rw) MRV_MI_BASE + 0x00000130
  uint32_t mi_mp_cb_base_ad_init2; //!< Base address 2 (pingpong) for main picture Cb component (rw) MRV_MI_BASE + 0x00000134
  uint32_t mi_mp_cr_base_ad_init2; //!< Base address 2 (pingpong) for main picture Cr component ring buffer (rw) MRV_MI_BASE + 0x00000138
  uint32_t mi_sp_y_base_ad_init2; //!< Base address 2 (ping pong) for main picture Y component, JPEG or raw data (rw) MRV_MI_BASE + 0x0000013c
  uint32_t mi_sp_cb_base_ad_init2; //!< Base address 2 (pingpong) for main picture Cb component (rw) MRV_MI_BASE + 0x00000140
  uint32_t mi_sp_cr_base_ad_init2; //!< Base address 2 (pingpong) for main picture Cr component ring buffer (rw) MRV_MI_BASE + 0x00000144
  uint32_t mi_xtd_format_ctrl; //!< Extended Storage Format Control for main, self and dma read path (rw) MRV_MI_BASE + 0x00000148
  uint32_t _notused_18 [(0x00001800-0x0000154c)/4]; // gap in address space
  uint32_t jpe_gen_header; //!< command to start stream header generation (w) MRV_JPE_BASE + 0x00000000
  uint32_t jpe_encode; //!< Start command to start JFIF stream encoding (w) MRV_JPE_BASE + 0x00000004
  uint32_t jpe_init; //!< Automatic configuration update (INIT) (w) MRV_JPE_BASE + 0x00000008
  uint32_t jpe_y_scale_en; //!< Y value scaling control register (rw) MRV_JPE_BASE + 0x0000000c
  uint32_t jpe_cbcr_scale_en; //!< Cb/Cr value scaling control register (rw) MRV_JPE_BASE + 0x00000010
  uint32_t jpe_table_flush; //!< header generation debug register (rw) MRV_JPE_BASE + 0x00000014
  uint32_t jpe_enc_hsize; //!< JPEG codec horizontal image size for encoding (rw) MRV_JPE_BASE + 0x00000018
  uint32_t jpe_enc_vsize; //!< JPEG codec vertical image size for encoding (rw) MRV_JPE_BASE + 0x0000001c
  uint32_t jpe_pic_format; //!< JPEG picture encoding format (rw) MRV_JPE_BASE + 0x00000020
  uint32_t jpe_restart_interval; //!< restart marker insertion register (rw) MRV_JPE_BASE + 0x00000024
  uint32_t jpe_tq_y_select; //!< Q- table selector 0, quant. table for Y component (rw) MRV_JPE_BASE + 0x00000028
  uint32_t jpe_tq_u_select; //!< Q- table selector 1, quant. table for U component (rw) MRV_JPE_BASE + 0x0000002c
  uint32_t jpe_tq_v_select; //!< Q- table selector 2, quant. table for V component (rw) MRV_JPE_BASE + 0x00000030
  uint32_t jpe_dc_table_select; //!< Huffman table selector for DC values (rw) MRV_JPE_BASE + 0x00000034
  uint32_t jpe_ac_table_select; //!< Huffman table selector for AC values (rw) MRV_JPE_BASE + 0x00000038
  uint32_t jpe_table_data; //!< table programming register (w) MRV_JPE_BASE + 0x0000003c
  uint32_t jpe_table_id; //!< table programming select register (rw) MRV_JPE_BASE + 0x00000040
  uint32_t jpe_tac0_len; //!< Huffman AC table 0 length (rw) MRV_JPE_BASE + 0x00000044
  uint32_t jpe_tdc0_len; //!< Huffman DC table 0 length (rw) MRV_JPE_BASE + 0x00000048
  uint32_t jpe_tac1_len; //!< Huffman AC table 1 length (rw) MRV_JPE_BASE + 0x0000004c
  uint32_t jpe_tdc1_len; //!< Huffman DC table 1 length (rw) MRV_JPE_BASE + 0x00000050
  uint32_t _notused_19 [(0x00001858-0x00001854)/4]; // gap in address space
  uint32_t jpe_encoder_busy; //!< encoder status flag (r) MRV_JPE_BASE + 0x00000058
  uint32_t jpe_header_mode; //!< header mode definition (rw) MRV_JPE_BASE + 0x0000005c
  uint32_t jpe_encode_mode; //!< encode mode (r) MRV_JPE_BASE + 0x00000060
  uint32_t jpe_debug; //!< debug information register (r) MRV_JPE_BASE + 0x00000064
  uint32_t jpe_error_imr; //!< JPEG error interrupt mask register (rw) MRV_JPE_BASE + 0x00000068
  uint32_t jpe_error_ris; //!< JPEG error raw  interrupt status register (r) MRV_JPE_BASE + 0x0000006c
  uint32_t jpe_error_mis; //!< JPEG error masked interrupt status register (r) MRV_JPE_BASE + 0x00000070
  uint32_t jpe_error_icr; //!< JPEG error interrupt set register (w) MRV_JPE_BASE + 0x00000074
  uint32_t jpe_error_isr; //!< JPEG error interrupt clear register (w) MRV_JPE_BASE + 0x00000078
  uint32_t jpe_status_imr; //!< JPEG status interrupt mask register (rw) MRV_JPE_BASE + 0x0000007c
  uint32_t jpe_status_ris; //!< JPEG status raw interrupt status register (r) MRV_JPE_BASE + 0x00000080
  uint32_t jpe_status_mis; //!< JPEG status masked interrupt status register (r) MRV_JPE_BASE + 0x00000084
  uint32_t jpe_status_icr; //!< JPEG status interrupt clear register (w) MRV_JPE_BASE + 0x00000088
  uint32_t jpe_status_isr; //!< JPEG status interrupt set register (w) MRV_JPE_BASE + 0x0000008c
  uint32_t jpe_config; //!< JPEG configuration register (rw) MRV_JPE_BASE + 0x00000090
  uint32_t _notused_20 [(0x00001a00-0x00001894)/4]; // gap in address space
  uint32_t smia_ctrl; //!< global control register (rw) MRV_SMIA_BASE + 0x00000000
  uint32_t smia_status; //!< global status register (r) MRV_SMIA_BASE + 0x00000004
  uint32_t smia_imsc; //!< Interrupt mask (rw) MRV_SMIA_BASE + 0x00000008
  uint32_t smia_ris; //!< Raw interrupt status (r) MRV_SMIA_BASE + 0x0000000c
  uint32_t smia_mis; //!< Masked interrupt status (r) MRV_SMIA_BASE + 0x00000010
  uint32_t smia_icr; //!< Interrupt clear register (w) MRV_SMIA_BASE + 0x00000014
  uint32_t smia_isr; //!< Interrupt set register (w) MRV_SMIA_BASE + 0x00000018
  uint32_t smia_data_format_sel; //!< data format selector register (rw) MRV_SMIA_BASE + 0x0000001c
  uint32_t smia_sof_emb_data_lines; //!< start of frame embedded data lines register (rw) MRV_SMIA_BASE + 0x00000020
  uint32_t smia_emb_hstart; //!< embedded data hstart register (rw) MRV_SMIA_BASE + 0x00000024
  uint32_t smia_emb_hsize; //!< embedded data hsize register (rw) MRV_SMIA_BASE + 0x00000028
  uint32_t smia_emb_vstart; //!< embedded data vstart register (rw) MRV_SMIA_BASE + 0x0000002c
  uint32_t smia_num_lines; //!< image data lines register (rw) MRV_SMIA_BASE + 0x00000030
  uint32_t smia_emb_data_fifo; //!< Embedded Data Fifo (r) MRV_SMIA_BASE + 0x00000034
  uint32_t smia_fifo_fill_level; //!< Embedded Data FIFO Fill Level (rw) MRV_SMIA_BASE + 0x00000038
  uint32_t _notused_21 [(0x00001c00-0x00001a3c)/4]; // gap in address space
  mipi_itf_t mipi[MIPI_ITF_ARR_SIZE];
  uint32_t _notused_22 [(0x00002000-0x00001e00)/4]; // gap in address space
  uint32_t isp_afm_ctrl; //!< This is the control register for AF measurement unit (rw) MRV_AFM_BASE + 0x00000000
  uint32_t isp_afm_lt_a; //!< Top Left corner of measure window A (rw) MRV_AFM_BASE + 0x00000004
  uint32_t isp_afm_rb_a; //!< Bottom right corner of measure window A (rw) MRV_AFM_BASE + 0x00000008
  uint32_t isp_afm_lt_b; //!< Top left corner of measure window B (rw) MRV_AFM_BASE + 0x0000000c
  uint32_t isp_afm_rb_b; //!< Bottom right corner of measure window B (rw) MRV_AFM_BASE + 0x00000010
  uint32_t isp_afm_lt_c; //!< Top left corner of measure window C (rw) MRV_AFM_BASE + 0x00000014
  uint32_t isp_afm_rb_c; //!< Bottom right corner of measure window C (rw) MRV_AFM_BASE + 0x00000018
  uint32_t isp_afm_thres; //!< Threshold register (rw) MRV_AFM_BASE + 0x0000001c
  uint32_t isp_afm_var_shift; //!< Variable shift register (rw) MRV_AFM_BASE + 0x00000020
  uint32_t isp_afm_sum_a; //!< Sharpness Value Status Register of Window A (r) MRV_AFM_BASE + 0x00000024
  uint32_t isp_afm_sum_b; //!< Sharpness Value Status Register of Window B (r) MRV_AFM_BASE + 0x00000028
  uint32_t isp_afm_sum_c; //!< Sharpness Value Status Register of Window C (r) MRV_AFM_BASE + 0x0000002c
  uint32_t isp_afm_lum_a; //!< Luminance Value Status Register of Window A (r) MRV_AFM_BASE + 0x00000030
  uint32_t isp_afm_lum_b; //!< Luminance Value Status Register of Window B (r) MRV_AFM_BASE + 0x00000034
  uint32_t isp_afm_lum_c; //!< Luminance Value Status Register of Window C (r) MRV_AFM_BASE + 0x00000038
  uint32_t _notused_23 [(0x00002200-0x0000203c)/4]; // gap in address space
  uint32_t isp_lsc_ctrl; //!< Lens shade control (rw) MRV_LSC_BASE + 0x00000000
  uint32_t isp_lsc_r_table_addr; //!< Table RAM Address for red component (rwhh) MRV_LSC_BASE + 0x00000004
  uint32_t isp_lsc_gr_table_addr; //!< Table RAM Address for green (red) component (rwhh) MRV_LSC_BASE + 0x00000008
  uint32_t isp_lsc_b_table_addr; //!< Table RAM Address for blue component (rwhh) MRV_LSC_BASE + 0x0000000c
  uint32_t isp_lsc_gb_table_addr; //!< Table RAM Address for green (blue) component (rwhh) MRV_LSC_BASE + 0x00000010
  uint32_t isp_lsc_r_table_data; //!< Sample table red (rw) MRV_LSC_BASE + 0x00000014
  uint32_t isp_lsc_gr_table_data; //!< Sample table green (red) (rw) MRV_LSC_BASE + 0x00000018
  uint32_t isp_lsc_b_table_data; //!< Sample table blue (rw) MRV_LSC_BASE + 0x0000001c
  uint32_t isp_lsc_gb_table_data; //!< Sample table green (blue) (rw) MRV_LSC_BASE + 0x00000020
  uint32_t isp_lsc_xgrad_01; //!< Gradient table x (rw) MRV_LSC_BASE + 0x00000024
  uint32_t isp_lsc_xgrad_23; //!< Gradient table x (rw) MRV_LSC_BASE + 0x00000028
  uint32_t isp_lsc_xgrad_45; //!< Gradient table x (rw) MRV_LSC_BASE + 0x0000002c
  uint32_t isp_lsc_xgrad_67; //!< Gradient table x (rw) MRV_LSC_BASE + 0x00000030
  uint32_t isp_lsc_ygrad_01; //!< Gradient table y (rw) MRV_LSC_BASE + 0x00000034
  uint32_t isp_lsc_ygrad_23; //!< Gradient table y (rw) MRV_LSC_BASE + 0x00000038
  uint32_t isp_lsc_ygrad_45; //!< Gradient table y (rw) MRV_LSC_BASE + 0x0000003c
  uint32_t isp_lsc_ygrad_67; //!< Gradient table y (rw) MRV_LSC_BASE + 0x00000040
  uint32_t isp_lsc_xsize_01; //!< Size table (rw) MRV_LSC_BASE + 0x00000044
  uint32_t isp_lsc_xsize_23; //!< Size table (rw) MRV_LSC_BASE + 0x00000048
  uint32_t isp_lsc_xsize_45; //!< Size table (rw) MRV_LSC_BASE + 0x0000004c
  uint32_t isp_lsc_xsize_67; //!< Size table (rw) MRV_LSC_BASE + 0x00000050
  uint32_t isp_lsc_ysize_01; //!< Size table (rw) MRV_LSC_BASE + 0x00000054
  uint32_t isp_lsc_ysize_23; //!< Size table (rw) MRV_LSC_BASE + 0x00000058
  uint32_t isp_lsc_ysize_45; //!< Size table (rw) MRV_LSC_BASE + 0x0000005c
  uint32_t isp_lsc_ysize_67; //!< Size table (rw) MRV_LSC_BASE + 0x00000060
  uint32_t isp_lsc_table_sel; //!< Lens shade table set selection (rw) MRV_LSC_BASE + 0x00000064
  uint32_t isp_lsc_status; //!< Lens shade status (r) MRV_LSC_BASE + 0x00000068
  uint32_t _notused_24 [(0x00002300-0x0000226c)/4]; // gap in address space
  uint32_t isp_is_ctrl; //!< Image Stabilization Control Register (rw) MRV_IS_BASE + 0x00000000
  uint32_t isp_is_recenter; //!< Recenter register (rw) MRV_IS_BASE + 0x00000004
  uint32_t isp_is_h_offs; //!< Horizontal offset of output window (rw) MRV_IS_BASE + 0x00000008
  uint32_t isp_is_v_offs; //!< Vertical offset of output window (rw) MRV_IS_BASE + 0x0000000c
  uint32_t isp_is_h_size; //!< Output horizontal picture size (rw) MRV_IS_BASE + 0x00000010
  uint32_t isp_is_v_size; //!< Output vertical picture size (rw) MRV_IS_BASE + 0x00000014
  uint32_t isp_is_max_dx; //!< Maximum Horizontal Displacement (rw) MRV_IS_BASE + 0x00000018
  uint32_t isp_is_max_dy; //!< Maximum Vertical Displacement (rw) MRV_IS_BASE + 0x0000001c
  uint32_t isp_is_displace; //!< Camera displacement (rw) MRV_IS_BASE + 0x00000020
  uint32_t isp_is_h_offs_shd; //!< current horizontal offset of output window (shadow register) (r) MRV_IS_BASE + 0x00000024
  uint32_t isp_is_v_offs_shd; //!< current vertical offset of output window (shadow register) (r) MRV_IS_BASE + 0x00000028
  uint32_t isp_is_h_size_shd; //!< current output horizontal picture size (shadow register) (r) MRV_IS_BASE + 0x0000002c
  uint32_t isp_is_v_size_shd; //!< current output vertical picture size (shadow register) (r) MRV_IS_BASE + 0x00000030
  uint32_t _notused_25 [(0x00002400-0x00002334)/4]; // gap in address space
  uint32_t isp_hist_prop; //!< Histogram properties (rw) MRV_HIST_BASE + 0x00000000
  uint32_t isp_hist_h_offs; //!< Histogram window horizontal offset for first window of 25 sub-windows (rw) MRV_HIST_BASE + 0x00000004
  uint32_t isp_hist_v_offs; //!< Histogram window vertical offset for first window of 25 sub-windows (rw) MRV_HIST_BASE + 0x00000008
  uint32_t isp_hist_h_size; //!< Horizontal (sub-)window size (rw) MRV_HIST_BASE + 0x0000000c
  uint32_t isp_hist_v_size; //!< Vertical (sub-)window size (rw) MRV_HIST_BASE + 0x00000010
  histogram_measurement_result_t histogram_measurement_result_arr[HISTOGRAM_MEASUREMENT_RESULT_ARR_SIZE]; //!< histogram_measurement_result MRV_HIST_BASE + 20 + (n*0x4) (n=0..15)
  uint32_t isp_hist_weight_00to30; //!< Weighting factor for sub-windows (rw) MRV_HIST_BASE + 0x00000054
  uint32_t isp_hist_weight_40to21; //!< Weighting factor for sub-windows (rw) MRV_HIST_BASE + 0x00000058
  uint32_t isp_hist_weight_31to12; //!< Weighting factor for sub-windows (rw) MRV_HIST_BASE + 0x0000005c
  uint32_t isp_hist_weight_22to03; //!< Weighting factor for sub-windows (rw) MRV_HIST_BASE + 0x00000060
  uint32_t isp_hist_weight_13to43; //!< Weighting factor for sub-windows (rw) MRV_HIST_BASE + 0x00000064
  uint32_t isp_hist_weight_04to34; //!< Weighting factor for sub-windows (rw) MRV_HIST_BASE + 0x00000068
  uint32_t isp_hist_weight_44; //!< Weighting factor for sub-windows (rw) MRV_HIST_BASE + 0x0000006c
  uint32_t _notused_26 [(0x00002500-0x00002470)/4]; // gap in address space
  uint32_t isp_filt_mode; //!< mode control register for the filter block (rw) MRV_FILT_BASE + 0x00000000
  uint32_t _notused_27 [(0x00002528-0x00002504)/4]; // gap in address space
  uint32_t isp_filt_thresh_bl0; //!< Blurring threshold 0 (rw) MRV_FILT_BASE + 0x00000028
  uint32_t isp_filt_thresh_bl1; //!< Blurring threshold 1 (rw) MRV_FILT_BASE + 0x0000002c
  uint32_t isp_filt_thresh_sh0; //!< Sharpening threshold 0 (rw) MRV_FILT_BASE + 0x00000030
  uint32_t isp_filt_thresh_sh1; //!< Sharpening threshold 1 (rw) MRV_FILT_BASE + 0x00000034
  uint32_t isp_filt_lum_weight; //!< Parameters for luminance weight function (rw) MRV_FILT_BASE + 0x00000038
  uint32_t isp_filt_fac_sh1; //!< filter factor sharp1 (rw) MRV_FILT_BASE + 0x0000003c
  uint32_t isp_filt_fac_sh0; //!< filter factor sharp0 (rw) MRV_FILT_BASE + 0x00000040
  uint32_t isp_filt_fac_mid; //!< filter factor middle (rw) MRV_FILT_BASE + 0x00000044
  uint32_t isp_filt_fac_bl0; //!< Parameter for blur 0 filter (rw) MRV_FILT_BASE + 0x00000048
  uint32_t isp_filt_fac_bl1; //!< Parameter for blur 1 filter (rw) MRV_FILT_BASE + 0x0000004c
  uint32_t _notused_28 [(0x00002580-0x00002550)/4]; // gap in address space
  uint32_t isp_cac_ctrl; //!< Control register for chromatic aberration correction (rw) MRV_CAC_BASE + 0x00000000
  uint32_t isp_cac_count_start; //!< Preload values for CAC pixel and line counter (rw) MRV_CAC_BASE + 0x00000004
  uint32_t isp_cac_a; //!< Linear Parameters for radial shift calculation (rw) MRV_CAC_BASE + 0x00000008
  uint32_t isp_cac_b; //!< Square Parameters for radial shift calculation (rw) MRV_CAC_BASE + 0x0000000c
  uint32_t isp_cac_c; //!< Cubical Parameters for radial shift calculation (rw) MRV_CAC_BASE + 0x00000010
  uint32_t isp_cac_x_norm; //!< Normalization parameters for calculation of image coordinate x_d relative to optical center (rw) MRV_CAC_BASE + 0x00000014
  uint32_t isp_cac_y_norm; //!< Normalization parameters for calculation of image coordinate y_d relative to optical center (rw) MRV_CAC_BASE + 0x00000018
  uint32_t _notused_29 [(0x00002600-0x0000259c)/4]; // gap in address space
  uint32_t isp_exp_ctrl; //!< Exposure control (rw) MRV_AE_BASE + 0x00000000
  uint32_t isp_exp_h_offset; //!< Horizontal offset for first block (rw) MRV_AE_BASE + 0x00000004
  uint32_t isp_exp_v_offset; //!< Vertical offset for first block (rw) MRV_AE_BASE + 0x00000008
  uint32_t isp_exp_h_size; //!< Horizontal size of one block (rw) MRV_AE_BASE + 0x0000000c
  uint32_t isp_exp_v_size; //!< Vertical size of one block (rw) MRV_AE_BASE + 0x00000010
  uint32_t isp_exp_mean_00; //!< Mean luminance value of block 00 (r) MRV_AE_BASE + 0x00000014
  uint32_t isp_exp_mean_10; //!< Mean luminance value of block 10 (r) MRV_AE_BASE + 0x00000018
  uint32_t isp_exp_mean_20; //!< Mean luminance value of block 20 (r) MRV_AE_BASE + 0x0000001c
  uint32_t isp_exp_mean_30; //!< Mean luminance value of block 30 (r) MRV_AE_BASE + 0x00000020
  uint32_t isp_exp_mean_40; //!< Mean luminance value of block 40 (r) MRV_AE_BASE + 0x00000024
  uint32_t isp_exp_mean_01; //!< Mean luminance value of block 01 (r) MRV_AE_BASE + 0x00000028
  uint32_t isp_exp_mean_11; //!< Mean luminance value of block 11 (r) MRV_AE_BASE + 0x0000002c
  uint32_t isp_exp_mean_21; //!< Mean luminance value of block 21 (r) MRV_AE_BASE + 0x00000030
  uint32_t isp_exp_mean_31; //!< Mean luminance value of block 31 (r) MRV_AE_BASE + 0x00000034
  uint32_t isp_exp_mean_41; //!< Mean luminance value of block 41 (r) MRV_AE_BASE + 0x00000038
  uint32_t isp_exp_mean_02; //!< Mean luminance value of block 02 (r) MRV_AE_BASE + 0x0000003c
  uint32_t isp_exp_mean_12; //!< Mean luminance value of block 12 (r) MRV_AE_BASE + 0x00000040
  uint32_t isp_exp_mean_22; //!< Mean luminance value of block 22 (r) MRV_AE_BASE + 0x00000044
  uint32_t isp_exp_mean_32; //!< Mean luminance value of block 32 (r) MRV_AE_BASE + 0x00000048
  uint32_t isp_exp_mean_42; //!< Mean luminance value of block 42 (r) MRV_AE_BASE + 0x0000004c
  uint32_t isp_exp_mean_03; //!< Mean luminance value of block 03 (r) MRV_AE_BASE + 0x00000050
  uint32_t isp_exp_mean_13; //!< Mean luminance value of block 13 (r) MRV_AE_BASE + 0x00000054
  uint32_t isp_exp_mean_23; //!< Mean luminance value of block 23 (r) MRV_AE_BASE + 0x00000058
  uint32_t isp_exp_mean_33; //!< Mean luminance value of block 33 (r) MRV_AE_BASE + 0x0000005c
  uint32_t isp_exp_mean_43; //!< Mean luminance value of block 43 (r) MRV_AE_BASE + 0x00000060
  uint32_t isp_exp_mean_04; //!< Mean luminance value of block 04 (r) MRV_AE_BASE + 0x00000064
  uint32_t isp_exp_mean_14; //!< Mean luminance value of block 14 (r) MRV_AE_BASE + 0x00000068
  uint32_t isp_exp_mean_24; //!< Mean luminance value of block 24 (r) MRV_AE_BASE + 0x0000006c
  uint32_t isp_exp_mean_34; //!< Mean luminance value of block 34 (r) MRV_AE_BASE + 0x00000070
  uint32_t isp_exp_mean_44; //!< Mean luminance value of block 44 (r) MRV_AE_BASE + 0x00000074
  uint32_t _notused_30 [(0x00002700-0x00002678)/4]; // gap in address space
  uint32_t isp_bls_ctrl; //!< global control register (rw) MRV_BLS_BASE + 0x00000000
  uint32_t isp_bls_samples; //!< samples register (rw) MRV_BLS_BASE + 0x00000004
  uint32_t isp_bls_h1_start; //!< window 1 horizontal start (rw) MRV_BLS_BASE + 0x00000008
  uint32_t isp_bls_h1_stop; //!< window 1 horizontal stop (rw) MRV_BLS_BASE + 0x0000000c
  uint32_t isp_bls_v1_start; //!< window 1 vertical start (rw) MRV_BLS_BASE + 0x00000010
  uint32_t isp_bls_v1_stop; //!< window 1 vertical stop (rw) MRV_BLS_BASE + 0x00000014
  uint32_t isp_bls_h2_start; //!< window 2 horizontal start (rw) MRV_BLS_BASE + 0x00000018
  uint32_t isp_bls_h2_stop; //!< window 2 horizontal stop (rw) MRV_BLS_BASE + 0x0000001c
  uint32_t isp_bls_v2_start; //!< window 2 vertical start (rw) MRV_BLS_BASE + 0x00000020
  uint32_t isp_bls_v2_stop; //!< window 2 vertical stop (rw) MRV_BLS_BASE + 0x00000024
  uint32_t isp_bls_a_fixed; //!< fixed black level A (rw) MRV_BLS_BASE + 0x00000028
  uint32_t isp_bls_b_fixed; //!< fixed black level B (rw) MRV_BLS_BASE + 0x0000002c
  uint32_t isp_bls_c_fixed; //!< fixed black level C (rw) MRV_BLS_BASE + 0x00000030
  uint32_t isp_bls_d_fixed; //!< fixed black level D (rw) MRV_BLS_BASE + 0x00000034
  uint32_t isp_bls_a_measured; //!< measured black level A (r) MRV_BLS_BASE + 0x00000038
  uint32_t isp_bls_b_measured; //!< measured black level B (r) MRV_BLS_BASE + 0x0000003c
  uint32_t isp_bls_c_measured; //!< measured black level C (r) MRV_BLS_BASE + 0x00000040
  uint32_t isp_bls_d_measured; //!< measured black level D (r) MRV_BLS_BASE + 0x00000044
  uint32_t _notused_31 [(0x00002800-0x00002748)/4]; // gap in address space
  uint32_t isp_dpf_mode; //!< Mode control for Denoising Pre-Filter block (rw) MRV_DPF_BASE + 0x00000000
  uint32_t isp_dpf_strength_r; //!< filter strength of the RED filter (rw) MRV_DPF_BASE + 0x00000004
  uint32_t isp_dpf_strength_g; //!< filter strength of the GREEN filter (rw) MRV_DPF_BASE + 0x00000008
  uint32_t isp_dpf_strength_b; //!< filter strength of the BLUE filter (rw) MRV_DPF_BASE + 0x0000000c
  uint32_t isp_dpf_s_weight_g_1_4; //!< Spatial Weights green channel 1 2 3 4 (rw) MRV_DPF_BASE + 0x00000010
  uint32_t isp_dpf_s_weight_g_5_6; //!< Spatial Weights green channel 5 6 (rw) MRV_DPF_BASE + 0x00000014
  uint32_t isp_dpf_s_weight_rb_1_4; //!< Spatial Weights red/blue channels 1 2 3 4 (rw) MRV_DPF_BASE + 0x00000018
  uint32_t isp_dpf_s_weight_rb_5_6; //!< Spatial Weights red/blue channels 5 6 (rw) MRV_DPF_BASE + 0x0000001c
  nlf_lookup_table_block_t nlf_lookup_table_block_arr[NLF_LOOKUP_TABLE_BLOCK_ARR_SIZE]; //!< nlf_lookup_table_block MRV_DPF_BASE + 32 + (n*0x4) (n=0..16)
  uint32_t isp_dpf_nf_gain_r; //!< noise function gain for red pixels (rw) MRV_DPF_BASE + 0x00000064
  uint32_t isp_dpf_nf_gain_gr; //!< noise function gain for green in red pixels (rw) MRV_DPF_BASE + 0x00000068
  uint32_t isp_dpf_nf_gain_gb; //!< noise function gain for green in blue pixels (rw) MRV_DPF_BASE + 0x0000006c
  uint32_t isp_dpf_nf_gain_b; //!< noise function gain for blue pixels (rw) MRV_DPF_BASE + 0x00000070
  uint32_t _notused_32 [(0x00002900-0x00002874)/4]; // gap in address space
  uint32_t isp_dpcc_mode; //!< Mode control for DPCC detection unit (rw) MRV_DPCC_BASE + 0x00000000
  uint32_t isp_dpcc_output_mode; //!< Interpolation mode for correction unit (rw) MRV_DPCC_BASE + 0x00000004
  uint32_t isp_dpcc_set_use; //!< DPCC methods set usage for detection (rw) MRV_DPCC_BASE + 0x00000008
  uint32_t isp_dpcc_methods_set_1; //!< Methods enable bits for SET_1 (rw) MRV_DPCC_BASE + 0x0000000c
  uint32_t isp_dpcc_methods_set_2; //!< Methods enable bits for SET_2 (rw) MRV_DPCC_BASE + 0x00000010
  uint32_t isp_dpcc_methods_set_3; //!< Methods enable bits for SET_3 (rw) MRV_DPCC_BASE + 0x00000014
  uint32_t isp_dpcc_line_thresh_1; //!< Line threshold SET_1 (rw) MRV_DPCC_BASE + 0x00000018
  uint32_t isp_dpcc_line_mad_fac_1; //!< Mean Absolute Difference (MAD) factor for Line check set 1 (rw) MRV_DPCC_BASE + 0x0000001c
  uint32_t isp_dpcc_pg_fac_1; //!< Peak gradient factor for set 1 (rw) MRV_DPCC_BASE + 0x00000020
  uint32_t isp_dpcc_rnd_thresh_1; //!< Rank Neighbor Difference threshold for set 1 (rw) MRV_DPCC_BASE + 0x00000024
  uint32_t isp_dpcc_rg_fac_1; //!< Rank gradient factor for set 1 (rw) MRV_DPCC_BASE + 0x00000028
  uint32_t isp_dpcc_line_thresh_2; //!< Line threshold set 2 (rw) MRV_DPCC_BASE + 0x0000002c
  uint32_t isp_dpcc_line_mad_fac_2; //!< Mean Absolute Difference (MAD) factor for Line check set 2 (rw) MRV_DPCC_BASE + 0x00000030
  uint32_t isp_dpcc_pg_fac_2; //!< Peak gradient factor for set 2 (rw) MRV_DPCC_BASE + 0x00000034
  uint32_t isp_dpcc_rnd_thresh_2; //!< Rank Neighbor Difference threshold for set 2 (rw) MRV_DPCC_BASE + 0x00000038
  uint32_t isp_dpcc_rg_fac_2; //!< Rank gradient factor for set 2 (rw) MRV_DPCC_BASE + 0x0000003c
  uint32_t isp_dpcc_line_thresh_3; //!< Line threshold set 3 (rw) MRV_DPCC_BASE + 0x00000040
  uint32_t isp_dpcc_line_mad_fac_3; //!< Mean Absolute Difference (MAD) factor for Line check set 3 (rw) MRV_DPCC_BASE + 0x00000044
  uint32_t isp_dpcc_pg_fac_3; //!< Peak gradient factor for set 3 (rw) MRV_DPCC_BASE + 0x00000048
  uint32_t isp_dpcc_rnd_thresh_3; //!< Rank Neighbor Difference threshold for set 3 (rw) MRV_DPCC_BASE + 0x0000004c
  uint32_t isp_dpcc_rg_fac_3; //!< Rank gradient factor for set 3 (rw) MRV_DPCC_BASE + 0x00000050
  uint32_t isp_dpcc_ro_limits; //!< Rank Order Limits (rw) MRV_DPCC_BASE + 0x00000054
  uint32_t isp_dpcc_rnd_offs; //!< Differential Rank Offsets for Rank Neighbor Difference (rw) MRV_DPCC_BASE + 0x00000058
  uint32_t isp_dpcc_bpt_ctrl; //!< bad pixel table settings (rw) MRV_DPCC_BASE + 0x0000005c
  uint32_t isp_dpcc_bpt_number; //!< Number of entries for bad pixel table (table based correction) (rw) MRV_DPCC_BASE + 0x00000060
  uint32_t isp_dpcc_bpt_addr; //!< TABLE Start Address for table-based correction algorithm (rwhh) MRV_DPCC_BASE + 0x00000064
  uint32_t isp_dpcc_bpt_data; //!< TABLE DATA register for read and write access of table RAM (rwhh) MRV_DPCC_BASE + 0x00000068
  uint32_t _notused_33 [(0x00002a00-0x0000296c)/4]; // gap in address space
  uint32_t isp_wdr_ctrl; //!< Control Bits for Wide Dynamic Range Unit (rw) MRV_WDR_BASE + 0x00000000
  uint32_t isp_wdr_tonecurve_1; //!< Tone Curve sample points dYn definition (part 1) (rw) MRV_WDR_BASE + 0x00000004
  uint32_t isp_wdr_tonecurve_2; //!< Tone Curve sample points dYn definition (part 2) (rw) MRV_WDR_BASE + 0x00000008
  uint32_t isp_wdr_tonecurve_3; //!< Tone Curve sample points dYn definition (part 3) (rw) MRV_WDR_BASE + 0x0000000c
  uint32_t isp_wdr_tonecurve_4; //!< Tone Curve sample points dYn definition (part 4) (rw) MRV_WDR_BASE + 0x00000010
  wdr_tone_mapping_curve_y_block_t wdr_tone_mapping_curve_y_block_arr[WDR_TONE_MAPPING_CURVE_Y_BLOCK_ARR_SIZE]; //!< wdr_tone_mapping_curve_y_block MRV_WDR_BASE + 20 + (n*0x4) (n=0..32)
  uint32_t isp_wdr_offset; //!< Offset values for RGB path (rw) MRV_WDR_BASE + 0x00000098
  uint32_t isp_wdr_deltamin; //!< DeltaMin Threshold and Strength factor (rw) MRV_WDR_BASE + 0x0000009c
  uint32_t isp_wdr_tonecurve_1_shd; //!< Tone Curve sample points dYn definition shadow register (part 1) (r) MRV_WDR_BASE + 0x000000a0
  uint32_t isp_wdr_tonecurve_2_shd; //!< Tone Curve sample points dYn definition shadow register (part 2) (r) MRV_WDR_BASE + 0x000000a4
  uint32_t isp_wdr_tonecurve_3_shd; //!< Tone Curve sample points dYn definition shadow register (part 3) (r) MRV_WDR_BASE + 0x000000a8
  uint32_t isp_wdr_tonecurve_4_shd; //!< Tone Curve sample points dYn definition shadow register(part 4) (r) MRV_WDR_BASE + 0x000000ac
  wdr_tone_mapping_curve_y_shd_block_t wdr_tone_mapping_curve_y_shd_block_arr[WDR_TONE_MAPPING_CURVE_Y_SHD_BLOCK_ARR_SIZE]; //!< wdr_tone_mapping_curve_y_shd_block MRV_WDR_BASE + 176 + (n*0x4) (n=0..32)
  uint32_t _notused_34 [(0x00002c00-0x00002b34)/4]; // gap in address space
  uint32_t awb_meas_mode; //!< AWB Measure Mode (rw) ISP_AWB_BASE + 0x00000000
  uint32_t awb_meas_h_offs; //!< AWB window horizontal offset (rw) ISP_AWB_BASE + 0x00000004
  uint32_t awb_meas_v_offs; //!< AWB window vertical offset (rw) ISP_AWB_BASE + 0x00000008
  uint32_t awb_meas_h_size; //!< Horizontal window size (rw) ISP_AWB_BASE + 0x0000000c
  uint32_t awb_meas_v_size; //!< Vertical window size (rw) ISP_AWB_BASE + 0x00000010
  uint32_t awb_meas_r_min_max; //!< Min Max Compare Red (rw) ISP_AWB_BASE + 0x00000014
  uint32_t awb_meas_g_min_max; //!< Min Max Compare Green (rw) ISP_AWB_BASE + 0x00000018
  uint32_t awb_meas_b_min_max; //!< Min Max Compare Blue (rw) ISP_AWB_BASE + 0x0000001c
  uint32_t awb_meas_divider_min; //!< Min Compare Divider (rw) ISP_AWB_BASE + 0x00000020
  uint32_t awb_meas_csc_coeff_0; //!< Color conversion coefficient 0 (rw) ISP_AWB_BASE + 0x00000024
  uint32_t awb_meas_csc_coeff_1; //!< Color conversion coefficient 1 (rw) ISP_AWB_BASE + 0x00000028
  uint32_t awb_meas_csc_coeff_2; //!< Color conversion coefficient 2 (rw) ISP_AWB_BASE + 0x0000002c
  uint32_t awb_meas_csc_coeff_3; //!< Color conversion coefficient 3 (rw) ISP_AWB_BASE + 0x00000030
  uint32_t awb_meas_csc_coeff_4; //!< Color conversion coefficient 4 (rw) ISP_AWB_BASE + 0x00000034
  uint32_t awb_meas_csc_coeff_5; //!< Color conversion coefficient 5 (rw) ISP_AWB_BASE + 0x00000038
  uint32_t awb_meas_csc_coeff_6; //!< Color conversion coefficient 6 (rw) ISP_AWB_BASE + 0x0000003c
  uint32_t awb_meas_csc_coeff_7; //!< Color conversion coefficient 7 (rw) ISP_AWB_BASE + 0x00000040
  uint32_t awb_meas_csc_coeff_8; //!< Color conversion coefficient 8 (rw) ISP_AWB_BASE + 0x00000044
  uint32_t awb_meas_ellip1_cen_x; //!< Ellipse 1 Center X (rw) ISP_AWB_BASE + 0x00000048
  uint32_t awb_meas_ellip1_cen_y; //!< Ellipse 1 Center Y (rw) ISP_AWB_BASE + 0x0000004c
  uint32_t awb_meas_ellip2_cen_x; //!< Ellipse 2 Center X (rw) ISP_AWB_BASE + 0x00000050
  uint32_t awb_meas_ellip2_cen_y; //!< Ellipse 2 Center Y (rw) ISP_AWB_BASE + 0x00000054
  uint32_t awb_meas_ellip3_cen_x; //!< Ellipse 3 Center X (rw) ISP_AWB_BASE + 0x00000058
  uint32_t awb_meas_ellip3_cen_y; //!< Ellipse 3 Center Y (rw) ISP_AWB_BASE + 0x0000005c
  uint32_t awb_meas_ellip4_cen_x; //!< Ellipse 4 Center X (rw) ISP_AWB_BASE + 0x00000060
  uint32_t awb_meas_ellip4_cen_y; //!< Ellipse 4 Center Y (rw) ISP_AWB_BASE + 0x00000064
  uint32_t awb_meas_ellip5_cen_x; //!< Ellipse 5 Center X (rw) ISP_AWB_BASE + 0x00000068
  uint32_t awb_meas_ellip5_cen_y; //!< Ellipse 5 Center Y (rw) ISP_AWB_BASE + 0x0000006c
  uint32_t awb_meas_ellip6_cen_x; //!< Ellipse 6 Center X (rw) ISP_AWB_BASE + 0x00000070
  uint32_t awb_meas_ellip6_cen_y; //!< Ellipse 6 Center Y (rw) ISP_AWB_BASE + 0x00000074
  uint32_t awb_meas_ellip7_cen_x; //!< Ellipse 7 Center X (rw) ISP_AWB_BASE + 0x00000078
  uint32_t awb_meas_ellip7_cen_y; //!< Ellipse 7 Center Y (rw) ISP_AWB_BASE + 0x0000007c
  uint32_t awb_meas_ellip8_cen_x; //!< Ellipse 8 Center X (rw) ISP_AWB_BASE + 0x00000080
  uint32_t awb_meas_ellip8_cen_y; //!< Ellipse 8 Center Y (rw) ISP_AWB_BASE + 0x00000084
  uint32_t awb_meas_ellip1_a1; //!< Ellipse 1 coefficient a1 (rw) ISP_AWB_BASE + 0x00000088
  uint32_t awb_meas_ellip1_a2; //!< Ellipse 1 coefficient a2 (rw) ISP_AWB_BASE + 0x0000008c
  uint32_t awb_meas_ellip1_a3; //!< Ellipse 1 coefficient a3 (rw) ISP_AWB_BASE + 0x00000090
  uint32_t awb_meas_ellip1_a4; //!< Ellipse 1 coefficient a4 (rw) ISP_AWB_BASE + 0x00000094
  uint32_t awb_meas_ellip2_a1; //!< Ellipse 2 coefficient a1 (rw) ISP_AWB_BASE + 0x00000098
  uint32_t awb_meas_ellip2_a2; //!< Ellipse 2 coefficient a2 (rw) ISP_AWB_BASE + 0x0000009c
  uint32_t awb_meas_ellip2_a3; //!< Ellipse 2 coefficient a3 (rw) ISP_AWB_BASE + 0x000000a0
  uint32_t awb_meas_ellip2_a4; //!< Ellipse 2 coefficient a4 (rw) ISP_AWB_BASE + 0x000000a4
  uint32_t awb_meas_ellip3_a1; //!< Ellipse 3 coefficient a1 (rw) ISP_AWB_BASE + 0x000000a8
  uint32_t awb_meas_ellip3_a2; //!< Ellipse 3 coefficient a2 (rw) ISP_AWB_BASE + 0x000000ac
  uint32_t awb_meas_ellip3_a3; //!< Ellipse 3 coefficient a3 (rw) ISP_AWB_BASE + 0x000000b0
  uint32_t awb_meas_ellip3_a4; //!< Ellipse 3 coefficient a4 (rw) ISP_AWB_BASE + 0x000000b4
  uint32_t awb_meas_ellip4_a1; //!< Ellipse 4 coefficient a1 (rw) ISP_AWB_BASE + 0x000000b8
  uint32_t awb_meas_ellip4_a2; //!< Ellipse 4 coefficient a2 (rw) ISP_AWB_BASE + 0x000000bc
  uint32_t awb_meas_ellip4_a3; //!< Ellipse 4 coefficient a3 (rw) ISP_AWB_BASE + 0x000000c0
  uint32_t awb_meas_ellip4_a4; //!< Ellipse 4 coefficient a4 (rw) ISP_AWB_BASE + 0x000000c4
  uint32_t awb_meas_ellip5_a1; //!< Ellipse 5 coefficient a1 (rw) ISP_AWB_BASE + 0x000000c8
  uint32_t awb_meas_ellip5_a2; //!< Ellipse 5 coefficient a2 (rw) ISP_AWB_BASE + 0x000000cc
  uint32_t awb_meas_ellip5_a3; //!< Ellipse 5 coefficient a3 (rw) ISP_AWB_BASE + 0x000000d0
  uint32_t awb_meas_ellip5_a4; //!< Ellipse 5 coefficient a4 (rw) ISP_AWB_BASE + 0x000000d4
  uint32_t awb_meas_ellip6_a1; //!< Ellipse 6 coefficient a1 (rw) ISP_AWB_BASE + 0x000000d8
  uint32_t awb_meas_ellip6_a2; //!< Ellipse 6 coefficient a2 (rw) ISP_AWB_BASE + 0x000000dc
  uint32_t awb_meas_ellip6_a3; //!< Ellipse 6 coefficient a3 (rw) ISP_AWB_BASE + 0x000000e0
  uint32_t awb_meas_ellip6_a4; //!< Ellipse 6 coefficient a4 (rw) ISP_AWB_BASE + 0x000000e4
  uint32_t awb_meas_ellip7_a1; //!< Ellipse 7 coefficient a1 (rw) ISP_AWB_BASE + 0x000000e8
  uint32_t awb_meas_ellip7_a2; //!< Ellipse 7 coefficient a2 (rw) ISP_AWB_BASE + 0x000000ec
  uint32_t awb_meas_ellip7_a3; //!< Ellipse 7 coefficient a3 (rw) ISP_AWB_BASE + 0x000000f0
  uint32_t awb_meas_ellip7_a4; //!< Ellipse 7 coefficient a4 (rw) ISP_AWB_BASE + 0x000000f4
  uint32_t awb_meas_ellip8_a1; //!< Ellipse 8 coefficient a1 (rw) ISP_AWB_BASE + 0x000000f8
  uint32_t awb_meas_ellip8_a2; //!< Ellipse 8 coefficient a2 (rw) ISP_AWB_BASE + 0x000000fc
  uint32_t awb_meas_ellip8_a3; //!< Ellipse 8 coefficient a3 (rw) ISP_AWB_BASE + 0x00000100
  uint32_t awb_meas_ellip8_a4; //!< Ellipse 8 coefficient a4 (rw) ISP_AWB_BASE + 0x00000104
  uint32_t awb_meas_ellip1_rmax; //!< Ellipse 1 r_max (rw) ISP_AWB_BASE + 0x00000108
  uint32_t awb_meas_ellip2_rmax; //!< Ellipse 2 r_max (rw) ISP_AWB_BASE + 0x0000010c
  uint32_t awb_meas_ellip3_rmax; //!< Ellipse 3 r_max (rw) ISP_AWB_BASE + 0x00000110
  uint32_t awb_meas_ellip4_rmax; //!< Ellipse 4 r_max (rw) ISP_AWB_BASE + 0x00000114
  uint32_t awb_meas_ellip5_rmax; //!< Ellipse 5 r_max (rw) ISP_AWB_BASE + 0x00000118
  uint32_t awb_meas_ellip6_rmax; //!< Ellipse 6 r_max (rw) ISP_AWB_BASE + 0x0000011c
  uint32_t awb_meas_ellip7_rmax; //!< Ellipse 7 r_max (rw) ISP_AWB_BASE + 0x00000120
  uint32_t awb_meas_ellip8_rmax; //!< Ellipse 8 r_max (rw) ISP_AWB_BASE + 0x00000124
  uint32_t awb_meas_counter_1; //!< AWB Counter 1 (r) ISP_AWB_BASE + 0x00000128
  uint32_t awb_meas_counter_2; //!< AWB Counter 2 (r) ISP_AWB_BASE + 0x0000012c
  uint32_t awb_meas_counter_3; //!< AWB Counter 3 (r) ISP_AWB_BASE + 0x00000130
  uint32_t awb_meas_counter_4; //!< AWB Counter 4 (r) ISP_AWB_BASE + 0x00000134
  uint32_t awb_meas_counter_5; //!< AWB Counter 5 (r) ISP_AWB_BASE + 0x00000138
  uint32_t awb_meas_counter_6; //!< AWB Counter 6 (r) ISP_AWB_BASE + 0x0000013c
  uint32_t awb_meas_counter_7; //!< AWB Counter 7 (r) ISP_AWB_BASE + 0x00000140
  uint32_t awb_meas_counter_8; //!< AWB Counter 8 (r) ISP_AWB_BASE + 0x00000144
  AWB_MEAS_ACCU_t AWB_MEAS_ACCU_arr[AWB_MEAS_ACCU_ARR_SIZE]; //!< AWB_MEAS_ACCU ISP_AWB_BASE + 328 + (n*0x4) (n=0..23)
  uint32_t _notused_35 [(0x00002e00-0x00002da8)/4]; // gap in address space
  uint32_t isp64_hist_ctrl; //!< Histogram control (rw) MRV_HIST_BASE + 0x00000000
  uint32_t isp64_hist_prop; //!< Histogram properties (sh_rw) MRV_HIST_BASE + 0x00000004
  uint32_t isp64_hist_subsampling; //!< Subsampling properties (sh_rw) MRV_HIST_BASE + 0x00000008
  uint32_t isp64_hist_coeff_r; //!< Color conversion coefficient for red (sh_rw) MRV_HIST_BASE + 0x0000000c
  uint32_t isp64_hist_coeff_g; //!< Color conversion coefficient for green (sh_rw) MRV_HIST_BASE + 0x00000010
  uint32_t isp64_hist_coeff_b; //!< Color conversion coefficient for blue (sh_rw) MRV_HIST_BASE + 0x00000014
  uint32_t isp64_hist_h_offs; //!< Histogram window horizontal offset for first window of 25 sub-windows (sh_rw) MRV_HIST_BASE + 0x00000018
  uint32_t isp64_hist_v_offs; //!< Histogram window vertical offset for first window of 25 sub-windows (sh_rw) MRV_HIST_BASE + 0x0000001c
  uint32_t isp64_hist_h_size; //!< Horizontal (sub-)window size (sh_rw) MRV_HIST_BASE + 0x00000020
  uint32_t isp64_hist_v_size; //!< Vertical (sub-)window size (sh_rw) MRV_HIST_BASE + 0x00000024
  uint32_t isp64_hist_sample_range; //!< Weighting factor for sub-windows (sh_rw) MRV_HIST_BASE + 0x00000028
  uint32_t isp64_hist_weight_00to30; //!< Weighting factor for sub-windows (sh_rw) MRV_HIST_BASE + 0x0000002c
  uint32_t isp64_hist_weight_40to21; //!< Weighting factor for sub-windows (sh_rw) MRV_HIST_BASE + 0x00000030
  uint32_t isp64_hist_weight_31to12; //!< Weighting factor for sub-windows (sh_rw) MRV_HIST_BASE + 0x00000034
  uint32_t isp64_hist_weight_22to03; //!< Weighting factor for sub-windows (sh_rw) MRV_HIST_BASE + 0x00000038
  uint32_t isp64_hist_weight_13to43; //!< Weighting factor for sub-windows (sh_rw) MRV_HIST_BASE + 0x0000003c
  uint32_t isp64_hist_weight_04to34; //!< Weighting factor for sub-windows (sh_rw) MRV_HIST_BASE + 0x00000040
  uint32_t isp64_hist_weight_44; //!< Weighting factor for sub-windows (sh_rw) MRV_HIST_BASE + 0x00000044
  uint32_t isp64_hist_forced_upd_start_line; //!< Forced update start line limit (rw) MRV_HIST_BASE + 0x00000048
  uint32_t isp64_hist_forced_update; //!< Histogram forced update (w) MRV_HIST_BASE + 0x0000004c
  uint32_t isp64_hist_vstart_status; //!< Forced update start line status (sh_r) MRV_HIST_BASE + 0x00000050
  isp64_histogram_measurement_result_t isp64_histogram_measurement_result_arr[ISP64_HISTOGRAM_MEASUREMENT_RESULT_ARR_SIZE]; //!< isp64_histogram_measurement_result MRV_HIST_BASE + 84 + (n*0x4) (n=0..31)
  uint32_t _notused_36 [(0x00002f00-0x00002ed4)/4]; // gap in address space
  uint32_t isp_vsm_mode; //!< VS Measure Mode (rw) ISP_VSM_BASE + 0x00000000
  uint32_t isp_vsm_h_offs; //!< VSM window horizontal offset (rw) ISP_VSM_BASE + 0x00000004
  uint32_t isp_vsm_v_offs; //!< VSM window vertical offset (rw) ISP_VSM_BASE + 0x00000008
  uint32_t isp_vsm_h_size; //!< Horizontal measure window size (rw) ISP_VSM_BASE + 0x0000000c
  uint32_t isp_vsm_v_size; //!< Vertical measure window size (rw) ISP_VSM_BASE + 0x00000010
  uint32_t isp_vsm_h_segments; //!< Iteration 1 horizontal segments (rw) ISP_VSM_BASE + 0x00000014
  uint32_t isp_vsm_v_segments; //!< Iteration 1 vertical segments (rw) ISP_VSM_BASE + 0x00000018
  uint32_t isp_vsm_delta_h; //!< estimated horizontal displacement (r) ISP_VSM_BASE + 0x0000001c
  uint32_t isp_vsm_delta_v; //!< estimated vertical displacement (r) ISP_VSM_BASE + 0x00000020
} MrvAllRegister_t;


// - MASK AND SHIFT MARCOS ----------------------------------------------------------

//! Register: vi_ccl: Clock control register (0x00000000)
//! Slice: vi_ccl_dis:
//! Clock Control Logic disable 
// 0: processing/cfg-clocks for all marvin sub modules enabled 
// 1: processing/cfg-clocks for all marvin sub modules disabled w/o access to ID and VI_CCL register
#define MRV_VI_CCL_DIS
#define MRV_VI_CCL_DIS_MASK 0x00000004U
#define MRV_VI_CCL_DIS_SHIFT 2U
//! Slice: vi_ccl_dis_status:
//! Status of vi_ccl[2] bit (copy of vi_ccl[2])
#define MRV_VI_CCL_DIS_STATUS
#define MRV_VI_CCL_DIS_STATUS_MASK 0x00000002U
#define MRV_VI_CCL_DIS_STATUS_SHIFT 1U

//! Register: vi_id: Revision identification register (0x00000008)
//! Slice: rev_id:
//! MARVIN revision IDs: 
// M5_v1 id =  0x0015'3010  release 1.0 
// M5_v1 id =  0x1015'3010  release 1.1 
// M5_v2 id =  0x0025'3010 
// M5_v2 id =  0x0075'3010  release 2.0 (full feature set) 
// M5_v3 id =  0x0035'3010 
// M5_v3 id =  0x2035'3010  with bug fixes in MIPI, MI, LSC 
// M5_v4 id =  0x0045'3010 
// M5_v4 id =  0x1045'3010  with bug fixes in MIPI, MI, LSC 
// M5_v6 id =  0x0055'3010 
// M5_v7 id =  0x0065'3010 
// M12_v1 id (Rel. 1.0) = 0x0015'3017  
// M12_v1 id (Rel. 1.2) = 0x1015'3017  
// M12_v1 id (Rel. 2.0) = 0x2015'3017  
// M12_v1 id (Rel. 2.1) = 0x3015'3017  
// M12_v2 id = 0x0025'3017  
// M12_v3 id (Rel. 1.0) = 0x0065'3017  
// M12_v3 id (Rel. 1.1) = 0x1065'3017  
// M14_v1 id (Rel. 1.0) = 0x0075'3017  
// M14_v1 id (Rel. 1.1) = 0x1075'3017  
// M14_v2 id (Rel. 1.0) = 0x0085'3017  
// M18_v1 id = 0x0035'3017 (MarvinBase)  
// M20_v1 id (Rel. 1.0) = 0x0055'3017  
// M20_v1 id (Rel. 1.1) = 0x1055'3017  
// M20_v1 id (Rel. 1.2) = 0x2055'3017  
// M20_v2 id (Rel. 1.0) = 0x0095'3017  
// M64_v1 id = 0x0045'3017
#define MRV_REV_ID
#define MRV_REV_ID_MASK 0xFFFFFFFFU
#define MRV_REV_ID_SHIFT 0U

//! Register: vi_iccl: Internal clock  control register (0x00000010)
//! Slice: vi_mipi_clk_enable:
//! MIPI interface clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_MIPI_CLK_ENABLE
#define MRV_VI_MIPI_CLK_ENABLE_MASK 0x00000800U
#define MRV_VI_MIPI_CLK_ENABLE_SHIFT 11U
//! Slice: vi_smia_clk_enable:
//! SMIA interface clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_SMIA_CLK_ENABLE
#define MRV_VI_SMIA_CLK_ENABLE_MASK 0x00000400U
#define MRV_VI_SMIA_CLK_ENABLE_SHIFT 10U
//! Slice: vi_simp_clk_enable:
//! Superimpose clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_SIMP_CLK_ENABLE
#define MRV_VI_SIMP_CLK_ENABLE_MASK 0x00000200U
#define MRV_VI_SIMP_CLK_ENABLE_SHIFT 9U
//! Slice: vi_ie_clk_enable:
//! Image effect clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_IE_CLK_ENABLE
#define MRV_VI_IE_CLK_ENABLE_MASK 0x00000100U
#define MRV_VI_IE_CLK_ENABLE_SHIFT 8U
//! Slice: vi_mi_clk_enable:
//! memory interface clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_MI_CLK_ENABLE
#define MRV_VI_MI_CLK_ENABLE_MASK 0x00000040U
#define MRV_VI_MI_CLK_ENABLE_SHIFT 6U
//! Slice: vi_jpeg_clk_enable:
//! JPEG encoder clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_JPEG_CLK_ENABLE
#define MRV_VI_JPEG_CLK_ENABLE_MASK 0x00000020U
#define MRV_VI_JPEG_CLK_ENABLE_SHIFT 5U
//! Slice: vi_srsz_clk_enable:
//! self picture resize clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_SRSZ_CLK_ENABLE
#define MRV_VI_SRSZ_CLK_ENABLE_MASK 0x00000010U
#define MRV_VI_SRSZ_CLK_ENABLE_SHIFT 4U
//! Slice: vi_mrsz_clk_enable:
//! main picture resize clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_MRSZ_CLK_ENABLE
#define MRV_VI_MRSZ_CLK_ENABLE_MASK 0x00000008U
#define MRV_VI_MRSZ_CLK_ENABLE_SHIFT 3U
//! Slice: vi_cp_clk_enable:
//! color processing clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_CP_CLK_ENABLE
#define MRV_VI_CP_CLK_ENABLE_MASK 0x00000002U
#define MRV_VI_CP_CLK_ENABLE_SHIFT 1U
//! Slice: vi_isp_clk_enable:
//! isp processing clock enable 
// 1: processing mode 
// 0: power safe
#define MRV_VI_ISP_CLK_ENABLE
#define MRV_VI_ISP_CLK_ENABLE_MASK 0x00000001U
#define MRV_VI_ISP_CLK_ENABLE_SHIFT 0U

//! Register: vi_ircl: Internal reset control register (0x00000014)
//! Slice: vi_mipi_soft_rst:
//! MIPI Interface software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_MIPI_SOFT_RST
#define MRV_VI_MIPI_SOFT_RST_MASK 0x00000800U
#define MRV_VI_MIPI_SOFT_RST_SHIFT 11U
//! Slice: vi_smia_soft_rst:
//! SMIA Interface software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_SMIA_SOFT_RST
#define MRV_VI_SMIA_SOFT_RST_MASK 0x00000400U
#define MRV_VI_SMIA_SOFT_RST_SHIFT 10U
//! Slice: vi_simp_soft_rst:
//! Superimpose software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_SIMP_SOFT_RST
#define MRV_VI_SIMP_SOFT_RST_MASK 0x00000200U
#define MRV_VI_SIMP_SOFT_RST_SHIFT 9U
//! Slice: vi_ie_soft_rst:
//! Image effect software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_IE_SOFT_RST
#define MRV_VI_IE_SOFT_RST_MASK 0x00000100U
#define MRV_VI_IE_SOFT_RST_SHIFT 8U
//! Slice: vi_marvin_rst:
//! hardware reset of entire marvin 
// 0: processing mode 
// 1: reset state
#define MRV_VI_MARVIN_RST
#define MRV_VI_MARVIN_RST_MASK 0x00000080U
#define MRV_VI_MARVIN_RST_SHIFT 7U
//! Slice: vi_mi_soft_rst:
//! memory interface software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_MI_SOFT_RST
#define MRV_VI_MI_SOFT_RST_MASK 0x00000040U
#define MRV_VI_MI_SOFT_RST_SHIFT 6U
//! Slice: vi_jpeg_soft_rst:
//! JPEG encoder software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_JPEG_SOFT_RST
#define MRV_VI_JPEG_SOFT_RST_MASK 0x00000020U
#define MRV_VI_JPEG_SOFT_RST_SHIFT 5U
//! Slice: vi_srsz_soft_rst:
//! Self-picture resize software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_SRSZ_SOFT_RST
#define MRV_VI_SRSZ_SOFT_RST_MASK 0x00000010U
#define MRV_VI_SRSZ_SOFT_RST_SHIFT 4U
//! Slice: vi_mrsz_soft_rst:
//! Main-picture resize software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_MRSZ_SOFT_RST
#define MRV_VI_MRSZ_SOFT_RST_MASK 0x00000008U
#define MRV_VI_MRSZ_SOFT_RST_SHIFT 3U
//! Slice: vi_ycs_soft_rst:
//! y/c splitter software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_YCS_SOFT_RST
#define MRV_VI_YCS_SOFT_RST_MASK 0x00000004U
#define MRV_VI_YCS_SOFT_RST_SHIFT 2U
//! Slice: vi_cp_soft_rst:
//! color processing software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_CP_SOFT_RST
#define MRV_VI_CP_SOFT_RST_MASK 0x00000002U
#define MRV_VI_CP_SOFT_RST_SHIFT 1U
//! Slice: vi_isp_soft_rst:
//! isp software reset 
// 0: processing mode 
// 1: reset state
#define MRV_VI_ISP_SOFT_RST
#define MRV_VI_ISP_SOFT_RST_MASK 0x00000001U
#define MRV_VI_ISP_SOFT_RST_SHIFT 0U

//! Register: vi_dpcl: Data path control register (0x00000018)
//! Slice: vi_dma_spmux:
//! 0: data from camera interface to self resize 
// 1: data from DMA read port to self resize
#define MRV_VI_DMA_SPMUX
#define MRV_VI_DMA_SPMUX_MASK 0x00000800U
#define MRV_VI_DMA_SPMUX_SHIFT 11U
//! Slice: vi_dma_iemux:
//! 0: data from camera interface to image effects  
// 1: data from DMA read port to image effects
#define MRV_VI_DMA_IEMUX
#define MRV_VI_DMA_IEMUX_MASK 0x00000400U
#define MRV_VI_DMA_IEMUX_SHIFT 10U
//! Slice: if_select:
//! selects input interface 
// 0: parallel interface 
// 1: SMIA-interface 
// 2: MIPI1-interface 
// 3: reserved
#define MRV_IF_SELECT
#define MRV_IF_SELECT_MASK 0x00000300U
#define MRV_IF_SELECT_SHIFT 8U
//! Slice: vi_dma_switch:
//! DMA read data path selector 
// 0: path to SPMUX 
// 1: path to Superimpose 
// 2: path to Image Effects 
// 3: path to JPEG encoder 
// 4: path to ISP Bayer RGB 
// 5..7: reserved
#define MRV_VI_DMA_SWITCH
#define MRV_VI_DMA_SWITCH_MASK 0x00000070U
#define MRV_VI_DMA_SWITCH_SHIFT 4U
//! Slice: vi_chan_mode:
//! Y/C splitter channel mode 
// 0: disabled 
// 1: main path and raw data mode 
// 2: self path mode 
// 3: main and self path mode
#define MRV_VI_CHAN_MODE
#define MRV_VI_CHAN_MODE_MASK 0x0000000CU
#define MRV_VI_CHAN_MODE_SHIFT 2U
//! Slice: vi_mp_mux:
//! data path selector for main path 
// 00: data from DMA read port to JPEG encoder 
// 01: data from main resize to MI, uncompressed 
// 10: data from main resize to JPEG encoder 
// 11: reserved
#define MRV_VI_MP_MUX
#define MRV_VI_MP_MUX_MASK 0x00000003U
#define MRV_VI_MP_MUX_SHIFT 0U

//! Register: img_eff_ctrl: Global control register (0x00000000)
//! Slice: full_range:
//! '0': pixel value range according to BT.601 
// '1': YCbCr full range 0...255
#define MRV_IMGEFF_FULL_RANGE
#define MRV_IMGEFF_FULL_RANGE_MASK 0x00000020U
#define MRV_IMGEFF_FULL_RANGE_SHIFT 5U
//! Slice: cfg_upd:
//! write '0': nothing happens 
// write '1': update shadow registers 
// read: always '0'
#define MRV_IMGEFF_CFG_UPD
#define MRV_IMGEFF_CFG_UPD_MASK 0x00000010U
#define MRV_IMGEFF_CFG_UPD_SHIFT 4U
//! Slice: effect_mode:
//! effect mode 
// 000: black & white effect (grayscale) 
// 001: negative 
// 010: sepia effect 
// 011: color selection effect 
// 100: emboss effect 
// 101: sketch effect 
// 110: sharpen effect 
// 111: reserved
#define MRV_IMGEFF_EFFECT_MODE
#define MRV_IMGEFF_EFFECT_MODE_MASK 0x0000000EU
#define MRV_IMGEFF_EFFECT_MODE_SHIFT 1U
//! Slice: bypass_mode:
//! bypass mode 
// 1: processing is activated 
// 0: processing is deactivated, bypass mode is selected
#define MRV_IMGEFF_BYPASS_MODE
#define MRV_IMGEFF_BYPASS_MODE_MASK 0x00000001U
#define MRV_IMGEFF_BYPASS_MODE_SHIFT 0U

//! Register: img_eff_color_sel: Color selection register (for color selection effect) (0x00000004)
//! Slice: color_threshold:
//! Threshold value of the RGB colors for the color selection effect.
#define MRV_IMGEFF_COLOR_THRESHOLD
#define MRV_IMGEFF_COLOR_THRESHOLD_MASK 0x0000FF00U
#define MRV_IMGEFF_COLOR_THRESHOLD_SHIFT 8U
//! Slice: color_selection:
//! Defining the maintained color: 
// 000: red green and blue 
// 001: blue 
// 010: green 
// 011: green and blue 
// 100: red 
// 101: red and blue 
// 110: red and green 
// 111: red green and blue
#define MRV_IMGEFF_COLOR_SELECTION
#define MRV_IMGEFF_COLOR_SELECTION_MASK 0x00000007U
#define MRV_IMGEFF_COLOR_SELECTION_SHIFT 0U

//! Register: img_eff_mat_1: 3x3 matrix coefficients for emboss effect (1) (0x00000008)
//! Slice: emb_coef_21_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_EMB_COEF_21_EN
#define MRV_IMGEFF_EMB_COEF_21_EN_MASK 0x00008000U
#define MRV_IMGEFF_EMB_COEF_21_EN_SHIFT 15U
//! Slice: emb_coef_21:
//! second line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_EMB_COEF_21
#define MRV_IMGEFF_EMB_COEF_21_MASK 0x00007000U
#define MRV_IMGEFF_EMB_COEF_21_SHIFT 12U
//! Slice: emb_coef_13_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_EMB_COEF_13_EN
#define MRV_IMGEFF_EMB_COEF_13_EN_MASK 0x00000800U
#define MRV_IMGEFF_EMB_COEF_13_EN_SHIFT 11U
//! Slice: emb_coef_13:
//! first line, right entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_EMB_COEF_13
#define MRV_IMGEFF_EMB_COEF_13_MASK 0x00000700U
#define MRV_IMGEFF_EMB_COEF_13_SHIFT 8U
//! Slice: emb_coef_12_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_EMB_COEF_12_EN
#define MRV_IMGEFF_EMB_COEF_12_EN_MASK 0x00000080U
#define MRV_IMGEFF_EMB_COEF_12_EN_SHIFT 7U
//! Slice: emb_coef_12:
//! first line, middle entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_EMB_COEF_12
#define MRV_IMGEFF_EMB_COEF_12_MASK 0x00000070U
#define MRV_IMGEFF_EMB_COEF_12_SHIFT 4U
//! Slice: emb_coef_11_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_EMB_COEF_11_EN
#define MRV_IMGEFF_EMB_COEF_11_EN_MASK 0x00000008U
#define MRV_IMGEFF_EMB_COEF_11_EN_SHIFT 3U
//! Slice: emb_coef_11:
//! first line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_EMB_COEF_11
#define MRV_IMGEFF_EMB_COEF_11_MASK 0x00000007U
#define MRV_IMGEFF_EMB_COEF_11_SHIFT 0U

//! Register: img_eff_mat_2: 3x3 matrix coefficients for emboss effect (2) (0x0000000c)
//! Slice: emb_coef_32_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_EMB_COEF_32_EN
#define MRV_IMGEFF_EMB_COEF_32_EN_MASK 0x00008000U
#define MRV_IMGEFF_EMB_COEF_32_EN_SHIFT 15U
//! Slice: emb_coef_32:
//! third line, middle entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_EMB_COEF_32
#define MRV_IMGEFF_EMB_COEF_32_MASK 0x00007000U
#define MRV_IMGEFF_EMB_COEF_32_SHIFT 12U
//! Slice: emb_coef_31_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_EMB_COEF_31_EN
#define MRV_IMGEFF_EMB_COEF_31_EN_MASK 0x00000800U
#define MRV_IMGEFF_EMB_COEF_31_EN_SHIFT 11U
//! Slice: emb_coef_31:
//! third line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_EMB_COEF_31
#define MRV_IMGEFF_EMB_COEF_31_MASK 0x00000700U
#define MRV_IMGEFF_EMB_COEF_31_SHIFT 8U
//! Slice: emb_coef_23_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_EMB_COEF_23_EN
#define MRV_IMGEFF_EMB_COEF_23_EN_MASK 0x00000080U
#define MRV_IMGEFF_EMB_COEF_23_EN_SHIFT 7U
//! Slice: emb_coef_23:
//! second line, right entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_EMB_COEF_23
#define MRV_IMGEFF_EMB_COEF_23_MASK 0x00000070U
#define MRV_IMGEFF_EMB_COEF_23_SHIFT 4U
//! Slice: emb_coef_22_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_EMB_COEF_22_EN
#define MRV_IMGEFF_EMB_COEF_22_EN_MASK 0x00000008U
#define MRV_IMGEFF_EMB_COEF_22_EN_SHIFT 3U
//! Slice: emb_coef_22:
//! second line, middle entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_EMB_COEF_22
#define MRV_IMGEFF_EMB_COEF_22_MASK 0x00000007U
#define MRV_IMGEFF_EMB_COEF_22_SHIFT 0U

//! Register: img_eff_mat_3: 3x3 matrix coefficients for emboss(3) effect / sketch/sharpen(1) effect (0x00000010)
//! Slice: sket_coef_13_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_SKET_COEF_13_EN
#define MRV_IMGEFF_SKET_COEF_13_EN_MASK 0x00008000U
#define MRV_IMGEFF_SKET_COEF_13_EN_SHIFT 15U
//! Slice: sket_coef_13:
//! first line, right entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_SKET_COEF_13
#define MRV_IMGEFF_SKET_COEF_13_MASK 0x00007000U
#define MRV_IMGEFF_SKET_COEF_13_SHIFT 12U
//! Slice: sket_coef_12_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_SKET_COEF_12_EN
#define MRV_IMGEFF_SKET_COEF_12_EN_MASK 0x00000800U
#define MRV_IMGEFF_SKET_COEF_12_EN_SHIFT 11U
//! Slice: sket_coef_12:
//! first line, middle entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_SKET_COEF_12
#define MRV_IMGEFF_SKET_COEF_12_MASK 0x00000700U
#define MRV_IMGEFF_SKET_COEF_12_SHIFT 8U
//! Slice: sket_coef_11_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_SKET_COEF_11_EN
#define MRV_IMGEFF_SKET_COEF_11_EN_MASK 0x00000080U
#define MRV_IMGEFF_SKET_COEF_11_EN_SHIFT 7U
//! Slice: sket_coef_11:
//! first line, left entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_SKET_COEF_11
#define MRV_IMGEFF_SKET_COEF_11_MASK 0x00000070U
#define MRV_IMGEFF_SKET_COEF_11_SHIFT 4U
//! Slice: emb_coef_33_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_EMB_COEF_33_EN
#define MRV_IMGEFF_EMB_COEF_33_EN_MASK 0x00000008U
#define MRV_IMGEFF_EMB_COEF_33_EN_SHIFT 3U
//! Slice: emb_coef_33:
//! third line, right entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_EMB_COEF_33
#define MRV_IMGEFF_EMB_COEF_33_MASK 0x00000007U
#define MRV_IMGEFF_EMB_COEF_33_SHIFT 0U

//! Register: img_eff_mat_4: 3x3 matrix coefficients for sketch/sharpen effect (2) (0x00000014)
//! Slice: sket_coef_31_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_SKET_COEF_31_EN
#define MRV_IMGEFF_SKET_COEF_31_EN_MASK 0x00008000U
#define MRV_IMGEFF_SKET_COEF_31_EN_SHIFT 15U
//! Slice: sket_coef_31:
//! third line, left entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_SKET_COEF_31
#define MRV_IMGEFF_SKET_COEF_31_MASK 0x00007000U
#define MRV_IMGEFF_SKET_COEF_31_SHIFT 12U
//! Slice: sket_coef_23_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_SKET_COEF_23_EN
#define MRV_IMGEFF_SKET_COEF_23_EN_MASK 0x00000800U
#define MRV_IMGEFF_SKET_COEF_23_EN_SHIFT 11U
//! Slice: sket_coef_23:
//! second line, right entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_SKET_COEF_23
#define MRV_IMGEFF_SKET_COEF_23_MASK 0x00000700U
#define MRV_IMGEFF_SKET_COEF_23_SHIFT 8U
//! Slice: sket_coef_22_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_SKET_COEF_22_EN
#define MRV_IMGEFF_SKET_COEF_22_EN_MASK 0x00000080U
#define MRV_IMGEFF_SKET_COEF_22_EN_SHIFT 7U
//! Slice: sket_coef_22:
//! second line, middle entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_SKET_COEF_22
#define MRV_IMGEFF_SKET_COEF_22_MASK 0x00000070U
#define MRV_IMGEFF_SKET_COEF_22_SHIFT 4U
//! Slice: sket_coef_21_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_SKET_COEF_21_EN
#define MRV_IMGEFF_SKET_COEF_21_EN_MASK 0x00000008U
#define MRV_IMGEFF_SKET_COEF_21_EN_SHIFT 3U
//! Slice: sket_coef_21:
//! second line, left entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_SKET_COEF_21
#define MRV_IMGEFF_SKET_COEF_21_MASK 0x00000007U
#define MRV_IMGEFF_SKET_COEF_21_SHIFT 0U

//! Register: img_eff_mat_5: 3x3 matrix coefficients for sketch/sharpen effect (3) (0x00000018)
//! Slice: sket_coef_33_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_SKET_COEF_33_EN
#define MRV_IMGEFF_SKET_COEF_33_EN_MASK 0x00000080U
#define MRV_IMGEFF_SKET_COEF_33_EN_SHIFT 7U
//! Slice: sket_coef_33:
//! third line, right entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_SKET_COEF_33
#define MRV_IMGEFF_SKET_COEF_33_MASK 0x00000070U
#define MRV_IMGEFF_SKET_COEF_33_SHIFT 4U
//! Slice: sket_coef_32_en:
//! 0: entry not used (coefficient is zero) 
// 1: entry used
#define MRV_IMGEFF_SKET_COEF_32_EN
#define MRV_IMGEFF_SKET_COEF_32_EN_MASK 0x00000008U
#define MRV_IMGEFF_SKET_COEF_32_EN_SHIFT 3U
//! Slice: sket_coef_32:
//! third line, middle entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.
#define MRV_IMGEFF_SKET_COEF_32
#define MRV_IMGEFF_SKET_COEF_32_MASK 0x00000007U
#define MRV_IMGEFF_SKET_COEF_32_SHIFT 0U

//! Register: img_eff_tint: Chrominance increment values of a tint (used for sepia effect) (0x0000001c)
//! Slice: incr_cr:
//! Cr increment value of a tint. 7 bits for value, 1 sign bit. 
// Default tint is R=162 G=138 B=101, which is used for the sepia effect. See below for the calculation of the entries.
#define MRV_IMGEFF_INCR_CR
#define MRV_IMGEFF_INCR_CR_MASK 0x0000FF00U
#define MRV_IMGEFF_INCR_CR_SHIFT 8U
//! Slice: incr_cb:
//! Cb increment value of a tint. 7 bits for value, 1 sign bit. 
// Default tint is R=162 G=138 B=101, which is used for the sepia effect. See below for the calculation of the entries.
#define MRV_IMGEFF_INCR_CB
#define MRV_IMGEFF_INCR_CB_MASK 0x000000FFU
#define MRV_IMGEFF_INCR_CB_SHIFT 0U

//! Register: img_eff_ctrl_shd: Shadow register for control register (0x00000020)
//! Slice: effect_mode_shd:
//! effect mode 
// 000: black & white effect (grayscale) 
// 001: negative 
// 010: sepia effect 
// 011: color selection effect 
// 100: emboss effect 
// 101: sketch effect 
// 110: sharpen effect 
// 111: reserved
#define MRV_IMGEFF_EFFECT_MODE_SHD
#define MRV_IMGEFF_EFFECT_MODE_SHD_MASK 0x0000000EU
#define MRV_IMGEFF_EFFECT_MODE_SHD_SHIFT 1U

//! Register: img_eff_sharpen: Factor and threshold for sharpen effect (0x00000024)
//! Slice: sharp_factor:
//! 6Bit Factor for sharpening function. Value range is from 0x0 to 0x3F. High value means strong sharpening. The resulting factors are for example: 
// 0x00 =	0 (no sharpen effect like bypass)
// 0x01 =	0.25 
// 0x02 =	0.5 
// 0x03 =	0.75 
// 0x04 =	1.0 
// 0x05 =	1.25 
// 0x06 =	1.5 
// 0x08 =	2.0 
// 0x0A =	2.5 
// 0x0C =	3.0 
// 0x10 =	4.0 
// 0x18 =	6.0 
// 0x20 =	8.0 
// 0x30 =	12.0 
// 0x3F =	15.75
#define MRV_IMGEFF_SHARP_FACTOR
#define MRV_IMGEFF_SHARP_FACTOR_MASK 0x00003F00U
#define MRV_IMGEFF_SHARP_FACTOR_SHIFT 8U
//! Slice: coring_thr:
//! Threshold for coring function. This value is used to avoid amplifying noise too much by suppressing sharpening for small gradients. Higher value means less sharpening for smooth edges.  Threshold zero means no coring, so all gradients are treated the same. Threshold 255 means nearly no sharpening. An absolute value for the highpass signal is defined here. The highpass signal is truncated at the defined level.
#define MRV_IMGEFF_CORING_THR
#define MRV_IMGEFF_CORING_THR_MASK 0x000000FFU
#define MRV_IMGEFF_CORING_THR_SHIFT 0U

//! Register: super_imp_ctrl: Global control register (0x00000000)
//! Slice: transparency_mode:
//! transparency mode 
// 1: transparency mode disabled 
// 0: transparency mode enabled
#define MRV_SI_TRANSPARENCY_MODE
#define MRV_SI_TRANSPARENCY_MODE_MASK 0x00000004U
#define MRV_SI_TRANSPARENCY_MODE_SHIFT 2U
//! Slice: ref_image:
//! Define the reference image 
// 1: superimpose bitmap from main memory 
// 0: image from the Image Effect module 
// Note: the reference image defines the size of the output image
#define MRV_SI_REF_IMAGE
#define MRV_SI_REF_IMAGE_MASK 0x00000002U
#define MRV_SI_REF_IMAGE_SHIFT 1U
//! Slice: bypass_mode:
//! Bypass mode 
// 0: bypass mode 
// 1: normal operation 
// Note: in the bypass mode the data stream from Image Effect is transmitted to MUX module without overlaying
#define MRV_SI_BYPASS_MODE
#define MRV_SI_BYPASS_MODE_MASK 0x00000001U
#define MRV_SI_BYPASS_MODE_SHIFT 0U

//! Register: super_imp_offset_x: Offset x register (0x00000004)
//! Slice: offset_x:
//! Offset X 
// Note: the bit 0 is dont care (write 1 doesnt have any effect, the read access always gives 0) 
// Note: the offset_x is positive and refers to the reference image
#define MRV_SI_OFFSET_X
#define MRV_SI_OFFSET_X_MASK 0x00003FFEU
#define MRV_SI_OFFSET_X_SHIFT 1U

//! Register: super_imp_offset_y: Offset y register (0x00000008)
//! Slice: offset_y:
//! Offset Y 
// Note: the offset_y is positive and refers to the reference image
#define MRV_SI_OFFSET_Y
#define MRV_SI_OFFSET_Y_MASK 0x00003FFFU
#define MRV_SI_OFFSET_Y_SHIFT 0U

//! Register: super_imp_color_y: Y component of transparent key color (0x0000000c)
//! Slice: y_comp:
//! Y component of transparent key color
#define MRV_SI_Y_COMP
#define MRV_SI_Y_COMP_MASK 0x000000FFU
#define MRV_SI_Y_COMP_SHIFT 0U

//! Register: super_imp_color_cb: Cb component of transparent key color (0x00000010)
//! Slice: cb_comp:
//! Cb component of transparent key color
#define MRV_SI_CB_COMP
#define MRV_SI_CB_COMP_MASK 0x000000FFU
#define MRV_SI_CB_COMP_SHIFT 0U

//! Register: super_imp_color_cr: Cr component of transparent key color (0x00000014)
//! Slice: cr_comp:
//! Cr component of transparent key color
#define MRV_SI_CR_COMP
#define MRV_SI_CR_COMP_MASK 0x000000FFU
#define MRV_SI_CR_COMP_SHIFT 0U

//! Register: isp_ctrl: global control register (0x00000000)
//! Slice: CTRL_RESERVED_1:
//! reserved
#define MRV_ISP_CTRL_RESERVED_1
#define MRV_ISP_CTRL_RESERVED_1_MASK 0x00010000U
#define MRV_ISP_CTRL_RESERVED_1_SHIFT 16U
//! Slice: CTRL_RESERVED_2:
//! reserved
#define MRV_ISP_CTRL_RESERVED_2
#define MRV_ISP_CTRL_RESERVED_2_MASK 0x00008000U
#define MRV_ISP_CTRL_RESERVED_2_SHIFT 15U
//! Slice: ISP_CSM_C_RANGE:
//! Color Space Matrix chrominance clipping range for ISP output 
// 0: CbCr range 64..960 (16..240) according to ITU-R BT.601 standard 
// 1: full UV range 0..1023 ( 0..255)  
// Numbers in brackets are for 8 bit resolution. 
// This bit also configures the YCbCr sequence align block accordingly.
#define MRV_ISP_ISP_CSM_C_RANGE
#define MRV_ISP_ISP_CSM_C_RANGE_MASK 0x00004000U
#define MRV_ISP_ISP_CSM_C_RANGE_SHIFT 14U
//! Slice: ISP_CSM_Y_RANGE:
//! Color Space Matrix luminance clipping range for ISP output 
// 0: Y range 64..940 (16..235) according to ITU-R BT.601 standard 
// 1: full Y range 0..1023 ( 0..255)  
// Numbers in brackets are for 8 bit resolution. 
// This bit also configures the YCbCr sequence align block accordingly.
#define MRV_ISP_ISP_CSM_Y_RANGE
#define MRV_ISP_ISP_CSM_Y_RANGE_MASK 0x00002000U
#define MRV_ISP_ISP_CSM_Y_RANGE_SHIFT 13U
//! Slice: ISP_FLASH_MODE:
//! 0: sensor interface works independently from flash control unit 
// 1: one frame is captured when signaled by flash control unit
#define MRV_ISP_ISP_FLASH_MODE
#define MRV_ISP_ISP_FLASH_MODE_MASK 0x00001000U
#define MRV_ISP_ISP_FLASH_MODE_SHIFT 12U
//! Slice: ISP_GAMMA_OUT_ENABLE:
//! gamma ON/OFF
#define MRV_ISP_ISP_GAMMA_OUT_ENABLE
#define MRV_ISP_ISP_GAMMA_OUT_ENABLE_MASK 0x00000800U
#define MRV_ISP_ISP_GAMMA_OUT_ENABLE_SHIFT 11U
//! Slice: ISP_GEN_CFG_UPD:
//! 1: generate frame synchronous configuration signal at the output of ISP for shadow registers of the following processing modules, write only
#define MRV_ISP_ISP_GEN_CFG_UPD
#define MRV_ISP_ISP_GEN_CFG_UPD_MASK 0x00000400U
#define MRV_ISP_ISP_GEN_CFG_UPD_SHIFT 10U
//! Slice: ISP_CFG_UPD:
//! 1: immediately configure (update) shadow registers, write only
#define MRV_ISP_ISP_CFG_UPD
#define MRV_ISP_ISP_CFG_UPD_MASK 0x00000200U
#define MRV_ISP_ISP_CFG_UPD_SHIFT 9U
//! Slice: ISP_CFG_UPD_PERMANENT:
//! 1: permanent configure (update) shadow registers on frame end.
#define MRV_ISP_ISP_CFG_UPD_PERMANENT
#define MRV_ISP_ISP_CFG_UPD_PERMANENT_MASK 0x00000100U
#define MRV_ISP_ISP_CFG_UPD_PERMANENT_SHIFT 8U
//! Slice: ISP_AWB_ENABLE:
//! auto white balance ON/OFF
#define MRV_ISP_ISP_AWB_ENABLE
#define MRV_ISP_ISP_AWB_ENABLE_MASK 0x00000080U
#define MRV_ISP_ISP_AWB_ENABLE_SHIFT 7U
//! Slice: ISP_GAMMA_IN_ENABLE:
//! Sensor De-gamma ON/OFF
#define MRV_ISP_ISP_GAMMA_IN_ENABLE
#define MRV_ISP_ISP_GAMMA_IN_ENABLE_MASK 0x00000040U
#define MRV_ISP_ISP_GAMMA_IN_ENABLE_SHIFT 6U
//! Slice: ISP_INFORM_ENABLE:
//! 1: input formatter enabled 
// 0: input formatter disabled 
// The ISP input formatter is enabled or disabled by this bit immediately, but always starts or stops acquisition frame synchronously.
#define MRV_ISP_ISP_INFORM_ENABLE
#define MRV_ISP_ISP_INFORM_ENABLE_MASK 0x00000010U
#define MRV_ISP_ISP_INFORM_ENABLE_SHIFT 4U
//! Slice: ISP_MODE:
//! 000 - RAW picture with BT.601 sync (ISP bypass) 
// 001 - ITU-R BT.656 (YUV with embedded sync) 
// 010 - ITU-R BT.601 (YUV input with H and Vsync signals) 
// 011 - Bayer RGB processing with H and Vsync signals 
// 100 - data mode (ISP bypass, sync signals interpreted as data enable) 
// 101 - Bayer RGB processing with BT.656 synchronization 
// 110 - RAW picture with ITU-R BT.656 synchronization (ISP bypass) 
// 111 - reserved 
// 
// Side effect: 
// If RAW, BT.601, BT.656, or data mode is selected, the clock of the ISP SRAMs (ISP line buffer, Lens Shading, Bad Pixel) is switched off. Only in Bayer RGB mode the clock to the SRAMs is enabled. This further reduces power consumption.
#define MRV_ISP_ISP_MODE
#define MRV_ISP_ISP_MODE_MASK 0x0000000EU
#define MRV_ISP_ISP_MODE_SHIFT 1U
//! Slice: ISP_ENABLE:
//! 1: ISP data output enabled 
// 0: ISP data output disabled 
// Controls output formatter frame synchronously, if isp_gen_cfg_upd is used to activate this bit. For immediate update isp_cfg_upd must be used.
#define MRV_ISP_ISP_ENABLE
#define MRV_ISP_ISP_ENABLE_MASK 0x00000001U
#define MRV_ISP_ISP_ENABLE_SHIFT 0U

//! Register: isp_acq_prop: ISP acquisition properties (0x00000004)
//! Slice: DMA_YUV_SELECTION:
//! 0: use align or conversion data for isp_is input. 
// 1: use dma yuv read data for isp_is input.
#define MRV_ISP_DMA_YUV_SELECTION
#define MRV_ISP_DMA_YUV_SELECTION_MASK 0x00010000U
#define MRV_ISP_DMA_YUV_SELECTION_SHIFT 16U
//! Slice: DMA_RGB_SELECTION:
//! 0: use input formatter data for latency fifo. 
// 1: use dma rgb read data for latency fifo.
#define MRV_ISP_DMA_RGB_SELECTION
#define MRV_ISP_DMA_RGB_SELECTION_MASK 0x00008000U
#define MRV_ISP_DMA_RGB_SELECTION_SHIFT 15U
//! Slice: INPUT_SELECTION:
//! 000- 12Bit external Interface 
// 001- 10Bit Interface, append 2 zeroes as LSBs 
// 010- 10Bit Interface, append 2 MSBs as LSBs 
// 011- 8Bit Interface, append 4 zeroes as LSBs 
// 100- 8Bit Interface, append 4 MSBs as LSBs   
// 101...111 reserved
#define MRV_ISP_INPUT_SELECTION
#define MRV_ISP_INPUT_SELECTION_MASK 0x00007000U
#define MRV_ISP_INPUT_SELECTION_SHIFT 12U
//! Slice: FIELD_INV:
//! 1: swap odd and even fields 
// 0: do not swap fields
#define MRV_ISP_FIELD_INV
#define MRV_ISP_FIELD_INV_MASK 0x00000800U
#define MRV_ISP_FIELD_INV_SHIFT 11U
//! Slice: FIELD_SELECTION:
//! 00- sample all fields (dont care about fields) 
// 01- sample only even fields 
// 10- sample only odd fields 
// 11- reserved
#define MRV_ISP_FIELD_SELECTION
#define MRV_ISP_FIELD_SELECTION_MASK 0x00000600U
#define MRV_ISP_FIELD_SELECTION_SHIFT 9U
//! Slice: CCIR_SEQ:
//! 00- YCbYCr 
// 01- YCrYCb 
// 10- CbYCrY 
// 11- CrYCbY
#define MRV_ISP_CCIR_SEQ
#define MRV_ISP_CCIR_SEQ_MASK 0x00000180U
#define MRV_ISP_CCIR_SEQ_SHIFT 7U
//! Slice: CONV_422:
//! 00- co-sited color subsampling Y0Cb0Cr0  Y1 
// 01- interleaved color subsampling Y0Cb0  Y1Cr1 (not recommended) 
// 10- non-cosited color subsampling Y0Cb(0+1)/2  Y1Cr(0+1)/2 
// 11- reserved
#define MRV_ISP_CONV_422
#define MRV_ISP_CONV_422_MASK 0x00000060U
#define MRV_ISP_CONV_422_SHIFT 5U
//! Slice: BAYER_PAT:
//! color components from sensor, starting with top left position in sampled frame (reprogram with ISP_ACQ_H_OFFS, ISP_ACQ_V_OFFS) 
// 00- first line: RGRG..., second line: GBGB..., etc. 
// 01- first line: GRGR..., second line: BGBG..., etc. 
// 10- first line: GBGB..., second line: RGRG..., etc. 
// 11- first line: BGBG..., second line: GRGR..., etc. 
// This configuration applies for the black level area after cropping by the input formatter.
#define MRV_ISP_BAYER_PAT
#define MRV_ISP_BAYER_PAT_MASK 0x00000018U
#define MRV_ISP_BAYER_PAT_SHIFT 3U
//! Slice: VSYNC_POL:
//! vertical sync polarity 
// 0: high active 
// 1: low active
#define MRV_ISP_VSYNC_POL
#define MRV_ISP_VSYNC_POL_MASK 0x00000004U
#define MRV_ISP_VSYNC_POL_SHIFT 2U
//! Slice: HSYNC_POL:
//! horizontal sync polarity 
// 0: high active 
// 1: low active
#define MRV_ISP_HSYNC_POL
#define MRV_ISP_HSYNC_POL_MASK 0x00000002U
#define MRV_ISP_HSYNC_POL_SHIFT 1U
//! Slice: SAMPLE_EDGE:
//! 0- negative edge sampling 
// 1- positive edge sampling
#define MRV_ISP_SAMPLE_EDGE
#define MRV_ISP_SAMPLE_EDGE_MASK 0x00000001U
#define MRV_ISP_SAMPLE_EDGE_SHIFT 0U

//! Register: isp_acq_h_offs: horizontal input offset (0x00000008)
//! Slice: ACQ_H_OFFS:
//! horizontal sample offset in 8-bit samples (yuv: 4 samples=2pix)
#define MRV_ISP_ACQ_H_OFFS
#define MRV_ISP_ACQ_H_OFFS_MASK 0x00007FFFU
#define MRV_ISP_ACQ_H_OFFS_SHIFT 0U

//! Register: isp_acq_v_offs: vertical input offset (0x0000000c)
//! Slice: ACQ_V_OFFS:
//! vertical sample offset in lines
#define MRV_ISP_ACQ_V_OFFS
#define MRV_ISP_ACQ_V_OFFS_MASK 0x00003FFFU
#define MRV_ISP_ACQ_V_OFFS_SHIFT 0U

//! Register: isp_acq_h_size: horizontal input size (0x00000010)
//! Slice: ACQ_H_SIZE:
//! horizontal sample size in 12-bit samples 
// YUV input: 2 samples = 1 pixel, else 1 sample = 1 pixel; So in YUV mode ACQ_H_SIZE must be twice as large as horizontal image size 
// horizontal image size must always be even exept in raw picture mode; if an odd size is programmed the value will be truncated to even size
#define MRV_ISP_ACQ_H_SIZE
#define MRV_ISP_ACQ_H_SIZE_MASK 0x00007FFFU
#define MRV_ISP_ACQ_H_SIZE_SHIFT 0U

//! Register: isp_acq_v_size: vertical input size (0x00000014)
//! Slice: ACQ_V_SIZE:
//! vertical sample size in lines
#define MRV_ISP_ACQ_V_SIZE
#define MRV_ISP_ACQ_V_SIZE_MASK 0x00003FFFU
#define MRV_ISP_ACQ_V_SIZE_SHIFT 0U

//! Register: isp_acq_nr_frames: Number of frames to be captured (0x00000018)
//! Slice: ACQ_NR_FRAMES:
//! number of input frames to be sampled ( 0 = continuous )
#define MRV_ISP_ACQ_NR_FRAMES
#define MRV_ISP_ACQ_NR_FRAMES_MASK 0x000003FFU
#define MRV_ISP_ACQ_NR_FRAMES_SHIFT 0U

//! Register: isp_gamma_dx_lo: De-Gamma Curve definition lower x increments (sampling points) (0x0000001c)
//! Slice: GAMMA_DX_8:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_8
#define MRV_ISP_GAMMA_DX_8_MASK 0x70000000U
#define MRV_ISP_GAMMA_DX_8_SHIFT 28U
//! Slice: GAMMA_DX_7:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_7
#define MRV_ISP_GAMMA_DX_7_MASK 0x07000000U
#define MRV_ISP_GAMMA_DX_7_SHIFT 24U
//! Slice: GAMMA_DX_6:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_6
#define MRV_ISP_GAMMA_DX_6_MASK 0x00700000U
#define MRV_ISP_GAMMA_DX_6_SHIFT 20U
//! Slice: GAMMA_DX_5:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_5
#define MRV_ISP_GAMMA_DX_5_MASK 0x00070000U
#define MRV_ISP_GAMMA_DX_5_SHIFT 16U
//! Slice: GAMMA_DX_4:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_4
#define MRV_ISP_GAMMA_DX_4_MASK 0x00007000U
#define MRV_ISP_GAMMA_DX_4_SHIFT 12U
//! Slice: GAMMA_DX_3:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_3
#define MRV_ISP_GAMMA_DX_3_MASK 0x00000700U
#define MRV_ISP_GAMMA_DX_3_SHIFT 8U
//! Slice: GAMMA_DX_2:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_2
#define MRV_ISP_GAMMA_DX_2_MASK 0x00000070U
#define MRV_ISP_GAMMA_DX_2_SHIFT 4U
//! Slice: GAMMA_DX_1:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_1
#define MRV_ISP_GAMMA_DX_1_MASK 0x00000007U
#define MRV_ISP_GAMMA_DX_1_SHIFT 0U

//! Register: isp_gamma_dx_hi: De-Gamma Curve definition higher x increments (sampling points) (0x00000020)
//! Slice: GAMMA_DX_16:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_16
#define MRV_ISP_GAMMA_DX_16_MASK 0x70000000U
#define MRV_ISP_GAMMA_DX_16_SHIFT 28U
//! Slice: GAMMA_DX_15:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_15
#define MRV_ISP_GAMMA_DX_15_MASK 0x07000000U
#define MRV_ISP_GAMMA_DX_15_SHIFT 24U
//! Slice: GAMMA_DX_14:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_14
#define MRV_ISP_GAMMA_DX_14_MASK 0x00700000U
#define MRV_ISP_GAMMA_DX_14_SHIFT 20U
//! Slice: GAMMA_DX_13:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_13
#define MRV_ISP_GAMMA_DX_13_MASK 0x00070000U
#define MRV_ISP_GAMMA_DX_13_SHIFT 16U
//! Slice: GAMMA_DX_12:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_12
#define MRV_ISP_GAMMA_DX_12_MASK 0x00007000U
#define MRV_ISP_GAMMA_DX_12_SHIFT 12U
//! Slice: GAMMA_DX_11:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_11
#define MRV_ISP_GAMMA_DX_11_MASK 0x00000700U
#define MRV_ISP_GAMMA_DX_11_SHIFT 8U
//! Slice: GAMMA_DX_10:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_10
#define MRV_ISP_GAMMA_DX_10_MASK 0x00000070U
#define MRV_ISP_GAMMA_DX_10_SHIFT 4U
//! Slice: GAMMA_DX_9:
//! gamma curve sample point definition x-axis (input)
#define MRV_ISP_GAMMA_DX_9
#define MRV_ISP_GAMMA_DX_9_MASK 0x00000007U
#define MRV_ISP_GAMMA_DX_9_SHIFT 0U

//! Register array: isp_gamma_r_y: De-Gamma Curve definition y red (0x0048 + n*0x4 (n=0..16))
//! Slice: GAMMA_R_Y:
// gamma curve point definition y-axis (output) for red 
// RESTRICTION: each Y must be in the +2047/-2048 range compared to its predecessor (so that the difference between successive Y values is 12-bit signed !)
#define MRV_ISP_GAMMA_R_Y
#define MRV_ISP_GAMMA_R_Y_MASK 0x00000FFFU
#define MRV_ISP_GAMMA_R_Y_SHIFT 0U

//! Register array: isp_gamma_g_y: De-Gamma Curve definition y green (0x0090 + n*0x4 (n=0..16))
//! Slice: GAMMA_G_Y:
// gamma curve point definition y-axis (output) for green 
// RESTRICTION: each Y must be in the +2047/-2048 range compared to its predecessor (so that the difference between successive Y values is 12-bit signed !)
#define MRV_ISP_GAMMA_G_Y
#define MRV_ISP_GAMMA_G_Y_MASK 0x00000FFFU
#define MRV_ISP_GAMMA_G_Y_SHIFT 0U

//! Register array: isp_gamma_b_y: De-Gamma Curve definition y blue (0x00D8 + n*0x4 (n=0..16))
//! Slice: GAMMA_B_Y:
// gamma curve point definition y-axis (output) for blue 
// RESTRICTION: each Y must be in the +2047/-2048 range compared to its predecessor (so that the difference between successive Y values is 12-bit signed !)
#define MRV_ISP_GAMMA_B_Y
#define MRV_ISP_GAMMA_B_Y_MASK 0x00000FFFU
#define MRV_ISP_GAMMA_B_Y_SHIFT 0U

//! Register: isp_awb_prop: Auto white balance properties (0x00000110)
//! Slice: AWB_MEAS_MODE:
//! 1: RGB based measurement mode 
// 0: near white discrimination mode using YCbCr color space
#define MRV_ISP_AWB_MEAS_MODE
#define MRV_ISP_AWB_MEAS_MODE_MASK 0x80000000U
#define MRV_ISP_AWB_MEAS_MODE_SHIFT 31U
//! Slice: AWB_MAX_EN:
//! 1: enable Y_MAX compare 
// 0: disable Y_MAX compare 
// Not valid in RGB measurement mode.
#define MRV_ISP_AWB_MAX_EN
#define MRV_ISP_AWB_MAX_EN_MASK 0x00000004U
#define MRV_ISP_AWB_MAX_EN_SHIFT 2U
//! Slice: AWB_MODE:
//! AWB_MODE(1:0): 
// 11: reserved 
// 10: measurement of YCbCr means (AWB_MEAS_MODE = 0) or RGB means (AWB_MEAS_MODE = 1) 
// 01: reserved 
// 00: no measurement
#define MRV_ISP_AWB_MODE
#define MRV_ISP_AWB_MODE_MASK 0x00000003U
#define MRV_ISP_AWB_MODE_SHIFT 0U

//! Register: isp_awb_h_offs: Auto white balance horizontal offset of measure window (0x00000114)
//! Slice: AWB_H_OFFS:
//! horizontal window offset in pixel
#define MRV_ISP_AWB_H_OFFS
#define MRV_ISP_AWB_H_OFFS_MASK 0x00001FFFU
#define MRV_ISP_AWB_H_OFFS_SHIFT 0U

//! Register: isp_awb_v_offs: Auto white balance vertical offset of measure window (0x00000118)
//! Slice: AWB_V_OFFS:
//! vertical window offset in lines
#define MRV_ISP_AWB_V_OFFS
#define MRV_ISP_AWB_V_OFFS_MASK 0x00001FFFU
#define MRV_ISP_AWB_V_OFFS_SHIFT 0U

//! Register: isp_awb_h_size: Auto white balance horizontal window size (0x0000011c)
//! Slice: AWB_H_SIZE:
//! horizontal measurement window size in pixel
#define MRV_ISP_AWB_H_SIZE
#define MRV_ISP_AWB_H_SIZE_MASK 0x00003FFFU
#define MRV_ISP_AWB_H_SIZE_SHIFT 0U

//! Register: isp_awb_v_size: Auto white balance vertical window size (0x00000120)
//! Slice: AWB_V_SIZE:
//! vertical measurement window size in lines
#define MRV_ISP_AWB_V_SIZE
#define MRV_ISP_AWB_V_SIZE_MASK 0x00003FFFU
#define MRV_ISP_AWB_V_SIZE_SHIFT 0U

//! Register: isp_awb_frames: Auto white balance mean value over multiple frames (0x00000124)
//! Slice: AWB_FRAMES:
//! number of frames-1 used for mean value calculation (value of 0 means 1 frame, value of 7 means 8 frames)
#define MRV_ISP_AWB_FRAMES
#define MRV_ISP_AWB_FRAMES_MASK 0x00000007U
#define MRV_ISP_AWB_FRAMES_SHIFT 0U

//! Register: isp_awb_ref: Auto white balance reference Cb/Cr values (0x00000128)
//! Slice: AWB_REF_CR__MAX_R:
//! - reference Cr value for AWB regulation, target for AWB 
// - maximum red value, if RGB measurement mode is selected
#define MRV_ISP_AWB_REF_CR__MAX_R
#define MRV_ISP_AWB_REF_CR__MAX_R_MASK 0x0000FF00U
#define MRV_ISP_AWB_REF_CR__MAX_R_SHIFT 8U
//! Slice: AWB_REF_CB__MAX_B:
//! - reference Cb value for AWB regulation, target for AWB 
// - maximum blue value, if RGB measurement mode is selected
#define MRV_ISP_AWB_REF_CB__MAX_B
#define MRV_ISP_AWB_REF_CB__MAX_B_MASK 0x000000FFU
#define MRV_ISP_AWB_REF_CB__MAX_B_SHIFT 0U

//! Register: isp_awb_thresh: Auto white balance threshold values (0x0000012c)
//! Slice: AWB_MAX_Y:
//! Luminance maximum value, only consider pixels with luminance smaller than threshold for the WB measurement (must be enabled by register AWB_MODE bit AWB_MAX_EN). Not valid for RGB measurement mode.
#define MRV_ISP_AWB_MAX_Y
#define MRV_ISP_AWB_MAX_Y_MASK 0xFF000000U
#define MRV_ISP_AWB_MAX_Y_SHIFT 24U
//! Slice: AWB_MIN_Y__MAX_G:
//! - Luminance minimum value, only consider pixels with luminance greater than threshold for the WB measurement 
// - maximum green value, if RGB measurement mode is selected
#define MRV_ISP_AWB_MIN_Y__MAX_G
#define MRV_ISP_AWB_MIN_Y__MAX_G_MASK 0x00FF0000U
#define MRV_ISP_AWB_MIN_Y__MAX_G_SHIFT 16U
//! Slice: AWB_MAX_CSUM:
//! Chrominance sum maximum value, only consider pixels with Cb+Cr smaller than threshold for WB measurements
#define MRV_ISP_AWB_MAX_CSUM
#define MRV_ISP_AWB_MAX_CSUM_MASK 0x0000FF00U
#define MRV_ISP_AWB_MAX_CSUM_SHIFT 8U
//! Slice: AWB_MIN_C:
//! Chrominance minimum value, only consider pixels with Cb/Cr each greater than threshold value for WB measurements
#define MRV_ISP_AWB_MIN_C
#define MRV_ISP_AWB_MIN_C_MASK 0x000000FFU
#define MRV_ISP_AWB_MIN_C_SHIFT 0U

//! Register: isp_awb_gain_g: Auto white balance gain green (0x00000138)
//! Slice: AWB_GAIN_GR:
//! gain value for green component in red line 100h = 1, unsigned integer value, range 0 to 4 with 8 bit fractional part
#define MRV_ISP_AWB_GAIN_GR
#define MRV_ISP_AWB_GAIN_GR_MASK 0x03FF0000U
#define MRV_ISP_AWB_GAIN_GR_SHIFT 16U
//! Slice: AWB_GAIN_GB:
//! gain value for green component in blue line 100h = 1, unsigned integer value, range 0 to 4 with 8 bit fractional part
#define MRV_ISP_AWB_GAIN_GB
#define MRV_ISP_AWB_GAIN_GB_MASK 0x000003FFU
#define MRV_ISP_AWB_GAIN_GB_SHIFT 0U

//! Register: isp_awb_gain_rb: Auto white balance gain red and blue (0x0000013c)
//! Slice: AWB_GAIN_R:
//! gain value for red component 100h = 1, unsigned integer value, range 0 to 4 with 8 bit fractional part
#define MRV_ISP_AWB_GAIN_R
#define MRV_ISP_AWB_GAIN_R_MASK 0x03FF0000U
#define MRV_ISP_AWB_GAIN_R_SHIFT 16U
//! Slice: AWB_GAIN_B:
//! gain value for blue component 100h = 1, unsigned integer value, range 0 to 4 with 8 bit fractional part
#define MRV_ISP_AWB_GAIN_B
#define MRV_ISP_AWB_GAIN_B_MASK 0x000003FFU
#define MRV_ISP_AWB_GAIN_B_SHIFT 0U

//! Register: isp_awb_white_cnt: Auto white balance white pixel count (0x00000140)
//! Slice: AWB_WHITE_CNT:
//! White pixel count, number of "white pixels" found during last measurement, i.e. pixels included in mean value calculation
#define MRV_ISP_AWB_WHITE_CNT
#define MRV_ISP_AWB_WHITE_CNT_MASK 0x03FFFFFFU
#define MRV_ISP_AWB_WHITE_CNT_SHIFT 0U

//! Register: isp_awb_mean: Auto white balance measured mean value (0x00000144)
//! Slice: AWB_MEAN_Y__G:
//! - mean value of Y within window and frames 
// - mean value of green, if RGB measurement mode is selected
#define MRV_ISP_AWB_MEAN_Y__G
#define MRV_ISP_AWB_MEAN_Y__G_MASK 0x00FF0000U
#define MRV_ISP_AWB_MEAN_Y__G_SHIFT 16U
//! Slice: AWB_MEAN_CB__B:
//! - mean value of Cb within window and frames 
// - mean value of blue, if RGB measurement mode is selected
#define MRV_ISP_AWB_MEAN_CB__B
#define MRV_ISP_AWB_MEAN_CB__B_MASK 0x0000FF00U
#define MRV_ISP_AWB_MEAN_CB__B_SHIFT 8U
//! Slice: AWB_MEAN_CR__R:
//! - mean value of Cr within window and frames 
// - mean value of red, if RGB measurement mode is selected
#define MRV_ISP_AWB_MEAN_CR__R
#define MRV_ISP_AWB_MEAN_CR__R_MASK 0x000000FFU
#define MRV_ISP_AWB_MEAN_CR__R_SHIFT 0U

//! Register: isp_cc_coeff_0: Color conversion coefficient 0 (0x00000170)
//! Slice: cc_coeff_0:
//! coefficient 0 for color space conversion
#define MRV_ISP_CC_COEFF_0
#define MRV_ISP_CC_COEFF_0_MASK 0x000001FFU
#define MRV_ISP_CC_COEFF_0_SHIFT 0U

//! Register: isp_cc_coeff_1: Color conversion coefficient 1 (0x00000174)
//! Slice: cc_coeff_1:
//! coefficient 1 for color space conversion
#define MRV_ISP_CC_COEFF_1
#define MRV_ISP_CC_COEFF_1_MASK 0x000001FFU
#define MRV_ISP_CC_COEFF_1_SHIFT 0U

//! Register: isp_cc_coeff_2: Color conversion coefficient 2 (0x00000178)
//! Slice: cc_coeff_2:
//! coefficient 2 for color space conversion
#define MRV_ISP_CC_COEFF_2
#define MRV_ISP_CC_COEFF_2_MASK 0x000001FFU
#define MRV_ISP_CC_COEFF_2_SHIFT 0U

//! Register: isp_cc_coeff_3: Color conversion coefficient 3 (0x0000017c)
//! Slice: cc_coeff_3:
//! coefficient 3 for color space conversion
#define MRV_ISP_CC_COEFF_3
#define MRV_ISP_CC_COEFF_3_MASK 0x000001FFU
#define MRV_ISP_CC_COEFF_3_SHIFT 0U

//! Register: isp_cc_coeff_4: Color conversion coefficient 4 (0x00000180)
//! Slice: cc_coeff_4:
//! coefficient 4 for color space conversion
#define MRV_ISP_CC_COEFF_4
#define MRV_ISP_CC_COEFF_4_MASK 0x000001FFU
#define MRV_ISP_CC_COEFF_4_SHIFT 0U

//! Register: isp_cc_coeff_5: Color conversion coefficient 5 (0x00000184)
//! Slice: cc_coeff_5:
//! coefficient 5 for color space conversion
#define MRV_ISP_CC_COEFF_5
#define MRV_ISP_CC_COEFF_5_MASK 0x000001FFU
#define MRV_ISP_CC_COEFF_5_SHIFT 0U

//! Register: isp_cc_coeff_6: Color conversion coefficient 6 (0x00000188)
//! Slice: cc_coeff_6:
//! coefficient 6 for color space conversion
#define MRV_ISP_CC_COEFF_6
#define MRV_ISP_CC_COEFF_6_MASK 0x000001FFU
#define MRV_ISP_CC_COEFF_6_SHIFT 0U

//! Register: isp_cc_coeff_7: Color conversion coefficient 7 (0x0000018c)
//! Slice: cc_coeff_7:
//! coefficient 7 for color space conversion
#define MRV_ISP_CC_COEFF_7
#define MRV_ISP_CC_COEFF_7_MASK 0x000001FFU
#define MRV_ISP_CC_COEFF_7_SHIFT 0U

//! Register: isp_cc_coeff_8: Color conversion coefficient 8 (0x00000190)
//! Slice: cc_coeff_8:
//! coefficient 8 for color space conversion
#define MRV_ISP_CC_COEFF_8
#define MRV_ISP_CC_COEFF_8_MASK 0x000001FFU
#define MRV_ISP_CC_COEFF_8_SHIFT 0U

//! Register: isp_out_h_offs: Horizontal offset of output window (0x00000194)
//! Slice: ISP_OUT_H_OFFS:
//! vertical pic offset in lines
#define MRV_ISP_ISP_OUT_H_OFFS
#define MRV_ISP_ISP_OUT_H_OFFS_MASK 0x00003FFFU
#define MRV_ISP_ISP_OUT_H_OFFS_SHIFT 0U

//! Register: isp_out_v_offs: Vertical offset of output window (0x00000198)
//! Slice: ISP_OUT_V_OFFS:
//! vertical pic offset in lines
#define MRV_ISP_ISP_OUT_V_OFFS
#define MRV_ISP_ISP_OUT_V_OFFS_MASK 0x00003FFFU
#define MRV_ISP_ISP_OUT_V_OFFS_SHIFT 0U

//! Register: isp_out_h_size: Output horizontal picture size (0x0000019c)
//! Slice: ISP_OUT_H_SIZE:
//! horizontal picture size in pixel  
// if ISP_MODE is set to 
// 001-(ITU-R BT.656 YUV), 
// 010-( ITU-R BT.601 YUV), 
// 011-( ITU-R BT.601 Bayer RGB), 
// 101-( ITU-R BT.656 Bayer RGB) 
// only even numbers are accepted, because complete quadruples of YUYV(YCbYCr) are needed for the 422 output. (if an odd size is programmed the value will be truncated to even size)
#define MRV_ISP_ISP_OUT_H_SIZE
#define MRV_ISP_ISP_OUT_H_SIZE_MASK 0x00007FFFU
#define MRV_ISP_ISP_OUT_H_SIZE_SHIFT 0U

//! Register: isp_out_v_size: Output vertical picture size (0x000001a0)
//! Slice: ISP_OUT_V_SIZE:
//! vertical pic size in lines
#define MRV_ISP_ISP_OUT_V_SIZE
#define MRV_ISP_ISP_OUT_V_SIZE_MASK 0x00003FFFU
#define MRV_ISP_ISP_OUT_V_SIZE_SHIFT 0U

//! Register: isp_demosaic: Demosaic parameters (0x000001a4)
//! Slice: DEMOSAIC_BYPASS:
//! 0: normal operation for RGB Bayer Pattern input 
// 1: demosaicing bypass for Black&White input data
#define MRV_ISP_DEMOSAIC_BYPASS
#define MRV_ISP_DEMOSAIC_BYPASS_MASK 0x00000400U
#define MRV_ISP_DEMOSAIC_BYPASS_SHIFT 10U
//! Slice: DEMOSAIC_TH:
//! Threshold for Bayer demosaicing texture detection. This value shifted left 4bit is compared with the difference of the vertical and horizontal 12Bit wide texture indicators, to decide if the vertical or horizontal texture flag must be set.  
// 0xFF: no texture detection 
// 0x00: maximum edge sensitivity
#define MRV_ISP_DEMOSAIC_TH
#define MRV_ISP_DEMOSAIC_TH_MASK 0x000000FFU
#define MRV_ISP_DEMOSAIC_TH_SHIFT 0U

//! Register: isp_flags_shd: Flags (current status) of certain signals and Shadow regs for enable signals (0x000001a8)
//! Slice: S_HSYNC:
//! state of ISP input port s_hsync, for test purposes
#define MRV_ISP_S_HSYNC
#define MRV_ISP_S_HSYNC_MASK 0x80000000U
#define MRV_ISP_S_HSYNC_SHIFT 31U
//! Slice: S_VSYNC:
//! state of ISP input port s_vsync, for test purposes
#define MRV_ISP_S_VSYNC
#define MRV_ISP_S_VSYNC_MASK 0x40000000U
#define MRV_ISP_S_VSYNC_SHIFT 30U
//! Slice: S_DATA:
//! state of ISP input port s_data, for test purposes
#define MRV_ISP_S_DATA
#define MRV_ISP_S_DATA_MASK 0x0FFF0000U
#define MRV_ISP_S_DATA_SHIFT 16U
//! Slice: INFORM_FIELD:
//! current field information (0=odd, 1=even)
#define MRV_ISP_INFORM_FIELD
#define MRV_ISP_INFORM_FIELD_MASK 0x00000004U
#define MRV_ISP_INFORM_FIELD_SHIFT 2U
//! Slice: ISP_INFORM_ENABLE_SHD:
//! Input formatter enable shadow register
#define MRV_ISP_ISP_INFORM_ENABLE_SHD
#define MRV_ISP_ISP_INFORM_ENABLE_SHD_MASK 0x00000002U
#define MRV_ISP_ISP_INFORM_ENABLE_SHD_SHIFT 1U
//! Slice: ISP_ENABLE_SHD:
//! ISP enable shadow register 
// shows, if ISP currently outputs data (1) or not (0)
#define MRV_ISP_ISP_ENABLE_SHD
#define MRV_ISP_ISP_ENABLE_SHD_MASK 0x00000001U
#define MRV_ISP_ISP_ENABLE_SHD_SHIFT 0U

//! Register: isp_out_h_offs_shd: current horizontal offset of output window (shadow register) (0x000001ac)
//! Slice: ISP_OUT_H_OFFS_SHD:
//! current vertical pic offset in lines
#define MRV_ISP_ISP_OUT_H_OFFS_SHD
#define MRV_ISP_ISP_OUT_H_OFFS_SHD_MASK 0x00003FFFU
#define MRV_ISP_ISP_OUT_H_OFFS_SHD_SHIFT 0U

//! Register: isp_out_v_offs_shd: current vertical offset of output window (shadow register) (0x000001b0)
//! Slice: ISP_OUT_V_OFFS_SHD:
//! current vertical pic offset in lines
#define MRV_ISP_ISP_OUT_V_OFFS_SHD
#define MRV_ISP_ISP_OUT_V_OFFS_SHD_MASK 0x00003FFFU
#define MRV_ISP_ISP_OUT_V_OFFS_SHD_SHIFT 0U

//! Register: isp_out_h_size_shd: current output horizontal picture size (shadow register) (0x000001b4)
//! Slice: ISP_OUT_H_SIZE_SHD:
//! current horizontal pic size in pixel
#define MRV_ISP_ISP_OUT_H_SIZE_SHD
#define MRV_ISP_ISP_OUT_H_SIZE_SHD_MASK 0x00007FFFU
#define MRV_ISP_ISP_OUT_H_SIZE_SHD_SHIFT 0U

//! Register: isp_out_v_size_shd: current output vertical picture size (shadow register) (0x000001b8)
//! Slice: ISP_OUT_V_SIZE_SHD:
//! vertical pic size in lines
#define MRV_ISP_ISP_OUT_V_SIZE_SHD
#define MRV_ISP_ISP_OUT_V_SIZE_SHD_MASK 0x00003FFFU
#define MRV_ISP_ISP_OUT_V_SIZE_SHD_SHIFT 0U

//! Register: isp_imsc: Interrupt mask (0x000001bc)
//! Slice: IMSC_VSM_END:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_VSM_END
#define MRV_ISP_IMSC_VSM_END_MASK 0x00080000U
#define MRV_ISP_IMSC_VSM_END_SHIFT 19U
//! Slice: IMSC_EXP_END:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_EXP_END
#define MRV_ISP_IMSC_EXP_END_MASK 0x00040000U
#define MRV_ISP_IMSC_EXP_END_SHIFT 18U
//! Slice: IMSC_FLASH_CAP:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_FLASH_CAP
#define MRV_ISP_IMSC_FLASH_CAP_MASK 0x00020000U
#define MRV_ISP_IMSC_FLASH_CAP_SHIFT 17U
//! Slice: IMSC_RESERVED_1:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_RESERVED_1
#define MRV_ISP_IMSC_RESERVED_1_MASK 0x00010000U
#define MRV_ISP_IMSC_RESERVED_1_SHIFT 16U
//! Slice: IMSC_HIST_MEASURE_RDY:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_HIST_MEASURE_RDY
#define MRV_ISP_IMSC_HIST_MEASURE_RDY_MASK 0x00008000U
#define MRV_ISP_IMSC_HIST_MEASURE_RDY_SHIFT 15U
//! Slice: IMSC_AFM_FIN:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_AFM_FIN
#define MRV_ISP_IMSC_AFM_FIN_MASK 0x00004000U
#define MRV_ISP_IMSC_AFM_FIN_SHIFT 14U
//! Slice: IMSC_AFM_LUM_OF:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_AFM_LUM_OF
#define MRV_ISP_IMSC_AFM_LUM_OF_MASK 0x00002000U
#define MRV_ISP_IMSC_AFM_LUM_OF_SHIFT 13U
//! Slice: IMSC_AFM_SUM_OF:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_AFM_SUM_OF
#define MRV_ISP_IMSC_AFM_SUM_OF_MASK 0x00001000U
#define MRV_ISP_IMSC_AFM_SUM_OF_SHIFT 12U
//! Slice: IMSC_SHUTTER_OFF:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_SHUTTER_OFF
#define MRV_ISP_IMSC_SHUTTER_OFF_MASK 0x00000800U
#define MRV_ISP_IMSC_SHUTTER_OFF_SHIFT 11U
//! Slice: IMSC_SHUTTER_ON:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_SHUTTER_ON
#define MRV_ISP_IMSC_SHUTTER_ON_MASK 0x00000400U
#define MRV_ISP_IMSC_SHUTTER_ON_SHIFT 10U
//! Slice: IMSC_FLASH_OFF:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_FLASH_OFF
#define MRV_ISP_IMSC_FLASH_OFF_MASK 0x00000200U
#define MRV_ISP_IMSC_FLASH_OFF_SHIFT 9U
//! Slice: IMSC_FLASH_ON:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_FLASH_ON
#define MRV_ISP_IMSC_FLASH_ON_MASK 0x00000100U
#define MRV_ISP_IMSC_FLASH_ON_SHIFT 8U
//! Slice: IMSC_H_START:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_H_START
#define MRV_ISP_IMSC_H_START_MASK 0x00000080U
#define MRV_ISP_IMSC_H_START_SHIFT 7U
//! Slice: IMSC_V_START:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_V_START
#define MRV_ISP_IMSC_V_START_MASK 0x00000040U
#define MRV_ISP_IMSC_V_START_SHIFT 6U
//! Slice: IMSC_FRAME_IN:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_FRAME_IN
#define MRV_ISP_IMSC_FRAME_IN_MASK 0x00000020U
#define MRV_ISP_IMSC_FRAME_IN_SHIFT 5U
//! Slice: IMSC_AWB_DONE:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_AWB_DONE
#define MRV_ISP_IMSC_AWB_DONE_MASK 0x00000010U
#define MRV_ISP_IMSC_AWB_DONE_SHIFT 4U
//! Slice: IMSC_PIC_SIZE_ERR:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_PIC_SIZE_ERR
#define MRV_ISP_IMSC_PIC_SIZE_ERR_MASK 0x00000008U
#define MRV_ISP_IMSC_PIC_SIZE_ERR_SHIFT 3U
//! Slice: IMSC_DATA_LOSS:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_DATA_LOSS
#define MRV_ISP_IMSC_DATA_LOSS_MASK 0x00000004U
#define MRV_ISP_IMSC_DATA_LOSS_SHIFT 2U
//! Slice: IMSC_FRAME:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_FRAME
#define MRV_ISP_IMSC_FRAME_MASK 0x00000002U
#define MRV_ISP_IMSC_FRAME_SHIFT 1U
//! Slice: IMSC_ISP_OFF:
//! enable interrupt (1) or mask out (0)
#define MRV_ISP_IMSC_ISP_OFF
#define MRV_ISP_IMSC_ISP_OFF_MASK 0x00000001U
#define MRV_ISP_IMSC_ISP_OFF_SHIFT 0U

//! Register: isp_ris: Raw interrupt status (0x000001c0)
//! Slice: RIS_VSM_END:
//! VSM measurement complete
#define MRV_ISP_RIS_VSM_END
#define MRV_ISP_RIS_VSM_END_MASK 0x00080000U
#define MRV_ISP_RIS_VSM_END_SHIFT 19U
//! Slice: RIS_EXP_END:
//! Exposure measurement complete
#define MRV_ISP_RIS_EXP_END
#define MRV_ISP_RIS_EXP_END_MASK 0x00040000U
#define MRV_ISP_RIS_EXP_END_SHIFT 18U
//! Slice: RIS_FLASH_CAP:
//! Signaling captured frame
#define MRV_ISP_RIS_FLASH_CAP
#define MRV_ISP_RIS_FLASH_CAP_MASK 0x00020000U
#define MRV_ISP_RIS_FLASH_CAP_SHIFT 17U
//! Slice: RIS_RESERVED_1:
//! reserved
#define MRV_ISP_RIS_RESERVED_1
#define MRV_ISP_RIS_RESERVED_1_MASK 0x00010000U
#define MRV_ISP_RIS_RESERVED_1_SHIFT 16U
//! Slice: RIS_HIST_MEASURE_RDY:
//! Histogram measurement ready. (old or new histogram measurement)
#define MRV_ISP_RIS_HIST_MEASURE_RDY
#define MRV_ISP_RIS_HIST_MEASURE_RDY_MASK 0x00008000U
#define MRV_ISP_RIS_HIST_MEASURE_RDY_SHIFT 15U
//! Slice: RIS_AFM_FIN:
//! AF measurement finished: this interrupt is set when the first complete frame is calculated after enabling the AF measurement
#define MRV_ISP_RIS_AFM_FIN
#define MRV_ISP_RIS_AFM_FIN_MASK 0x00004000U
#define MRV_ISP_RIS_AFM_FIN_SHIFT 14U
//! Slice: RIS_AFM_LUM_OF:
//! Auto focus luminance overflow
#define MRV_ISP_RIS_AFM_LUM_OF
#define MRV_ISP_RIS_AFM_LUM_OF_MASK 0x00002000U
#define MRV_ISP_RIS_AFM_LUM_OF_SHIFT 13U
//! Slice: RIS_AFM_SUM_OF:
//! Auto focus sum overflow
#define MRV_ISP_RIS_AFM_SUM_OF
#define MRV_ISP_RIS_AFM_SUM_OF_MASK 0x00001000U
#define MRV_ISP_RIS_AFM_SUM_OF_SHIFT 12U
//! Slice: RIS_SHUTTER_OFF:
//! Mechanical shutter is switched off
#define MRV_ISP_RIS_SHUTTER_OFF
#define MRV_ISP_RIS_SHUTTER_OFF_MASK 0x00000800U
#define MRV_ISP_RIS_SHUTTER_OFF_SHIFT 11U
//! Slice: RIS_SHUTTER_ON:
//! Mechanical shutter is switched on
#define MRV_ISP_RIS_SHUTTER_ON
#define MRV_ISP_RIS_SHUTTER_ON_MASK 0x00000400U
#define MRV_ISP_RIS_SHUTTER_ON_SHIFT 10U
//! Slice: RIS_FLASH_OFF:
//! Flash light is switched off
#define MRV_ISP_RIS_FLASH_OFF
#define MRV_ISP_RIS_FLASH_OFF_MASK 0x00000200U
#define MRV_ISP_RIS_FLASH_OFF_SHIFT 9U
//! Slice: RIS_FLASH_ON:
//! Flash light is switched on
#define MRV_ISP_RIS_FLASH_ON
#define MRV_ISP_RIS_FLASH_ON_MASK 0x00000100U
#define MRV_ISP_RIS_FLASH_ON_SHIFT 8U
//! Slice: RIS_H_START:
//! Start edge of h_sync
#define MRV_ISP_RIS_H_START
#define MRV_ISP_RIS_H_START_MASK 0x00000080U
#define MRV_ISP_RIS_H_START_SHIFT 7U
//! Slice: RIS_V_START:
//! Start edge of v_sync
#define MRV_ISP_RIS_V_START
#define MRV_ISP_RIS_V_START_MASK 0x00000040U
#define MRV_ISP_RIS_V_START_SHIFT 6U
//! Slice: RIS_FRAME_IN:
//! sampled input frame is complete
#define MRV_ISP_RIS_FRAME_IN
#define MRV_ISP_RIS_FRAME_IN_MASK 0x00000020U
#define MRV_ISP_RIS_FRAME_IN_SHIFT 5U
//! Slice: RIS_AWB_DONE:
//! White balancing measurement cycle is complete, results can be read out
#define MRV_ISP_RIS_AWB_DONE
#define MRV_ISP_RIS_AWB_DONE_MASK 0x00000010U
#define MRV_ISP_RIS_AWB_DONE_SHIFT 4U
//! Slice: RIS_PIC_SIZE_ERR:
//! pic size violation occurred, programming seems wrong
#define MRV_ISP_RIS_PIC_SIZE_ERR
#define MRV_ISP_RIS_PIC_SIZE_ERR_MASK 0x00000008U
#define MRV_ISP_RIS_PIC_SIZE_ERR_SHIFT 3U
//! Slice: RIS_DATA_LOSS:
//! loss of data occurred within a line, processing failure
#define MRV_ISP_RIS_DATA_LOSS
#define MRV_ISP_RIS_DATA_LOSS_MASK 0x00000004U
#define MRV_ISP_RIS_DATA_LOSS_SHIFT 2U
//! Slice: RIS_FRAME:
//! frame was completely put out
#define MRV_ISP_RIS_FRAME
#define MRV_ISP_RIS_FRAME_MASK 0x00000002U
#define MRV_ISP_RIS_FRAME_SHIFT 1U
//! Slice: RIS_ISP_OFF:
//! isp output was disabled (vsynced) due to f_cnt reached or manual
#define MRV_ISP_RIS_ISP_OFF
#define MRV_ISP_RIS_ISP_OFF_MASK 0x00000001U
#define MRV_ISP_RIS_ISP_OFF_SHIFT 0U

//! Register: isp_mis: Masked interrupt status (0x000001c4)
//! Slice: MIS_VSM_END:
//! VSM measurement complete
#define MRV_ISP_MIS_VSM_END
#define MRV_ISP_MIS_VSM_END_MASK 0x00080000U
#define MRV_ISP_MIS_VSM_END_SHIFT 19U
//! Slice: MIS_EXP_END:
//! Exposure measurement complete
#define MRV_ISP_MIS_EXP_END
#define MRV_ISP_MIS_EXP_END_MASK 0x00040000U
#define MRV_ISP_MIS_EXP_END_SHIFT 18U
//! Slice: MIS_FLASH_CAP:
//! Captured is frame is detected
#define MRV_ISP_MIS_FLASH_CAP
#define MRV_ISP_MIS_FLASH_CAP_MASK 0x00020000U
#define MRV_ISP_MIS_FLASH_CAP_SHIFT 17U
//! Slice: MIS_RESERVED_1:
//! reserved
#define MRV_ISP_MIS_RESERVED_1
#define MRV_ISP_MIS_RESERVED_1_MASK 0x00010000U
#define MRV_ISP_MIS_RESERVED_1_SHIFT 16U
//! Slice: MIS_HIST_MEASURE_RDY:
//! Histogram measurement ready. (old or new histogram measurement)
#define MRV_ISP_MIS_HIST_MEASURE_RDY
#define MRV_ISP_MIS_HIST_MEASURE_RDY_MASK 0x00008000U
#define MRV_ISP_MIS_HIST_MEASURE_RDY_SHIFT 15U
//! Slice: MIS_AFM_FIN:
//! AF measurement finished: this interrupt is set when the first complete frame is calculated after enabling the AF measurement
#define MRV_ISP_MIS_AFM_FIN
#define MRV_ISP_MIS_AFM_FIN_MASK 0x00004000U
#define MRV_ISP_MIS_AFM_FIN_SHIFT 14U
//! Slice: MIS_AFM_LUM_OF:
//! Luminance overflow
#define MRV_ISP_MIS_AFM_LUM_OF
#define MRV_ISP_MIS_AFM_LUM_OF_MASK 0x00002000U
#define MRV_ISP_MIS_AFM_LUM_OF_SHIFT 13U
//! Slice: MIS_AFM_SUM_OF:
//! Sum overflow
#define MRV_ISP_MIS_AFM_SUM_OF
#define MRV_ISP_MIS_AFM_SUM_OF_MASK 0x00001000U
#define MRV_ISP_MIS_AFM_SUM_OF_SHIFT 12U
//! Slice: MIS_SHUTTER_OFF:
//! Mechanical shutter is switched off
#define MRV_ISP_MIS_SHUTTER_OFF
#define MRV_ISP_MIS_SHUTTER_OFF_MASK 0x00000800U
#define MRV_ISP_MIS_SHUTTER_OFF_SHIFT 11U
//! Slice: MIS_SHUTTER_ON:
//! Mechanical shutter is switched on
#define MRV_ISP_MIS_SHUTTER_ON
#define MRV_ISP_MIS_SHUTTER_ON_MASK 0x00000400U
#define MRV_ISP_MIS_SHUTTER_ON_SHIFT 10U
//! Slice: MIS_FLASH_OFF:
//! Flash light is switched off
#define MRV_ISP_MIS_FLASH_OFF
#define MRV_ISP_MIS_FLASH_OFF_MASK 0x00000200U
#define MRV_ISP_MIS_FLASH_OFF_SHIFT 9U
//! Slice: MIS_FLASH_ON:
//! Flash light is switched on
#define MRV_ISP_MIS_FLASH_ON
#define MRV_ISP_MIS_FLASH_ON_MASK 0x00000100U
#define MRV_ISP_MIS_FLASH_ON_SHIFT 8U
//! Slice: MIS_H_START:
//! Start edge of h_sync
#define MRV_ISP_MIS_H_START
#define MRV_ISP_MIS_H_START_MASK 0x00000080U
#define MRV_ISP_MIS_H_START_SHIFT 7U
//! Slice: MIS_V_START:
//! Start edge of v_sync
#define MRV_ISP_MIS_V_START
#define MRV_ISP_MIS_V_START_MASK 0x00000040U
#define MRV_ISP_MIS_V_START_SHIFT 6U
//! Slice: MIS_FRAME_IN:
//! sampled input frame is complete
#define MRV_ISP_MIS_FRAME_IN
#define MRV_ISP_MIS_FRAME_IN_MASK 0x00000020U
#define MRV_ISP_MIS_FRAME_IN_SHIFT 5U
//! Slice: MIS_AWB_DONE:
//! White balancing measurement cycle is complete, results can be read out
#define MRV_ISP_MIS_AWB_DONE
#define MRV_ISP_MIS_AWB_DONE_MASK 0x00000010U
#define MRV_ISP_MIS_AWB_DONE_SHIFT 4U
//! Slice: MIS_PIC_SIZE_ERR:
//! pic size violation occurred, programming seems wrong
#define MRV_ISP_MIS_PIC_SIZE_ERR
#define MRV_ISP_MIS_PIC_SIZE_ERR_MASK 0x00000008U
#define MRV_ISP_MIS_PIC_SIZE_ERR_SHIFT 3U
//! Slice: MIS_DATA_LOSS:
//! loss of data occurred within a line, processing failure
#define MRV_ISP_MIS_DATA_LOSS
#define MRV_ISP_MIS_DATA_LOSS_MASK 0x00000004U
#define MRV_ISP_MIS_DATA_LOSS_SHIFT 2U
//! Slice: MIS_FRAME:
//! frame was completely put out
#define MRV_ISP_MIS_FRAME
#define MRV_ISP_MIS_FRAME_MASK 0x00000002U
#define MRV_ISP_MIS_FRAME_SHIFT 1U
//! Slice: MIS_ISP_OFF:
//! isp was turned off (vsynced) due to f_cnt reached or manual
#define MRV_ISP_MIS_ISP_OFF
#define MRV_ISP_MIS_ISP_OFF_MASK 0x00000001U
#define MRV_ISP_MIS_ISP_OFF_SHIFT 0U

//! Register: isp_icr: Interrupt clear register (0x000001c8)
//! Slice: ICR_VSM_END:
//! clear interrupt
#define MRV_ISP_ICR_VSM_END
#define MRV_ISP_ICR_VSM_END_MASK 0x00080000U
#define MRV_ISP_ICR_VSM_END_SHIFT 19U
//! Slice: ICR_EXP_END:
//! clear interrupt
#define MRV_ISP_ICR_EXP_END
#define MRV_ISP_ICR_EXP_END_MASK 0x00040000U
#define MRV_ISP_ICR_EXP_END_SHIFT 18U
//! Slice: ICR_FLASH_CAP:
//! clear interrupt
#define MRV_ISP_ICR_FLASH_CAP
#define MRV_ISP_ICR_FLASH_CAP_MASK 0x00020000U
#define MRV_ISP_ICR_FLASH_CAP_SHIFT 17U
//! Slice: ICR_RESERVED_1:
//! clear interrupt
#define MRV_ISP_ICR_RESERVED_1
#define MRV_ISP_ICR_RESERVED_1_MASK 0x00010000U
#define MRV_ISP_ICR_RESERVED_1_SHIFT 16U
//! Slice: ICR_HIST_MEASURE_RDY:
//! clear interrupt
#define MRV_ISP_ICR_HIST_MEASURE_RDY
#define MRV_ISP_ICR_HIST_MEASURE_RDY_MASK 0x00008000U
#define MRV_ISP_ICR_HIST_MEASURE_RDY_SHIFT 15U
//! Slice: ICR_AFM_FIN:
//! clear interrupt
#define MRV_ISP_ICR_AFM_FIN
#define MRV_ISP_ICR_AFM_FIN_MASK 0x00004000U
#define MRV_ISP_ICR_AFM_FIN_SHIFT 14U
//! Slice: ICR_AFM_LUM_OF:
//! clear interrupt
#define MRV_ISP_ICR_AFM_LUM_OF
#define MRV_ISP_ICR_AFM_LUM_OF_MASK 0x00002000U
#define MRV_ISP_ICR_AFM_LUM_OF_SHIFT 13U
//! Slice: ICR_AFM_SUM_OF:
//! clear interrupt
#define MRV_ISP_ICR_AFM_SUM_OF
#define MRV_ISP_ICR_AFM_SUM_OF_MASK 0x00001000U
#define MRV_ISP_ICR_AFM_SUM_OF_SHIFT 12U
//! Slice: ICR_SHUTTER_OFF:
//! clear interrupt
#define MRV_ISP_ICR_SHUTTER_OFF
#define MRV_ISP_ICR_SHUTTER_OFF_MASK 0x00000800U
#define MRV_ISP_ICR_SHUTTER_OFF_SHIFT 11U
//! Slice: ICR_SHUTTER_ON:
//! clear interrupt
#define MRV_ISP_ICR_SHUTTER_ON
#define MRV_ISP_ICR_SHUTTER_ON_MASK 0x00000400U
#define MRV_ISP_ICR_SHUTTER_ON_SHIFT 10U
//! Slice: ICR_FLASH_OFF:
//! clear interrupt
#define MRV_ISP_ICR_FLASH_OFF
#define MRV_ISP_ICR_FLASH_OFF_MASK 0x00000200U
#define MRV_ISP_ICR_FLASH_OFF_SHIFT 9U
//! Slice: ICR_FLASH_ON:
//! clear interrupt
#define MRV_ISP_ICR_FLASH_ON
#define MRV_ISP_ICR_FLASH_ON_MASK 0x00000100U
#define MRV_ISP_ICR_FLASH_ON_SHIFT 8U
//! Slice: ICR_H_START:
//! clear interrupt
#define MRV_ISP_ICR_H_START
#define MRV_ISP_ICR_H_START_MASK 0x00000080U
#define MRV_ISP_ICR_H_START_SHIFT 7U
//! Slice: ICR_V_START:
//! clear interrupt
#define MRV_ISP_ICR_V_START
#define MRV_ISP_ICR_V_START_MASK 0x00000040U
#define MRV_ISP_ICR_V_START_SHIFT 6U
//! Slice: ICR_FRAME_IN:
//! clear interrupt
#define MRV_ISP_ICR_FRAME_IN
#define MRV_ISP_ICR_FRAME_IN_MASK 0x00000020U
#define MRV_ISP_ICR_FRAME_IN_SHIFT 5U
//! Slice: ICR_AWB_DONE:
//! clear interrupt
#define MRV_ISP_ICR_AWB_DONE
#define MRV_ISP_ICR_AWB_DONE_MASK 0x00000010U
#define MRV_ISP_ICR_AWB_DONE_SHIFT 4U
//! Slice: ICR_PIC_SIZE_ERR:
//! clear interrupt
#define MRV_ISP_ICR_PIC_SIZE_ERR
#define MRV_ISP_ICR_PIC_SIZE_ERR_MASK 0x00000008U
#define MRV_ISP_ICR_PIC_SIZE_ERR_SHIFT 3U
//! Slice: ICR_DATA_LOSS:
//! clear interrupt
#define MRV_ISP_ICR_DATA_LOSS
#define MRV_ISP_ICR_DATA_LOSS_MASK 0x00000004U
#define MRV_ISP_ICR_DATA_LOSS_SHIFT 2U
//! Slice: ICR_FRAME:
//! clear interrupt
#define MRV_ISP_ICR_FRAME
#define MRV_ISP_ICR_FRAME_MASK 0x00000002U
#define MRV_ISP_ICR_FRAME_SHIFT 1U
//! Slice: ICR_ISP_OFF:
//! clear interrupt
#define MRV_ISP_ICR_ISP_OFF
#define MRV_ISP_ICR_ISP_OFF_MASK 0x00000001U
#define MRV_ISP_ICR_ISP_OFF_SHIFT 0U

//! Register: isp_isr: Interrupt set register (0x000001cc)
//! Slice: ISR_VSM_END:
//! set interrupt
#define MRV_ISP_ISR_VSM_END
#define MRV_ISP_ISR_VSM_END_MASK 0x00080000U
#define MRV_ISP_ISR_VSM_END_SHIFT 19U
//! Slice: ISR_EXP_END:
//! set interrupt
#define MRV_ISP_ISR_EXP_END
#define MRV_ISP_ISR_EXP_END_MASK 0x00040000U
#define MRV_ISP_ISR_EXP_END_SHIFT 18U
//! Slice: ISR_FLASH_CAP:
//! set interrupt
#define MRV_ISP_ISR_FLASH_CAP
#define MRV_ISP_ISR_FLASH_CAP_MASK 0x00020000U
#define MRV_ISP_ISR_FLASH_CAP_SHIFT 17U
//! Slice: ISR_RESERVED_1:
//! set interrupt
#define MRV_ISP_ISR_RESERVED_1
#define MRV_ISP_ISR_RESERVED_1_MASK 0x00010000U
#define MRV_ISP_ISR_RESERVED_1_SHIFT 16U
//! Slice: ISR_HIST_MEASURE_RDY:
//! set interrupt
#define MRV_ISP_ISR_HIST_MEASURE_RDY
#define MRV_ISP_ISR_HIST_MEASURE_RDY_MASK 0x00008000U
#define MRV_ISP_ISR_HIST_MEASURE_RDY_SHIFT 15U
//! Slice: ISR_AFM_FIN:
//! set interrupt
#define MRV_ISP_ISR_AFM_FIN
#define MRV_ISP_ISR_AFM_FIN_MASK 0x00004000U
#define MRV_ISP_ISR_AFM_FIN_SHIFT 14U
//! Slice: ISR_AFM_LUM_OF:
//! set interrupt
#define MRV_ISP_ISR_AFM_LUM_OF
#define MRV_ISP_ISR_AFM_LUM_OF_MASK 0x00002000U
#define MRV_ISP_ISR_AFM_LUM_OF_SHIFT 13U
//! Slice: ISR_AFM_SUM_OF:
//! set interrupt
#define MRV_ISP_ISR_AFM_SUM_OF
#define MRV_ISP_ISR_AFM_SUM_OF_MASK 0x00001000U
#define MRV_ISP_ISR_AFM_SUM_OF_SHIFT 12U
//! Slice: ISR_SHUTTER_OFF:
//! set interrupt
#define MRV_ISP_ISR_SHUTTER_OFF
#define MRV_ISP_ISR_SHUTTER_OFF_MASK 0x00000800U
#define MRV_ISP_ISR_SHUTTER_OFF_SHIFT 11U
//! Slice: ISR_SHUTTER_ON:
//! set interrupt
#define MRV_ISP_ISR_SHUTTER_ON
#define MRV_ISP_ISR_SHUTTER_ON_MASK 0x00000400U
#define MRV_ISP_ISR_SHUTTER_ON_SHIFT 10U
//! Slice: ISR_FLASH_OFF:
//! set interrupt
#define MRV_ISP_ISR_FLASH_OFF
#define MRV_ISP_ISR_FLASH_OFF_MASK 0x00000200U
#define MRV_ISP_ISR_FLASH_OFF_SHIFT 9U
//! Slice: ISR_FLASH_ON:
//! set interrupt
#define MRV_ISP_ISR_FLASH_ON
#define MRV_ISP_ISR_FLASH_ON_MASK 0x00000100U
#define MRV_ISP_ISR_FLASH_ON_SHIFT 8U
//! Slice: ISR_H_START:
//! set interrupt
#define MRV_ISP_ISR_H_START
#define MRV_ISP_ISR_H_START_MASK 0x00000080U
#define MRV_ISP_ISR_H_START_SHIFT 7U
//! Slice: ISR_V_START:
//! set interrupt
#define MRV_ISP_ISR_V_START
#define MRV_ISP_ISR_V_START_MASK 0x00000040U
#define MRV_ISP_ISR_V_START_SHIFT 6U
//! Slice: ISR_FRAME_IN:
//! set interrupt
#define MRV_ISP_ISR_FRAME_IN
#define MRV_ISP_ISR_FRAME_IN_MASK 0x00000020U
#define MRV_ISP_ISR_FRAME_IN_SHIFT 5U
//! Slice: ISR_AWB_DONE:
//! set interrupt
#define MRV_ISP_ISR_AWB_DONE
#define MRV_ISP_ISR_AWB_DONE_MASK 0x00000010U
#define MRV_ISP_ISR_AWB_DONE_SHIFT 4U
//! Slice: ISR_PIC_SIZE_ERR:
//! set interrupt
#define MRV_ISP_ISR_PIC_SIZE_ERR
#define MRV_ISP_ISR_PIC_SIZE_ERR_MASK 0x00000008U
#define MRV_ISP_ISR_PIC_SIZE_ERR_SHIFT 3U
//! Slice: ISR_DATA_LOSS:
//! set interrupt
#define MRV_ISP_ISR_DATA_LOSS
#define MRV_ISP_ISR_DATA_LOSS_MASK 0x00000004U
#define MRV_ISP_ISR_DATA_LOSS_SHIFT 2U
//! Slice: ISR_FRAME:
//! set interrupt
#define MRV_ISP_ISR_FRAME
#define MRV_ISP_ISR_FRAME_MASK 0x00000002U
#define MRV_ISP_ISR_FRAME_SHIFT 1U
//! Slice: ISR_ISP_OFF:
//! set interrupt
#define MRV_ISP_ISR_ISP_OFF
#define MRV_ISP_ISR_ISP_OFF_MASK 0x00000001U
#define MRV_ISP_ISR_ISP_OFF_SHIFT 0U

//! Register array: isp_ct_coeff: cross-talk configuration register (color correction matrix) (0x03A0 + n*0x4 (n=0..8))
//! Slice: ct_coeff:
// Coefficient n for cross talk matrix.  
// 
// Values are 11-bit signed fixed-point numbers with 4 bit integer and 7 bit fractional part, 
// ranging from -8 (0x400) to +7.992 (0x3FF). 0 is reprsented by 0x000 and a coefficient value of 1 as 0x080.
#define MRV_ISP_CT_COEFF
#define MRV_ISP_CT_COEFF_MASK 0x000007FFU
#define MRV_ISP_CT_COEFF_SHIFT 0U

//! Register: isp_gamma_out_mode: gamma segmentation mode register for output gamma (0x000001f4)
//! Slice: equ_segm:
//! 0: logarithmic like segmentation of gamma curve (default after reset) 
//   segmentation from 0 to 4095: 64 64 64 64 128 128 128 128 256 256 256 512 512 512 512 512  
// 1: equidistant segmentation (all 16 segments are 256 )
#define MRV_ISP_EQU_SEGM
#define MRV_ISP_EQU_SEGM_MASK 0x00000001U
#define MRV_ISP_EQU_SEGM_SHIFT 0U

//! Register array: isp_gamma_out_y: Gamma Out Curve definition y_ (0x03F0 + n*0x4 (n=0..16))
//! Slice: isp_gamma_out_y:
// Gamma_out curve point definition y-axis (output) for all color components (red,green,blue) 
// RESTRICTION: The difference between two Y_n (dy = Y_n - Y_n-1) is restricted to +511/-512 (10 bit signed)!
#define MRV_ISP_ISP_GAMMA_OUT_Y
#define MRV_ISP_ISP_GAMMA_OUT_Y_MASK 0x000003FFU
#define MRV_ISP_ISP_GAMMA_OUT_Y_SHIFT 0U

//! Register: isp_err: ISP error register (0x0000023c)
//! Slice: outform_size_err:
//! size error is generated in outmux submodule
#define MRV_ISP_OUTFORM_SIZE_ERR
#define MRV_ISP_OUTFORM_SIZE_ERR_MASK 0x00000004U
#define MRV_ISP_OUTFORM_SIZE_ERR_SHIFT 2U
//! Slice: is_size_err:
//! size error is generated in image stabilization submodule
#define MRV_ISP_IS_SIZE_ERR
#define MRV_ISP_IS_SIZE_ERR_MASK 0x00000002U
#define MRV_ISP_IS_SIZE_ERR_SHIFT 1U
//! Slice: inform_size_err:
//! size error is generated in inform submodule
#define MRV_ISP_INFORM_SIZE_ERR
#define MRV_ISP_INFORM_SIZE_ERR_MASK 0x00000001U
#define MRV_ISP_INFORM_SIZE_ERR_SHIFT 0U

//! Register: isp_err_clr: ISP error clear register (0x00000240)
//! Slice: outform_size_err_clr:
//! size error is cleared
#define MRV_ISP_OUTFORM_SIZE_ERR_CLR
#define MRV_ISP_OUTFORM_SIZE_ERR_CLR_MASK 0x00000004U
#define MRV_ISP_OUTFORM_SIZE_ERR_CLR_SHIFT 2U
//! Slice: is_size_err_clr:
//! size error is cleared
#define MRV_ISP_IS_SIZE_ERR_CLR
#define MRV_ISP_IS_SIZE_ERR_CLR_MASK 0x00000002U
#define MRV_ISP_IS_SIZE_ERR_CLR_SHIFT 1U
//! Slice: inform_size_err_clr:
//! size error is cleared
#define MRV_ISP_INFORM_SIZE_ERR_CLR
#define MRV_ISP_INFORM_SIZE_ERR_CLR_MASK 0x00000001U
#define MRV_ISP_INFORM_SIZE_ERR_CLR_SHIFT 0U

//! Register: isp_frame_count: Frame counter (0x00000244)
//! Slice: frame_counter:
//! Current frame count of processing
#define MRV_ISP_FRAME_COUNTER
#define MRV_ISP_FRAME_COUNTER_MASK 0x000003FFU
#define MRV_ISP_FRAME_COUNTER_SHIFT 0U

//! Register: isp_ct_offset_r: cross-talk offset red (0x00000248)
//! Slice: ct_offset_r:
//! Offset red for cross talk matrix. Two's complement integer number ranging from -2048 (0x800) to 2047 (0x7FF). 0 is represented as 0x000.
#define MRV_ISP_CT_OFFSET_R
#define MRV_ISP_CT_OFFSET_R_MASK 0x00000FFFU
#define MRV_ISP_CT_OFFSET_R_SHIFT 0U

//! Register: isp_ct_offset_g: cross-talk offset green (0x0000024c)
//! Slice: ct_offset_g:
//! Offset green for cross talk matrix. Two's complement integer number ranging from -2048 (0x800) to 2047 (0x7FF). 0 is represented as 0x000.
#define MRV_ISP_CT_OFFSET_G
#define MRV_ISP_CT_OFFSET_G_MASK 0x00000FFFU
#define MRV_ISP_CT_OFFSET_G_SHIFT 0U

//! Register: isp_ct_offset_b: cross-talk offset blue (0x00000250)
//! Slice: ct_offset_b:
//! Offset blue for cross talk matrix. Two's complement integer number ranging from -2048 (0x800) to 2047 (0x7FF). 0 is represented as 0x000.
#define MRV_ISP_CT_OFFSET_B
#define MRV_ISP_CT_OFFSET_B_MASK 0x00000FFFU
#define MRV_ISP_CT_OFFSET_B_SHIFT 0U

//! Register: isp_flash_cmd: Flash command (0x00000000)
//! Slice: preflash_on:
//! preflash on 
// 0: no effect 
// 1: flash delay counter is started at next trigger event 
// No capture event is signaled to the sensor interface block.
#define MRV_FLASH_PREFLASH_ON
#define MRV_FLASH_PREFLASH_ON_MASK 0x00000004U
#define MRV_FLASH_PREFLASH_ON_SHIFT 2U
//! Slice: flash_on:
//! flash on 
// 0: no effect 
// 1: flash delay counter is started at next trigger event 
// A capture event is signaled to the sensor interface block.
#define MRV_FLASH_FLASH_ON
#define MRV_FLASH_FLASH_ON_MASK 0x00000002U
#define MRV_FLASH_FLASH_ON_SHIFT 1U
//! Slice: prelight_on:
//! prelight on 
// 0: prelight is switched off at next trigger event 
// 1: prelight is switched on at next trigger event
#define MRV_FLASH_PRELIGHT_ON
#define MRV_FLASH_PRELIGHT_ON_MASK 0x00000001U
#define MRV_FLASH_PRELIGHT_ON_SHIFT 0U

//! Register: isp_flash_config: Flash config (0x00000004)
//! Slice: fl_cap_del:
//! capture delay 
// frame number (0 to 15) to be captured after trigger event
#define MRV_FLASH_FL_CAP_DEL
#define MRV_FLASH_FL_CAP_DEL_MASK 0x000000F0U
#define MRV_FLASH_FL_CAP_DEL_SHIFT 4U
//! Slice: fl_trig_src:
//! trigger source for flash and prelight 
// 0: use vds_vsync for trigger event (with evaluation of vs_in_edge)  
// 1: use fl_trig for trigger event (positive edge)
#define MRV_FLASH_FL_TRIG_SRC
#define MRV_FLASH_FL_TRIG_SRC_MASK 0x00000008U
#define MRV_FLASH_FL_TRIG_SRC_SHIFT 3U
//! Slice: fl_pol:
//! polarity of flash related signals 
// 0: flash_trig, prelight_trig are high active 
// 1: flash_trig, prelight_trig are low active
#define MRV_FLASH_FL_POL
#define MRV_FLASH_FL_POL_MASK 0x00000004U
#define MRV_FLASH_FL_POL_SHIFT 2U
//! Slice: vs_in_edge:
//! VSYNC edge 
// 0: use negative edge of vds_vsync if generating a trigger event 
// 1: use positive edge of vds_vsync if generating a trigger event
#define MRV_FLASH_VS_IN_EDGE
#define MRV_FLASH_VS_IN_EDGE_MASK 0x00000002U
#define MRV_FLASH_VS_IN_EDGE_SHIFT 1U
//! Slice: prelight_mode:
//! prelight mode 
// 0: prelight is switched off at begin of flash 
// 1: prelight is switched off at end of flash
#define MRV_FLASH_PRELIGHT_MODE
#define MRV_FLASH_PRELIGHT_MODE_MASK 0x00000001U
#define MRV_FLASH_PRELIGHT_MODE_SHIFT 0U

//! Register: isp_flash_prediv: Flash Counter Pre-Divider (0x00000008)
//! Slice: fl_pre_div:
//! pre-divider for flush/preflash counter
#define MRV_FLASH_FL_PRE_DIV
#define MRV_FLASH_FL_PRE_DIV_MASK 0x000003FFU
#define MRV_FLASH_FL_PRE_DIV_SHIFT 0U

//! Register: isp_flash_delay: Flash Delay (0x0000000c)
//! Slice: fl_delay:
//! counter value for flash/preflash delay 
// open_delay =  (fl_delay + 1) * (fl_pre_div+1) / clk_isp 
// fl_delay =  (open_delay * clk_isp) / (fl_pre_div+1) - 1
#define MRV_FLASH_FL_DELAY
#define MRV_FLASH_FL_DELAY_MASK 0x0003FFFFU
#define MRV_FLASH_FL_DELAY_SHIFT 0U

//! Register: isp_flash_time: Flash time (0x00000010)
//! Slice: fl_time:
//! counter value for flash/preflash time 
// open_time =  (fl_time + 1) * (fl_pre_div+1) / clk_isp 
// fl_time =  (open_time * clk_isp) / (fl_pre_div+1) - 1
#define MRV_FLASH_FL_TIME
#define MRV_FLASH_FL_TIME_MASK 0x0003FFFFU
#define MRV_FLASH_FL_TIME_SHIFT 0U

//! Register: isp_flash_maxp: Maximum value for flash or preflash (0x00000014)
//! Slice: fl_maxp:
//! maximum period value for flash or preflash 
// max. flash/preflash period = 214 * (fl_maxp + 1) / clk_isp 
// fl_maxp =  (max_period * clk_isp) / 214  - 1
#define MRV_FLASH_FL_MAXP
#define MRV_FLASH_FL_MAXP_MASK 0x0000FFFFU
#define MRV_FLASH_FL_MAXP_SHIFT 0U

//! Register: isp_sh_ctrl: mechanical shutter control (0x00000000)
//! Slice: sh_open_pol:
//! shutter_open polarity 
// 0: shutter_open is high active 
// 1: shutter_open is low active
#define MRV_SHUT_SH_OPEN_POL
#define MRV_SHUT_SH_OPEN_POL_MASK 0x00000010U
#define MRV_SHUT_SH_OPEN_POL_SHIFT 4U
//! Slice: sh_trig_en:
//! mechanical shutter trigger edge 
// 0: use negative edge of trigger signal 
// 1: use positive edge of trigger signal
#define MRV_SHUT_SH_TRIG_EN
#define MRV_SHUT_SH_TRIG_EN_MASK 0x00000008U
#define MRV_SHUT_SH_TRIG_EN_SHIFT 3U
//! Slice: sh_trig_src:
//! mechanical shutter trigger source 
// 0: use vds_vsync for trigger event  
// 1: use shutter_trig for trigger event
#define MRV_SHUT_SH_TRIG_SRC
#define MRV_SHUT_SH_TRIG_SRC_MASK 0x00000004U
#define MRV_SHUT_SH_TRIG_SRC_SHIFT 2U
//! Slice: sh_rep_en:
//! mechanical shutter repetition enable 
// 0: shutter is opened only once 
// 1: shutter is opened with the repetition rate of the trigger signal
#define MRV_SHUT_SH_REP_EN
#define MRV_SHUT_SH_REP_EN_MASK 0x00000002U
#define MRV_SHUT_SH_REP_EN_SHIFT 1U
//! Slice: sh_en:
//! mechanical shutter enable 
// 0: mechanical shutter function is disabled 
// 1: mechanical shutter function is enabled
#define MRV_SHUT_SH_EN
#define MRV_SHUT_SH_EN_MASK 0x00000001U
#define MRV_SHUT_SH_EN_SHIFT 0U

//! Register: isp_sh_prediv: Mech. Shutter Counter Pre-Divider (0x00000004)
//! Slice: sh_pre_div:
//! pre-divider for mechanical shutter open_delay and open_time counter
#define MRV_SHUT_SH_PRE_DIV
#define MRV_SHUT_SH_PRE_DIV_MASK 0x000003FFU
#define MRV_SHUT_SH_PRE_DIV_SHIFT 0U

//! Register: isp_sh_delay: Delay register (0x00000008)
//! Slice: sh_delay:
//! counter value for delay 
// open_delay =  (sh_delay + 1) * (fl_pre_div+1) / clk_isp 
// sh_delay =  (open_delay * clk_isp) / (sh_pre_div+1)  1
#define MRV_SHUT_SH_DELAY
#define MRV_SHUT_SH_DELAY_MASK 0x000FFFFFU
#define MRV_SHUT_SH_DELAY_SHIFT 0U

//! Register: isp_sh_time: Time register (0x0000000c)
//! Slice: sh_time:
//! counter value for time 
// open_time =  (sh_time + 1) * (fl_pre_div+1) / clk_isp 
// sh_time =  (open_time * clk_isp) / (sh_pre_div+1) - 1
#define MRV_SHUT_SH_TIME
#define MRV_SHUT_SH_TIME_MASK 0x000FFFFFU
#define MRV_SHUT_SH_TIME_SHIFT 0U

//! Register: cproc_ctrl: Global control register (0x00000000)
//! Slice: cproc_c_out_range:
//! Color processing chrominance pixel clipping range at output 
// 0: CbCr_out clipping range 16..240 according to ITU-R BT.601 standard 
// 1: full UV_out clipping range 0..255
#define MRV_CPROC_CPROC_C_OUT_RANGE
#define MRV_CPROC_CPROC_C_OUT_RANGE_MASK 0x00000008U
#define MRV_CPROC_CPROC_C_OUT_RANGE_SHIFT 3U
//! Slice: cproc_y_in_range:
//! Color processing luminance input range (offset processing) 
// 0: Y_in range 64..940 according to ITU-R BT.601 standard; 
// offset of 64 will be subtracted from Y_in  
// 1: Y_in full range 0..1023;  no offset will be subtracted from Y_in
#define MRV_CPROC_CPROC_Y_IN_RANGE
#define MRV_CPROC_CPROC_Y_IN_RANGE_MASK 0x00000004U
#define MRV_CPROC_CPROC_Y_IN_RANGE_SHIFT 2U
//! Slice: cproc_y_out_range:
//! Color processing luminance output clipping range 
// 0: Y_out clipping range 16..235; offset of 16 is added to Y_out according to ITU-R BT.601 standard 
// 1: Y_out clipping range 0..255; no offset is added to Y_out
#define MRV_CPROC_CPROC_Y_OUT_RANGE
#define MRV_CPROC_CPROC_Y_OUT_RANGE_MASK 0x00000002U
#define MRV_CPROC_CPROC_Y_OUT_RANGE_SHIFT 1U
//! Slice: cproc_enable:
//! color processing enable 
// 0: color processing is bypassed  
// 2 * 10 Bit input data are truncated to 2 * 8Bit output data  
// 1: color processing is active  
// output data are rounded to 2 * 8Bit and clipping is active
#define MRV_CPROC_CPROC_ENABLE
#define MRV_CPROC_CPROC_ENABLE_MASK 0x00000001U
#define MRV_CPROC_CPROC_ENABLE_SHIFT 0U

//! Register: cproc_contrast: Color Processing contrast register (0x00000004)
//! Slice: cproc_contrast:
//! contrast adjustment value 
// 00H equals x 0.0 
//  
// 80H equals x 1.0 
//  
// FFH equals x 1.992
#define MRV_CPROC_CPROC_CONTRAST
#define MRV_CPROC_CPROC_CONTRAST_MASK 0x000000FFU
#define MRV_CPROC_CPROC_CONTRAST_SHIFT 0U

//! Register: cproc_brightness: Color Processing brightness register (0x00000008)
//! Slice: cproc_brightness:
//! brightness adjustment value 
// 80H equals -128 
//  
// 00H equals +0  
//  
// 7FH equals +127
#define MRV_CPROC_CPROC_BRIGHTNESS
#define MRV_CPROC_CPROC_BRIGHTNESS_MASK 0x000000FFU
#define MRV_CPROC_CPROC_BRIGHTNESS_SHIFT 0U

//! Register: cproc_saturation: Color Processing saturation register (0x0000000c)
//! Slice: cproc_saturation:
//! saturation adjustment value 
// 00H equals x 0.0 
//  
// 80H equals x 1.0 
//  
// FFH equals x 1.992
#define MRV_CPROC_CPROC_SATURATION
#define MRV_CPROC_CPROC_SATURATION_MASK 0x000000FFU
#define MRV_CPROC_CPROC_SATURATION_SHIFT 0U

//! Register: cproc_hue: Color Processing hue register (0x00000010)
//! Slice: cproc_hue:
//! hue adjustment value 
// 80H equals -90 deg 
//  
// 00H equals 0 deg 
//  
// 7FH equals +87.188 deg
#define MRV_CPROC_CPROC_HUE
#define MRV_CPROC_CPROC_HUE_MASK 0x000000FFU
#define MRV_CPROC_CPROC_HUE_SHIFT 0U

//! Register: dual_crop_ctrl: Global control register (0x00000000)
//! Slice: DUAL_CROP_GEN_CFG_UPD:
//! 1: generate frame synchronous configuration signal at the output for shadow registers of the following processing modules, write only
#define MRV_dual_crop_DUAL_CROP_GEN_CFG_UPD
#define MRV_dual_crop_DUAL_CROP_GEN_CFG_UPD_MASK 0x00000040U
#define MRV_dual_crop_DUAL_CROP_GEN_CFG_UPD_SHIFT 6U
//! Slice: DUAL_CROP_CFG_UPD:
//! 1: immediately configure (update) shadow registers, write only
#define MRV_dual_crop_DUAL_CROP_CFG_UPD
#define MRV_dual_crop_DUAL_CROP_CFG_UPD_MASK 0x00000020U
#define MRV_dual_crop_DUAL_CROP_CFG_UPD_SHIFT 5U
//! Slice: DUAL_CROP_CFG_UPD_PERMANENT:
//! 1: permanent configure (update) shadow registers on frame end.
#define MRV_dual_crop_DUAL_CROP_CFG_UPD_PERMANENT
#define MRV_dual_crop_DUAL_CROP_CFG_UPD_PERMANENT_MASK 0x00000010U
#define MRV_dual_crop_DUAL_CROP_CFG_UPD_PERMANENT_SHIFT 4U
//! Slice: CROP_SP_MODE:
//! Self Path Cropping mode 
// 00: bypass 
// 01: YUV 
// 10: Raw 
// 11: data
#define MRV_dual_crop_CROP_SP_MODE
#define MRV_dual_crop_CROP_SP_MODE_MASK 0x0000000CU
#define MRV_dual_crop_CROP_SP_MODE_SHIFT 2U
//! Slice: CROP_MP_MODE:
//! Main Path Cropping mode 
// 00: bypass 
// 01: YUV 
// 10: Raw 
// 11: data
#define MRV_dual_crop_CROP_MP_MODE
#define MRV_dual_crop_CROP_MP_MODE_MASK 0x00000003U
#define MRV_dual_crop_CROP_MP_MODE_SHIFT 0U

//! Register: dual_crop_m_h_offs: Main Path Horizontal offset of output window (0x00000004)
//! Slice: DUAL_CROP_M_H_OFFS:
//! horizontal pic offset in pixels 
//01-(YUV), only even numbers are accepted, 
// because complete quadruples of YUYV(YCbYCr) are needed for the 422 output. (if an odd size is programmed the value will be truncated to even size)
#define MRV_dual_crop_DUAL_CROP_M_H_OFFS
#define MRV_dual_crop_DUAL_CROP_M_H_OFFS_MASK 0x00003FFFU
#define MRV_dual_crop_DUAL_CROP_M_H_OFFS_SHIFT 0U

//! Register: dual_crop_m_v_offs: Main Path Vertical offset of output window (0x00000008)
//! Slice: DUAL_CROP_M_V_OFFS:
//! vertical pic offset in lines
#define MRV_dual_crop_DUAL_CROP_M_V_OFFS
#define MRV_dual_crop_DUAL_CROP_M_V_OFFS_MASK 0x00003FFFU
#define MRV_dual_crop_DUAL_CROP_M_V_OFFS_SHIFT 0U

//! Register: dual_crop_m_h_size: Main Path Output horizontal picture size (0x0000000c)
//! Slice: DUAL_CROP_M_H_SIZE:
//! horizontal picture size in pixels  
// if CROP_MP_MODE is set to 
// 01-(YUV), only even numbers are accepted, 
// because complete quadruples of YUYV(YCbYCr) are needed for the 422 output. (if an odd size is programmed the value will be truncated to even size)
#define MRV_dual_crop_DUAL_CROP_M_H_SIZE
#define MRV_dual_crop_DUAL_CROP_M_H_SIZE_MASK 0x00003FFFU
#define MRV_dual_crop_DUAL_CROP_M_H_SIZE_SHIFT 0U

//! Register: dual_crop_m_v_size: Main Path Output vertical picture size (0x00000010)
//! Slice: DUAL_CROP_M_V_SIZE:
//! vertical pic size in lines
#define MRV_dual_crop_DUAL_CROP_M_V_SIZE
#define MRV_dual_crop_DUAL_CROP_M_V_SIZE_MASK 0x00003FFFU
#define MRV_dual_crop_DUAL_CROP_M_V_SIZE_SHIFT 0U

//! Register: dual_crop_s_h_offs: Self Path Horizontal offset of output window (0x00000014)
//! Slice: DUAL_CROP_S_H_OFFS:
//! horizontal pic offset in pixels 
//01-(YUV), only even numbers are accepted, 
// because complete quadruples of YUYV(YCbYCr) are needed for the 422 output. (if an odd size is programmed the value will be truncated to even size)
#define MRV_dual_crop_DUAL_CROP_S_H_OFFS
#define MRV_dual_crop_DUAL_CROP_S_H_OFFS_MASK 0x00003FFFU
#define MRV_dual_crop_DUAL_CROP_S_H_OFFS_SHIFT 0U

//! Register: dual_crop_s_v_offs: Self Path Vertical offset of output window (0x00000018)
//! Slice: DUAL_CROP_S_V_OFFS:
//! vertical pic offset in lines
#define MRV_dual_crop_DUAL_CROP_S_V_OFFS
#define MRV_dual_crop_DUAL_CROP_S_V_OFFS_MASK 0x00003FFFU
#define MRV_dual_crop_DUAL_CROP_S_V_OFFS_SHIFT 0U

//! Register: dual_crop_s_h_size: Self Path Output horizontal picture size (0x0000001c)
//! Slice: DUAL_CROP_S_H_SIZE:
//! horizontal picture size in pixels  
// if CROP_SP_MODE is set to 
// 01-(YUV), only even numbers are accepted, 
// because complete quadruples of YUYV(YCbYCr) are needed for the 422 output. (if an odd size is programmed the value will be truncated to even size)
#define MRV_dual_crop_DUAL_CROP_S_H_SIZE
#define MRV_dual_crop_DUAL_CROP_S_H_SIZE_MASK 0x00003FFFU
#define MRV_dual_crop_DUAL_CROP_S_H_SIZE_SHIFT 0U

//! Register: dual_crop_s_v_size: Self Path Output vertical picture size (0x00000020)
//! Slice: DUAL_CROP_S_V_SIZE:
//! vertical pic size in lines
#define MRV_dual_crop_DUAL_CROP_S_V_SIZE
#define MRV_dual_crop_DUAL_CROP_S_V_SIZE_MASK 0x00003FFFU
#define MRV_dual_crop_DUAL_CROP_S_V_SIZE_SHIFT 0U

//! Register: dual_crop_m_h_offs_shd: current horizontal offset of output window (shadow register) (0x00000024)
//! Slice: M_H_OFFS_SHD:
//! current horizontal pic offset in pixels
#define MRV_dual_crop_M_H_OFFS_SHD
#define MRV_dual_crop_M_H_OFFS_SHD_MASK 0x00003FFFU
#define MRV_dual_crop_M_H_OFFS_SHD_SHIFT 0U

//! Register: dual_crop_m_v_offs_shd: current vertical offset of output window (shadow register) (0x00000028)
//! Slice: M_V_OFFS_SHD:
//! current vertical pic offset in lines
#define MRV_dual_crop_M_V_OFFS_SHD
#define MRV_dual_crop_M_V_OFFS_SHD_MASK 0x00003FFFU
#define MRV_dual_crop_M_V_OFFS_SHD_SHIFT 0U

//! Register: dual_crop_m_h_size_shd: current output horizontal picture size (shadow register) (0x0000002c)
//! Slice: M_H_SIZE_SHD:
//! current horizontal pic size in pixels
#define MRV_dual_crop_M_H_SIZE_SHD
#define MRV_dual_crop_M_H_SIZE_SHD_MASK 0x00007FFFU
#define MRV_dual_crop_M_H_SIZE_SHD_SHIFT 0U

//! Register: dual_crop_m_v_size_shd: current output vertical picture size (shadow register) (0x00000030)
//! Slice: M_V_SIZE_SHD:
//! vertical pic size in lines
#define MRV_dual_crop_M_V_SIZE_SHD
#define MRV_dual_crop_M_V_SIZE_SHD_MASK 0x00003FFFU
#define MRV_dual_crop_M_V_SIZE_SHD_SHIFT 0U

//! Register: dual_crop_s_h_offs_shd: current horizontal offset of output window (shadow register) (0x00000034)
//! Slice: S_H_OFFS_SHD:
//! current horizontal pic offset in pixels
#define MRV_dual_crop_S_H_OFFS_SHD
#define MRV_dual_crop_S_H_OFFS_SHD_MASK 0x00003FFFU
#define MRV_dual_crop_S_H_OFFS_SHD_SHIFT 0U

//! Register: dual_crop_s_v_offs_shd: current vertical offset of output window (shadow register) (0x00000038)
//! Slice: S_V_OFFS_SHD:
//! current vertical pic offset in lines
#define MRV_dual_crop_S_V_OFFS_SHD
#define MRV_dual_crop_S_V_OFFS_SHD_MASK 0x00003FFFU
#define MRV_dual_crop_S_V_OFFS_SHD_SHIFT 0U

//! Register: dual_crop_s_h_size_shd: current output horizontal picture size (shadow register) (0x0000003c)
//! Slice: S_H_SIZE_SHD:
//! current horizontal pic size in pixels
#define MRV_dual_crop_S_H_SIZE_SHD
#define MRV_dual_crop_S_H_SIZE_SHD_MASK 0x00007FFFU
#define MRV_dual_crop_S_H_SIZE_SHD_SHIFT 0U

//! Register: dual_crop_s_v_size_shd: current output vertical picture size (shadow register) (0x00000040)
//! Slice: S_V_SIZE_SHD:
//! vertical pic size in lines
#define MRV_dual_crop_S_V_SIZE_SHD
#define MRV_dual_crop_S_V_SIZE_SHD_MASK 0x00003FFFU
#define MRV_dual_crop_S_V_SIZE_SHD_SHIFT 0U

//! Register: mrsz_ctrl: global control register (0x00000000)
//! Slice: auto_upd:
//! 1: automatic register update at frame end enabled. 
// 0: automatic register update at frame end disabled.
#define MRV_MRSZ_AUTO_UPD
#define MRV_MRSZ_AUTO_UPD_MASK 0x00000200U
#define MRV_MRSZ_AUTO_UPD_SHIFT 9U
//! Slice: cfg_upd:
//! write 0: nothing happens 
// write 1: update shadow registers 
// read: always 0
#define MRV_MRSZ_CFG_UPD
#define MRV_MRSZ_CFG_UPD_MASK 0x00000100U
#define MRV_MRSZ_CFG_UPD_SHIFT 8U
//! Slice: scale_vc_up:
//! 1: vertical chrominance upscaling selected 
// 0: vertical chrominance downscaling selected
#define MRV_MRSZ_SCALE_VC_UP
#define MRV_MRSZ_SCALE_VC_UP_MASK 0x00000080U
#define MRV_MRSZ_SCALE_VC_UP_SHIFT 7U
//! Slice: scale_vy_up:
//! 1: vertical luminance upscaling selected 
// 0: vertical luminance downscaling selected
#define MRV_MRSZ_SCALE_VY_UP
#define MRV_MRSZ_SCALE_VY_UP_MASK 0x00000040U
#define MRV_MRSZ_SCALE_VY_UP_SHIFT 6U
//! Slice: scale_hc_up:
//! 1: horizontal chrominance upscaling selected 
// 0: horizontal chrominance downscaling selected
#define MRV_MRSZ_SCALE_HC_UP
#define MRV_MRSZ_SCALE_HC_UP_MASK 0x00000020U
#define MRV_MRSZ_SCALE_HC_UP_SHIFT 5U
//! Slice: scale_hy_up:
//! 1: horizontal luminance upscaling selected 
// 0: horizontal luminance downscaling selected
#define MRV_MRSZ_SCALE_HY_UP
#define MRV_MRSZ_SCALE_HY_UP_MASK 0x00000010U
#define MRV_MRSZ_SCALE_HY_UP_SHIFT 4U
//! Slice: scale_vc_enable:
//! 0: bypass vertical chrominance scaling unit  
// 1: enable vertical chrominance scaling unit
#define MRV_MRSZ_SCALE_VC_ENABLE
#define MRV_MRSZ_SCALE_VC_ENABLE_MASK 0x00000008U
#define MRV_MRSZ_SCALE_VC_ENABLE_SHIFT 3U
//! Slice: scale_vy_enable:
//! 0: bypass vertical luminance scaling unit  
// 1: enable vertical luminance scaling unit
#define MRV_MRSZ_SCALE_VY_ENABLE
#define MRV_MRSZ_SCALE_VY_ENABLE_MASK 0x00000004U
#define MRV_MRSZ_SCALE_VY_ENABLE_SHIFT 2U
//! Slice: scale_hc_enable:
//! 0: bypass horizontal chrominance scaling unit  
// 1: enable horizontal chrominance scaling unit
#define MRV_MRSZ_SCALE_HC_ENABLE
#define MRV_MRSZ_SCALE_HC_ENABLE_MASK 0x00000002U
#define MRV_MRSZ_SCALE_HC_ENABLE_SHIFT 1U
//! Slice: scale_hy_enable:
//! 0: bypass horizontal luminance scaling unit  
// 1: enable horizontal luminance scaling unit
#define MRV_MRSZ_SCALE_HY_ENABLE
#define MRV_MRSZ_SCALE_HY_ENABLE_MASK 0x00000001U
#define MRV_MRSZ_SCALE_HY_ENABLE_SHIFT 0U

//! Register: mrsz_scale_hy: horizontal luminance scale factor register (0x00000004)
//! Slice: scale_hy:
//! This register is set to the horizontal luminance downscale factor or to the reciprocal of the horizontal luminance upscale factor
#define MRV_MRSZ_SCALE_HY
#define MRV_MRSZ_SCALE_HY_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_HY_SHIFT 0U

//! Register: mrsz_scale_hcb: horizontal Cb scale factor register (0x00000008)
//! Slice: scale_hcb:
//! This register is set to the horizontal Cb downscale factor or to the reciprocal of the horizontal Cb upscale factor
#define MRV_MRSZ_SCALE_HCB
#define MRV_MRSZ_SCALE_HCB_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_HCB_SHIFT 0U

//! Register: mrsz_scale_hcr: horizontal Cr scale factor register (0x0000000c)
//! Slice: scale_hcr:
//! This register is set to the horizontal Cr downscale factor or to the reciprocal of the horizontal Cr upscale factor
#define MRV_MRSZ_SCALE_HCR
#define MRV_MRSZ_SCALE_HCR_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_HCR_SHIFT 0U

//! Register: mrsz_scale_vy: vertical luminance scale factor register (0x00000010)
//! Slice: scale_vy:
//! This register is set to the vertical luminance downscale factor or to the reciprocal of the vertical luminance upscale factor
#define MRV_MRSZ_SCALE_VY
#define MRV_MRSZ_SCALE_VY_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_VY_SHIFT 0U

//! Register: mrsz_scale_vc: vertical chrominance scale factor register (0x00000014)
//! Slice: scale_vc:
//! This register is set to the vertical chrominance downscale factor or to the reciprocal of the vertical chrominance upscale factor
#define MRV_MRSZ_SCALE_VC
#define MRV_MRSZ_SCALE_VC_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_VC_SHIFT 0U

//! Register: mrsz_phase_hy: horizontal luminance phase register (0x00000018)
//! Slice: phase_hy:
//! This register is set to the horizontal luminance phase offset
#define MRV_MRSZ_PHASE_HY
#define MRV_MRSZ_PHASE_HY_MASK 0x0000FFFFU
#define MRV_MRSZ_PHASE_HY_SHIFT 0U

//! Register: mrsz_phase_hc: horizontal chrominance phase register (0x0000001c)
//! Slice: phase_hc:
//! This register is set to the horizontal chrominance phase offset
#define MRV_MRSZ_PHASE_HC
#define MRV_MRSZ_PHASE_HC_MASK 0x0000FFFFU
#define MRV_MRSZ_PHASE_HC_SHIFT 0U

//! Register: mrsz_phase_vy: vertical luminance phase register (0x00000020)
//! Slice: phase_vy:
//! This register is set to the vertical luminance phase offset
#define MRV_MRSZ_PHASE_VY
#define MRV_MRSZ_PHASE_VY_MASK 0x0000FFFFU
#define MRV_MRSZ_PHASE_VY_SHIFT 0U

//! Register: mrsz_phase_vc: vertical chrominance phase register (0x00000024)
//! Slice: phase_vc:
//! This register is set to the vertical chrominance phase offset
#define MRV_MRSZ_PHASE_VC
#define MRV_MRSZ_PHASE_VC_MASK 0x0000FFFFU
#define MRV_MRSZ_PHASE_VC_SHIFT 0U

//! Register: mrsz_scale_lut_addr: Address pointer of up-scaling look up table (0x00000028)
//! Slice: scale_lut_addr:
//! Pointer to entry of lookup table
#define MRV_MRSZ_SCALE_LUT_ADDR
#define MRV_MRSZ_SCALE_LUT_ADDR_MASK 0x0000003FU
#define MRV_MRSZ_SCALE_LUT_ADDR_SHIFT 0U

//! Register: mrsz_scale_lut: Entry of up-scaling look up table (0x0000002c)
//! Slice: scale_lut:
//! Entry of lookup table at position scale_lut_addr. The lookup table must be filled with appropriate values before the up-scaling functionality can be used.
#define MRV_MRSZ_SCALE_LUT
#define MRV_MRSZ_SCALE_LUT_MASK 0x0000003FU
#define MRV_MRSZ_SCALE_LUT_SHIFT 0U

//! Register: mrsz_ctrl_shd: global control shadow register (0x00000030)
//! Slice: scale_vc_up_shd:
//! 1: vertical chrominance upscaling selected 
// 0: vertical chrominance downscaling selected
#define MRV_MRSZ_SCALE_VC_UP_SHD
#define MRV_MRSZ_SCALE_VC_UP_SHD_MASK 0x00000080U
#define MRV_MRSZ_SCALE_VC_UP_SHD_SHIFT 7U
//! Slice: scale_vy_up_shd:
//! 1: vertical luminance upscaling selected 
// 0: vertical luminance downscaling selected
#define MRV_MRSZ_SCALE_VY_UP_SHD
#define MRV_MRSZ_SCALE_VY_UP_SHD_MASK 0x00000040U
#define MRV_MRSZ_SCALE_VY_UP_SHD_SHIFT 6U
//! Slice: scale_hc_up_shd:
//! 1: horizontal chrominance upscaling selected 
// 0: horizontal chrominance downscaling selected
#define MRV_MRSZ_SCALE_HC_UP_SHD
#define MRV_MRSZ_SCALE_HC_UP_SHD_MASK 0x00000020U
#define MRV_MRSZ_SCALE_HC_UP_SHD_SHIFT 5U
//! Slice: scale_hy_up_shd:
//! 1: horizontal luminance upscaling selected 
// 0: horizontal luminance downscaling selected
#define MRV_MRSZ_SCALE_HY_UP_SHD
#define MRV_MRSZ_SCALE_HY_UP_SHD_MASK 0x00000010U
#define MRV_MRSZ_SCALE_HY_UP_SHD_SHIFT 4U
//! Slice: scale_vc_enable_shd:
//! 0: bypass vertical chrominance scaling unit  
// 1: enable vertical chrominance scaling unit
#define MRV_MRSZ_SCALE_VC_ENABLE_SHD
#define MRV_MRSZ_SCALE_VC_ENABLE_SHD_MASK 0x00000008U
#define MRV_MRSZ_SCALE_VC_ENABLE_SHD_SHIFT 3U
//! Slice: scale_vy_enable_shd:
//! 0: bypass vertical luminance scaling unit  
// 1: enable vertical luminance scaling unit
#define MRV_MRSZ_SCALE_VY_ENABLE_SHD
#define MRV_MRSZ_SCALE_VY_ENABLE_SHD_MASK 0x00000004U
#define MRV_MRSZ_SCALE_VY_ENABLE_SHD_SHIFT 2U
//! Slice: scale_hc_enable_shd:
//! 0: bypass horizontal chrominance scaling unit  
// 1: enable horizontal chrominance scaling unit
#define MRV_MRSZ_SCALE_HC_ENABLE_SHD
#define MRV_MRSZ_SCALE_HC_ENABLE_SHD_MASK 0x00000002U
#define MRV_MRSZ_SCALE_HC_ENABLE_SHD_SHIFT 1U
//! Slice: scale_hy_enable_shd:
//! 0: bypass horizontal luminance scaling unit  
// 1: enable horizontal luminance scaling unit
#define MRV_MRSZ_SCALE_HY_ENABLE_SHD
#define MRV_MRSZ_SCALE_HY_ENABLE_SHD_MASK 0x00000001U
#define MRV_MRSZ_SCALE_HY_ENABLE_SHD_SHIFT 0U

//! Register: mrsz_scale_hy_shd: horizontal luminance scale factor shadow register (0x00000034)
//! Slice: scale_hy_shd:
//! This register is set to the horizontal luminance downscale factor or to the reciprocal of the horizontal luminance upscale factor
#define MRV_MRSZ_SCALE_HY_SHD
#define MRV_MRSZ_SCALE_HY_SHD_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_HY_SHD_SHIFT 0U

//! Register: mrsz_scale_hcb_shd: horizontal Cb scale factor shadow register (0x00000038)
//! Slice: scale_hcb_shd:
//! This register is set to the horizontal Cb downscale factor or to the reciprocal of the horizontal Cb upscale factor
#define MRV_MRSZ_SCALE_HCB_SHD
#define MRV_MRSZ_SCALE_HCB_SHD_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_HCB_SHD_SHIFT 0U

//! Register: mrsz_scale_hcr_shd: horizontal Cr scale factor shadow register (0x0000003c)
//! Slice: scale_hcr_shd:
//! This register is set to the horizontal Cr downscale factor or to the reciprocal of the horizontal Cr upscale factor
#define MRV_MRSZ_SCALE_HCR_SHD
#define MRV_MRSZ_SCALE_HCR_SHD_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_HCR_SHD_SHIFT 0U

//! Register: mrsz_scale_vy_shd: vertical luminance scale factor shadow register (0x00000040)
//! Slice: scale_vy_shd:
//! This register is set to the vertical luminance downscale factor or to the reciprocal of the vertical luminance upscale factor
#define MRV_MRSZ_SCALE_VY_SHD
#define MRV_MRSZ_SCALE_VY_SHD_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_VY_SHD_SHIFT 0U

//! Register: mrsz_scale_vc_shd: vertical chrominance scale factor shadow register (0x00000044)
//! Slice: scale_vc_shd:
//! This register is set to the vertical chrominance downscale factor or to the reciprocal of the vertical chrominance upscale factor
#define MRV_MRSZ_SCALE_VC_SHD
#define MRV_MRSZ_SCALE_VC_SHD_MASK 0x0000FFFFU
#define MRV_MRSZ_SCALE_VC_SHD_SHIFT 0U

//! Register: mrsz_phase_hy_shd: horizontal luminance phase shadow register (0x00000048)
//! Slice: phase_hy_shd:
//! This register is set to the horizontal luminance phase offset
#define MRV_MRSZ_PHASE_HY_SHD
#define MRV_MRSZ_PHASE_HY_SHD_MASK 0x0000FFFFU
#define MRV_MRSZ_PHASE_HY_SHD_SHIFT 0U

//! Register: mrsz_phase_hc_shd: horizontal chrominance phase shadow register (0x0000004c)
//! Slice: phase_hc_shd:
//! This register is set to the horizontal chrominance phase offset
#define MRV_MRSZ_PHASE_HC_SHD
#define MRV_MRSZ_PHASE_HC_SHD_MASK 0x0000FFFFU
#define MRV_MRSZ_PHASE_HC_SHD_SHIFT 0U

//! Register: mrsz_phase_vy_shd: vertical luminance phase shadow register (0x00000050)
//! Slice: phase_vy_shd:
//! This register is set to the vertical luminance phase offset
#define MRV_MRSZ_PHASE_VY_SHD
#define MRV_MRSZ_PHASE_VY_SHD_MASK 0x0000FFFFU
#define MRV_MRSZ_PHASE_VY_SHD_SHIFT 0U

//! Register: mrsz_phase_vc_shd: vertical chrominance phase shadow register (0x00000054)
//! Slice: phase_vc_shd:
//! This register is set to the vertical chrominance phase offset
#define MRV_MRSZ_PHASE_VC_SHD
#define MRV_MRSZ_PHASE_VC_SHD_MASK 0x0000FFFFU
#define MRV_MRSZ_PHASE_VC_SHD_SHIFT 0U

//! Register: srsz_ctrl: global control register (0x00000000)
//! Slice: auto_upd:
//! 1: automatic register update at frame end enabled. 
// 0: automatic register update at frame end disabled.
#define MRV_SRSZ_AUTO_UPD
#define MRV_SRSZ_AUTO_UPD_MASK 0x00000200U
#define MRV_SRSZ_AUTO_UPD_SHIFT 9U
//! Slice: cfg_upd:
//! write 0: nothing happens 
// write 1: update shadow registers 
// read: always 0
#define MRV_SRSZ_CFG_UPD
#define MRV_SRSZ_CFG_UPD_MASK 0x00000100U
#define MRV_SRSZ_CFG_UPD_SHIFT 8U
//! Slice: scale_vc_up:
//! 1: vertical chrominance upscaling selected 
// 0: vertical chrominance downscaling selected
#define MRV_SRSZ_SCALE_VC_UP
#define MRV_SRSZ_SCALE_VC_UP_MASK 0x00000080U
#define MRV_SRSZ_SCALE_VC_UP_SHIFT 7U
//! Slice: scale_vy_up:
//! 1: vertical luminance upscaling selected 
// 0: vertical luminance downscaling selected
#define MRV_SRSZ_SCALE_VY_UP
#define MRV_SRSZ_SCALE_VY_UP_MASK 0x00000040U
#define MRV_SRSZ_SCALE_VY_UP_SHIFT 6U
//! Slice: scale_hc_up:
//! 1: horizontal chrominance upscaling selected 
// 0: horizontal chrominance downscaling selected
#define MRV_SRSZ_SCALE_HC_UP
#define MRV_SRSZ_SCALE_HC_UP_MASK 0x00000020U
#define MRV_SRSZ_SCALE_HC_UP_SHIFT 5U
//! Slice: scale_hy_up:
//! 1: horizontal luminance upscaling selected 
// 0: horizontal luminance downscaling selected
#define MRV_SRSZ_SCALE_HY_UP
#define MRV_SRSZ_SCALE_HY_UP_MASK 0x00000010U
#define MRV_SRSZ_SCALE_HY_UP_SHIFT 4U
//! Slice: scale_vc_enable:
//! 0: bypass vertical chrominance scaling unit  
// 1: enable vertical chrominance scaling unit
#define MRV_SRSZ_SCALE_VC_ENABLE
#define MRV_SRSZ_SCALE_VC_ENABLE_MASK 0x00000008U
#define MRV_SRSZ_SCALE_VC_ENABLE_SHIFT 3U
//! Slice: scale_vy_enable:
//! 0: bypass vertical luminance scaling unit  
// 1: enable vertical luminance scaling unit
#define MRV_SRSZ_SCALE_VY_ENABLE
#define MRV_SRSZ_SCALE_VY_ENABLE_MASK 0x00000004U
#define MRV_SRSZ_SCALE_VY_ENABLE_SHIFT 2U
//! Slice: scale_hc_enable:
//! 0: bypass horizontal chrominance scaling unit  
// 1: enable horizontal chrominance scaling unit
#define MRV_SRSZ_SCALE_HC_ENABLE
#define MRV_SRSZ_SCALE_HC_ENABLE_MASK 0x00000002U
#define MRV_SRSZ_SCALE_HC_ENABLE_SHIFT 1U
//! Slice: scale_hy_enable:
//! 0: bypass horizontal luminance scaling unit  
// 1: enable horizontal luminance scaling unit
#define MRV_SRSZ_SCALE_HY_ENABLE
#define MRV_SRSZ_SCALE_HY_ENABLE_MASK 0x00000001U
#define MRV_SRSZ_SCALE_HY_ENABLE_SHIFT 0U

//! Register: srsz_scale_hy: horizontal luminance scale factor register (0x00000004)
//! Slice: scale_hy:
//! This register is set to the horizontal luminance downscale factor or to the reciprocal of the horizontal luminance upscale factor
#define MRV_SRSZ_SCALE_HY
#define MRV_SRSZ_SCALE_HY_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_HY_SHIFT 0U

//! Register: srsz_scale_hcb: horizontal chrominance scale factor register (0x00000008)
//! Slice: scale_hcb:
//! This register is set to the horizontal Cb downscale factor or to the reciprocal of the horizontal Cb upscale factor
#define MRV_SRSZ_SCALE_HCB
#define MRV_SRSZ_SCALE_HCB_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_HCB_SHIFT 0U

//! Register: srsz_scale_hcr: horizontal chrominance scale factor register (0x0000000c)
//! Slice: scale_hcr:
//! This register is set to the horizontal Cr downscale factor or to the reciprocal of the horizontal Cr upscale factor
#define MRV_SRSZ_SCALE_HCR
#define MRV_SRSZ_SCALE_HCR_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_HCR_SHIFT 0U

//! Register: srsz_scale_vy: vertical luminance scale factor register (0x00000010)
//! Slice: scale_vy:
//! This register is set to the vertical luminance downscale factor or to the reciprocal of the vertical luminance upscale factor
#define MRV_SRSZ_SCALE_VY
#define MRV_SRSZ_SCALE_VY_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_VY_SHIFT 0U

//! Register: srsz_scale_vc: vertical chrominance scale factor register (0x00000014)
//! Slice: scale_vc:
//! This register is set to the vertical chrominance downscale factor or to the reciprocal of the vertical chrominance upscale factor
#define MRV_SRSZ_SCALE_VC
#define MRV_SRSZ_SCALE_VC_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_VC_SHIFT 0U

//! Register: srsz_phase_hy: horizontal luminance phase register (0x00000018)
//! Slice: phase_hy:
//! This register is set to the horizontal luminance phase offset
#define MRV_SRSZ_PHASE_HY
#define MRV_SRSZ_PHASE_HY_MASK 0x0000FFFFU
#define MRV_SRSZ_PHASE_HY_SHIFT 0U

//! Register: srsz_phase_hc: horizontal chrominance phase register (0x0000001c)
//! Slice: phase_hc:
//! This register is set to the horizontal chrominance phase offset
#define MRV_SRSZ_PHASE_HC
#define MRV_SRSZ_PHASE_HC_MASK 0x0000FFFFU
#define MRV_SRSZ_PHASE_HC_SHIFT 0U

//! Register: srsz_phase_vy: vertical luminance phase register (0x00000020)
//! Slice: phase_vy:
//! This register is set to the vertical luminance phase offset
#define MRV_SRSZ_PHASE_VY
#define MRV_SRSZ_PHASE_VY_MASK 0x0000FFFFU
#define MRV_SRSZ_PHASE_VY_SHIFT 0U

//! Register: srsz_phase_vc: vertical chrominance phase register (0x00000024)
//! Slice: phase_vc:
//! This register is set to the vertical chrominance phase offset
#define MRV_SRSZ_PHASE_VC
#define MRV_SRSZ_PHASE_VC_MASK 0x0000FFFFU
#define MRV_SRSZ_PHASE_VC_SHIFT 0U

//! Register: srsz_scale_lut_addr: Address pointer of up-scaling look up table (0x00000028)
//! Slice: scale_lut_addr:
//! Pointer to entry of lookup table
#define MRV_SRSZ_SCALE_LUT_ADDR
#define MRV_SRSZ_SCALE_LUT_ADDR_MASK 0x0000003FU
#define MRV_SRSZ_SCALE_LUT_ADDR_SHIFT 0U

//! Register: srsz_scale_lut: Entry of up-scaling look up table (0x0000002c)
//! Slice: scale_lut:
//! Entry of lookup table at position scale_lut_addr. The lookup table must be filled with appropriate values before the up-scaling functionality can be used.
#define MRV_SRSZ_SCALE_LUT
#define MRV_SRSZ_SCALE_LUT_MASK 0x0000003FU
#define MRV_SRSZ_SCALE_LUT_SHIFT 0U

//! Register: srsz_ctrl_shd: global control shadow register (0x00000030)
//! Slice: scale_vc_up_shd:
//! 1: vertical chrominance upscaling selected 
// 0: vertical chrominance downscaling selected
#define MRV_SRSZ_SCALE_VC_UP_SHD
#define MRV_SRSZ_SCALE_VC_UP_SHD_MASK 0x00000080U
#define MRV_SRSZ_SCALE_VC_UP_SHD_SHIFT 7U
//! Slice: scale_vy_up_shd:
//! 1: vertical luminance upscaling selected 
// 0: vertical luminance downscaling selected
#define MRV_SRSZ_SCALE_VY_UP_SHD
#define MRV_SRSZ_SCALE_VY_UP_SHD_MASK 0x00000040U
#define MRV_SRSZ_SCALE_VY_UP_SHD_SHIFT 6U
//! Slice: scale_hc_up_shd:
//! 1: horizontal chrominance upscaling selected 
// 0: horizontal chrominance downscaling selected
#define MRV_SRSZ_SCALE_HC_UP_SHD
#define MRV_SRSZ_SCALE_HC_UP_SHD_MASK 0x00000020U
#define MRV_SRSZ_SCALE_HC_UP_SHD_SHIFT 5U
//! Slice: scale_hy_up_shd:
//! 1: horizontal luminance upscaling selected 
// 0: horizontal luminance downscaling selected
#define MRV_SRSZ_SCALE_HY_UP_SHD
#define MRV_SRSZ_SCALE_HY_UP_SHD_MASK 0x00000010U
#define MRV_SRSZ_SCALE_HY_UP_SHD_SHIFT 4U
//! Slice: scale_vc_enable_shd:
//! 0: bypass vertical chrominance scaling unit  
// 1: enable vertical chrominance scaling unit
#define MRV_SRSZ_SCALE_VC_ENABLE_SHD
#define MRV_SRSZ_SCALE_VC_ENABLE_SHD_MASK 0x00000008U
#define MRV_SRSZ_SCALE_VC_ENABLE_SHD_SHIFT 3U
//! Slice: scale_vy_enable_shd:
//! 0: bypass vertical luminance scaling unit  
// 1: enable vertical luminance scaling unit
#define MRV_SRSZ_SCALE_VY_ENABLE_SHD
#define MRV_SRSZ_SCALE_VY_ENABLE_SHD_MASK 0x00000004U
#define MRV_SRSZ_SCALE_VY_ENABLE_SHD_SHIFT 2U
//! Slice: scale_hc_enable_shd:
//! 0: bypass horizontal chrominance scaling unit  
// 1: enable horizontal chrominance scaling unit
#define MRV_SRSZ_SCALE_HC_ENABLE_SHD
#define MRV_SRSZ_SCALE_HC_ENABLE_SHD_MASK 0x00000002U
#define MRV_SRSZ_SCALE_HC_ENABLE_SHD_SHIFT 1U
//! Slice: scale_hy_enable_shd:
//! 0: bypass horizontal luminance scaling unit  
// 1: enable horizontal luminance scaling unit
#define MRV_SRSZ_SCALE_HY_ENABLE_SHD
#define MRV_SRSZ_SCALE_HY_ENABLE_SHD_MASK 0x00000001U
#define MRV_SRSZ_SCALE_HY_ENABLE_SHD_SHIFT 0U

//! Register: srsz_scale_hy_shd: horizontal luminance scale factor shadow register (0x00000034)
//! Slice: scale_hy_shd:
//! This register is set to the horizontal luminance downscale factor or to the reciprocal of the horizontal luminance upscale factor
#define MRV_SRSZ_SCALE_HY_SHD
#define MRV_SRSZ_SCALE_HY_SHD_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_HY_SHD_SHIFT 0U

//! Register: srsz_scale_hcb_shd: horizontal Cb scale factor shadow register (0x00000038)
//! Slice: scale_hcb_shd:
//! This register is set to the horizontal Cb downscale factor or to the reciprocal of the horizontal Cb upscale factor
#define MRV_SRSZ_SCALE_HCB_SHD
#define MRV_SRSZ_SCALE_HCB_SHD_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_HCB_SHD_SHIFT 0U

//! Register: srsz_scale_hcr_shd: horizontal Cr scale factor shadow register (0x0000003c)
//! Slice: scale_hcr_shd:
//! This register is set to the horizontal r downscale factor or to the reciprocal of the horizontal r upscale factor
#define MRV_SRSZ_SCALE_HCR_SHD
#define MRV_SRSZ_SCALE_HCR_SHD_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_HCR_SHD_SHIFT 0U

//! Register: srsz_scale_vy_shd: vertical luminance scale factor shadow register (0x00000040)
//! Slice: scale_vy_shd:
//! This register is set to the vertical luminance downscale factor or to the reciprocal of the vertical luminance upscale factor
#define MRV_SRSZ_SCALE_VY_SHD
#define MRV_SRSZ_SCALE_VY_SHD_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_VY_SHD_SHIFT 0U

//! Register: srsz_scale_vc_shd: vertical chrominance scale factor shadow register (0x00000044)
//! Slice: scale_vc_shd:
//! This register is set to the vertical chrominance downscale factor or to the reciprocal of the vertical chrominance upscale factor
#define MRV_SRSZ_SCALE_VC_SHD
#define MRV_SRSZ_SCALE_VC_SHD_MASK 0x0000FFFFU
#define MRV_SRSZ_SCALE_VC_SHD_SHIFT 0U

//! Register: srsz_phase_hy_shd: horizontal luminance phase shadow register (0x00000048)
//! Slice: phase_hy_shd:
//! This register is set to the horizontal luminance phase offset
#define MRV_SRSZ_PHASE_HY_SHD
#define MRV_SRSZ_PHASE_HY_SHD_MASK 0x0000FFFFU
#define MRV_SRSZ_PHASE_HY_SHD_SHIFT 0U

//! Register: srsz_phase_hc_shd: horizontal chrominance phase shadow register (0x0000004c)
//! Slice: phase_hc_shd:
//! This register is set to the horizontal chrominance phase offset
#define MRV_SRSZ_PHASE_HC_SHD
#define MRV_SRSZ_PHASE_HC_SHD_MASK 0x0000FFFFU
#define MRV_SRSZ_PHASE_HC_SHD_SHIFT 0U

//! Register: srsz_phase_vy_shd: vertical luminance phase shadow register (0x00000050)
//! Slice: phase_vy_shd:
//! This register is set to the vertical luminance phase offset
#define MRV_SRSZ_PHASE_VY_SHD
#define MRV_SRSZ_PHASE_VY_SHD_MASK 0x0000FFFFU
#define MRV_SRSZ_PHASE_VY_SHD_SHIFT 0U

//! Register: srsz_phase_vc_shd: vertical chrominance phase shadow register (0x00000054)
//! Slice: phase_vc_shd:
//! This register is set to the vertical chrominance phase offset
#define MRV_SRSZ_PHASE_VC_SHD
#define MRV_SRSZ_PHASE_VC_SHD_MASK 0x0000FFFFU
#define MRV_SRSZ_PHASE_VC_SHD_SHIFT 0U

//! Register: mi_ctrl: Global control register (0x00000000)
//! Slice: sp_output_format:
//! Selects output format of self picture. For possible restrictions see sub-chapter "Picture Orientation" in chapter "Self Path Output Programming". 
// 
// 111: reserved 
// 110: RGB 888 
// 101: RGB 666 
// 100: RGB 565 
// 
// 011: YCbCr  4:4:4 
// 010: YCbCr  4:2:2 
// 001: YCbCr  4:2:0 
// 000: YCbCr  4:0:0 
// 
// Note: 
// - Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path. 
// - for RGB output format the SP input format must be YCbCr 4:2:2
#define MRV_MI_SP_OUTPUT_FORMAT
#define MRV_MI_SP_OUTPUT_FORMAT_MASK 0x70000000U
#define MRV_MI_SP_OUTPUT_FORMAT_SHIFT 28U
//! Slice: sp_input_format:
//! Selects input format of self picture. For possible restrictions see sub-chapter "Picture Orientation" in chapter "Self Path Output Programming". 
// 
// 11: YCbCr  4:4:4 
// 10: YCbCr  4:2:2 
// 01: YCbCr  4:2:0 
// 00: YCbCr  4:0:0 
// 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_SP_INPUT_FORMAT
#define MRV_MI_SP_INPUT_FORMAT_MASK 0x0C000000U
#define MRV_MI_SP_INPUT_FORMAT_SHIFT 26U
//! Slice: sp_write_format:
//! Defines how YCbCr self picture data is written to memory. 
// Must be set to 00 if RGB conversion is active. Note that with RGB conversion active the output format is always interleaved. 
// 
// 00:	planar 
// 01:	semi planar, for YCbCr 4:2:x 
// 10:	interleaved (combined), for YCbCr 4:2:2 only 
// 11:	reserved 
// 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_SP_WRITE_FORMAT
#define MRV_MI_SP_WRITE_FORMAT_MASK 0x03000000U
#define MRV_MI_SP_WRITE_FORMAT_SHIFT 24U
//! Slice: mp_write_format:
//! Defines how YCbCr main picture data is written to memory. Ignored if JPEG data is chosen. 
// In YCbCr mode the following meaning is applicable 
// 00:	planar 
// 01:	semi planar, for YCbCr 4:2:x 
// 10:	interleaved (combined), for YCbCr 4:2:2 only 
// 11:	reserved 
// In RAW data mode the following meaning is applicable 
// 00:	RAW 8 bit 
// 01:	reserved 
// 10:	RAW 12 bit 
// 11:	reserved 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the main path.
#define MRV_MI_MP_WRITE_FORMAT
#define MRV_MI_MP_WRITE_FORMAT_MASK 0x00C00000U
#define MRV_MI_MP_WRITE_FORMAT_SHIFT 22U
//! Slice: init_offset_en:
//! Enables updating of the offset counters shadow registers for main and self picture to the programmed register init values. 
// MI_MP/SP_Y/CB/CR_OFFS_CNT_INIT 
// -> MI_MP/SP_Y/CB/CR_OFFS_CNT_SHD 
// The update will be executed either when a forced software update occurs (in register MI_INIT bit cfg_upd = 1) or when an automatic config update signal arrives at the MI input port. The latter is split into main and self picture. So only the corresponding main/self shadow registers are affected. 
// After a picture skip has been performed init_offset_en selects between skip restart and skip init mode (see bit skip in register MI_INIT).
#define MRV_MI_INIT_OFFSET_EN
#define MRV_MI_INIT_OFFSET_EN_MASK 0x00200000U
#define MRV_MI_INIT_OFFSET_EN_SHIFT 21U
//! Slice: init_base_en:
//! Enables updating of the base address and buffer size shadow registers for main and self picture to the programmed register init values. 
// MI_MP/SP_Y/CB/CR_BASE_AD_INIT 
// -> MI_MP/SP_Y/CB/CR_BASE_AD_SHD 
// MI_MP/SP_Y/CB/CR_SIZE_INIT 
// -> MI_MP/SP_Y/CB/CR_SIZE_SHD 
// The update will be executed either when a forced software update occurs (in register MI_INIT bit cfg_upd = 1) or when an automatic config update signal arrives at the MI input port. The latter is split into main and self picture. So only the corresponding main/self shadow registers are affected.
#define MRV_MI_INIT_BASE_EN
#define MRV_MI_INIT_BASE_EN_MASK 0x00100000U
#define MRV_MI_INIT_BASE_EN_SHIFT 20U
//! Slice: burst_len_chrom:
//! Burst length for Cb or Cr data affecting write port. 
// 00: 4-beat bursts 
// 01: 8-beat bursts 
// 10: 16-beat bursts 
// 11: reserved 
// Ignored if 8- or 16-beat bursts are not supported. If rotation is active, then only 4-beat bursts will be generated in self path, regardless of the setting here. 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the main and self path.
#define MRV_MI_BURST_LEN_CHROM
#define MRV_MI_BURST_LEN_CHROM_MASK 0x000C0000U
#define MRV_MI_BURST_LEN_CHROM_SHIFT 18U
//! Slice: burst_len_lum:
//! Burst length for Y, JPEG, or raw data affecting write port. 
// 00: 4-beat bursts 
// 01: 8-beat bursts 
// 10: 16-beat bursts 
// 11: reserved 
// Ignored if 8- or 16-beat bursts are not supported. 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the main and self path.
#define MRV_MI_BURST_LEN_LUM
#define MRV_MI_BURST_LEN_LUM_MASK 0x00030000U
#define MRV_MI_BURST_LEN_LUM_SHIFT 16U
//! Slice: last_pixel_sig_en:
//! enables the last pixel signalization 
// 1: enabled 
// 0: disabled
#define MRV_MI_LAST_PIXEL_SIG_EN
#define MRV_MI_LAST_PIXEL_SIG_EN_MASK 0x00008000U
#define MRV_MI_LAST_PIXEL_SIG_EN_SHIFT 15U
//! Slice: sp_auto_update:
//! automatic update of configuration registers for self path at frame end. 
// 1: enabled 
// 0: disabled
#define MRV_MI_SP_AUTO_UPDATE
#define MRV_MI_SP_AUTO_UPDATE_MASK 0x00004000U
#define MRV_MI_SP_AUTO_UPDATE_SHIFT 14U
//! Slice: mp_auto_update:
//! automatic update of configuration registers for main path at frame end. 
// 1: enabled 
// 0: disabled
#define MRV_MI_MP_AUTO_UPDATE
#define MRV_MI_MP_AUTO_UPDATE_MASK 0x00002000U
#define MRV_MI_MP_AUTO_UPDATE_SHIFT 13U
//! Slice: sp_pingpong_enable:
//! pingpong  mode of configuration registers for self path at frame end. 
// 1: enabled 
// 0: disabled
#define MRV_MI_SP_PINGPONG_ENABLE
#define MRV_MI_SP_PINGPONG_ENABLE_MASK 0x00001000U
#define MRV_MI_SP_PINGPONG_ENABLE_SHIFT 12U
//! Slice: mp_pingpong_enable:
//! pingpong  mode of configuration registers for main path at frame end. 
// 1: enabled 
// 0: disabled
#define MRV_MI_MP_PINGPONG_ENABLE
#define MRV_MI_MP_PINGPONG_ENABLE_MASK 0x00000800U
#define MRV_MI_MP_PINGPONG_ENABLE_SHIFT 11U
//! Slice: 422noncosited:
//! Enables self path YCbCr422non-co-sited -> YCbCr444 interpolation 
// (M5_v6, M5_v7 only) 
// 1: YCbCr422 data are non_co-sited (Cb and Cr samples are centered between Y samples) so modified interpolation is activated 
// 0: YCbCr422 data are co-sited (Y0 Cb0 and Cr0 are sampled at the same position)
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_422NONCOSITED
#define MRV_MI_422NONCOSITED_MASK 0x00000400U
#define MRV_MI_422NONCOSITED_SHIFT 10U
//! Slice: cbcr_full_range:
//! Enables CbCr full range for self path YCbCr -> RGB conversion 
// (M5_v6, M5_v7 only) 
// 1: CbCr have full range (0..255) 
// 0: CbCr have compressed range range (16..240) 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_CBCR_FULL_RANGE
#define MRV_MI_CBCR_FULL_RANGE_MASK 0x00000200U
#define MRV_MI_CBCR_FULL_RANGE_SHIFT 9U
//! Slice: y_full_range:
//! Enables Y full range for self path YCbCr -> RGB conversion 
// (M5_v6, M5_v7 only) 
// 1: Y has full range (0..255) 
// 0: Y has compressed range (16..235) 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_Y_FULL_RANGE
#define MRV_MI_Y_FULL_RANGE_MASK 0x00000100U
#define MRV_MI_Y_FULL_RANGE_SHIFT 8U
//! Slice: byte_swap:
//! Enables change of byte order of the 32 bit output word at write port 
// 1: byte order is mirrored but the bit order within one byte doesnt change 
// 0: no byte mirroring 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the main and self path.
#define MRV_MI_BYTE_SWAP
#define MRV_MI_BYTE_SWAP_MASK 0x00000080U
#define MRV_MI_BYTE_SWAP_SHIFT 7U
//! Slice: rot:
//! Rotation 90 degree counter clockwise of self picture, only in RGB mode. For picture orientation and operation modes see sub-chapter "Picture Orientation" in chapter "Self Path Output Programming". 
// For RGB 565 format the line length must be a multiple of 2. There are no restrictions for RGB 888/666. 
// 1: enabled 
// 0: disabled 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path. In rotation mode only 4-beat bursts are supported for self-path.
#define MRV_MI_ROT
#define MRV_MI_ROT_MASK 0x00000040U
#define MRV_MI_ROT_SHIFT 6U
//! Slice: v_flip:
//! Vertical flipping of self picture. For picture orientation and operation modes see sub-chapter "Picture Orientation" in chapter "Self Path Output Programming". 
// For Y component the line length in 4:2:x planar mode must be a multiple of 8, for all other component modes a multiple of 4 and for RGB 565 a multiple of 2. There are no restrictions for RGB 888/666. 
// 1: enabled 
// 0: disabled 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_V_FLIP
#define MRV_MI_V_FLIP_MASK 0x00000020U
#define MRV_MI_V_FLIP_SHIFT 5U
//! Slice: h_flip:
//! Horizontal flipping of self picture. For picture orientation and operation modes see sub-chapter "Picture Orientation" in chapter "Self Path Output Programming". 
// For Y component the line length in 4:2:x planar mode must be a multiple of 8, for all other component modes a multiple of 4 and for RGB 565 a multiple of 2. There are no restrictions for RGB 888/666. 
// 1: enabled 
// 0: disabled 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_H_FLIP
#define MRV_MI_H_FLIP_MASK 0x00000010U
#define MRV_MI_H_FLIP_SHIFT 4U
//! Slice: path_enable:
//! Enables data pathes of MI according to the following table: 
//
// 0000: disabled, no data is transferred 
// 0001: YUV data output, mainpath only (mp_enable only) 
// 0010: self-path only, output data format depending on other settings (sp_enable only) 
// 0011: YUV data output in mainpath and self-path image data active 
// 0100: JPEG data output, mainpath only (jpeg_enable only) 
// 0101: not allowed 
// 0110: JPEG data output in mainpath and self-path image data active 
// 0111: not allowed 
// 1000: RAW data output, mainpath only (raw_enable only) 
// 1001: defect pixel data on self-path, image data on mainpath 
// 1010: defect pixel data on mainpath, image data on self-path 
// 1011: not allowed 
// 1100: defect pixel data on self-path, JPEG data on mainpath 
// 1101: defect pixel data on mainpath only 
// 1110: defect pixel data on self-path only 
// 1111: defect pixel data on self-path, RAW data on mainpath 
//
// Programmed value becomes effective (visible in shadow register) after a soft reset, a forced software update or an automatic config update.  Affects MI_IN and MI_OUT module.
#define MRV_MI_PATH_ENABLE
#define MRV_MI_PATH_ENABLE_MASK 0x0000000FU
#define MRV_MI_PATH_ENABLE_SHIFT 0U

//! Register: mi_init: Control register for address init and skip function (0x00000004)
//! Slice: mi_cfg_upd:
//! Forced configuration update. Leads to an immediate update of the shadow registers. 
// Depending on the two init enable bits in the MI_CTRL register (init_offset_en and init_base_en) the offset counter, base address and buffer size shadow registers are also updated.
#define MRV_MI_MI_CFG_UPD
#define MRV_MI_MI_CFG_UPD_MASK 0x00000010U
#define MRV_MI_MI_CFG_UPD_SHIFT 4U
//! Slice: mi_skip:
//! Skip of current or next starting main picture: 
// Aborts writing of main picture image data of the current frame to RAM (after the current burst transmission has been completed). Further main picture data up to the end of the current frame are discarded. 
// 
// No further makroblock line interrupt (mblk_line), no wrap around interrupt for main picture (wrap_mp_y/cb/cr) and no fill level interrupt (fill_mp_y) are generated. 
// 
// Skip does not affect the generation of the main path frame end interrupt (mp_frame_end). 
// Skip does not affect the processing of self picture and its corresponding interrupts namely the self path frame end interrupt (sp_frame_end). 
// 
// The byte counter (register MI_BYTE_CNT) is not affected. It produces the correct number of JPEG or RAW data bytes at the end of the current (skipped) frame. 
// 
// After a skip has been performed the offset counter for the main picture at the start of the following frame are set depending on the bit init_offset_en in register MI_CTRL: 
// 
// - Skip restart mode (init_offset_en = 0) 
// The offset counters of the main picture are restarted at the old start values of the previous skipped frame. 
// 
// - Skip init mode (init_offset_en = 1) 
// The offset counters of the main picture are initialized with the register contents of the offset counter init registers without any additional forced software update or automatic config update.
#define MRV_MI_MI_SKIP
#define MRV_MI_MI_SKIP_MASK 0x00000004U
#define MRV_MI_MI_SKIP_SHIFT 2U

//! Register: mi_mp_y_base_ad_init: Base address for main picture Y component, JPEG or raw data (0x00000008)
//! Slice: mp_y_base_ad_init:
//! Base address of main picture Y component ring buffer, JPEG ring buffer or raw data ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update.
#define MRV_MI_MP_Y_BASE_AD_INIT
#define MRV_MI_MP_Y_BASE_AD_INIT_MASK 0xFFFFFFF8U
#define MRV_MI_MP_Y_BASE_AD_INIT_SHIFT 3U

//! Register: mi_mp_y_size_init: Size of main picture Y component, JPEG or raw data (0x0000000c)
//! Slice: mp_y_size_init:
//! Size of main picture Y component ring buffer, JPEG ring buffer or raw data ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update.
#define MRV_MI_MP_Y_SIZE_INIT
#define MRV_MI_MP_Y_SIZE_INIT_MASK 0x1FFFFFF8U
#define MRV_MI_MP_Y_SIZE_INIT_SHIFT 3U

//! Register: mi_mp_y_offs_cnt_init: Offset counter init value for main picture Y, JPEG or raw data (0x00000010)
//! Slice: mp_y_offs_cnt_init:
//! Offset counter init value of main picture Y component ring buffer, JPEG ring buffer or raw data ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update.
#define MRV_MI_MP_Y_OFFS_CNT_INIT
#define MRV_MI_MP_Y_OFFS_CNT_INIT_MASK 0x1FFFFFF8U
#define MRV_MI_MP_Y_OFFS_CNT_INIT_SHIFT 3U

//! Register: mi_mp_y_offs_cnt_start: Offset counter start value for main picture Y, JPEG or raw data (0x00000014)
//! Slice: mp_y_offs_cnt_start:
//! Offset counter value which points to the start address of the previously processed picture (main picture Y component, JPEG or raw data). Updated at frame end. 
// Note: A soft reset resets the contents to the reset value.
#define MRV_MI_MP_Y_OFFS_CNT_START
#define MRV_MI_MP_Y_OFFS_CNT_START_MASK 0x1FFFFFF8U
#define MRV_MI_MP_Y_OFFS_CNT_START_SHIFT 3U

//! Register: mi_mp_y_irq_offs_init: Fill level interrupt offset value for main picture Y, JPEG or raw data (0x00000018)
//! Slice: mp_y_irq_offs_init:
//! Reaching this programmed value by the current offset counter for addressing main picture Y component, JPEG or raw data leads to generation of fill level interrupt fill_mp_y. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update.
#define MRV_MI_MP_Y_IRQ_OFFS_INIT
#define MRV_MI_MP_Y_IRQ_OFFS_INIT_MASK 0x1FFFFFF8U
#define MRV_MI_MP_Y_IRQ_OFFS_INIT_SHIFT 3U

//! Register: mi_mp_cb_base_ad_init: Base address for main picture Cb component ring buffer (0x0000001c)
//! Slice: mp_cb_base_ad_init:
//! Base address of main picture Cb component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_MP_CB_BASE_AD_INIT
#define MRV_MI_MP_CB_BASE_AD_INIT_MASK 0xFFFFFFF8U
#define MRV_MI_MP_CB_BASE_AD_INIT_SHIFT 3U

//! Register: mi_mp_cb_size_init: Size of main picture Cb component ring buffer (0x00000020)
//! Slice: mp_cb_size_init:
//! Size of main picture Cb component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_MP_CB_SIZE_INIT
#define MRV_MI_MP_CB_SIZE_INIT_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CB_SIZE_INIT_SHIFT 3U

//! Register: mi_mp_cb_offs_cnt_init: Offset counter init value for main picture Cb component ring buffer (0x00000024)
//! Slice: mp_cb_offs_cnt_init:
//! Offset counter init value of main picture Cb component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect. Check exceptional handling in skip modes.
#define MRV_MI_MP_CB_OFFS_CNT_INIT
#define MRV_MI_MP_CB_OFFS_CNT_INIT_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CB_OFFS_CNT_INIT_SHIFT 3U

//! Register: mi_mp_cb_offs_cnt_start: Offset counter start value for main picture Cb component ring buffer (0x00000028)
//! Slice: mp_cb_offs_cnt_start:
//! Offset counter value which points to the start address of the previously processed picture (main picture Cb component). Updated at frame end.
#define MRV_MI_MP_CB_OFFS_CNT_START
#define MRV_MI_MP_CB_OFFS_CNT_START_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CB_OFFS_CNT_START_SHIFT 3U

//! Register: mi_mp_cr_base_ad_init: Base address for main picture Cr component ring buffer (0x0000002c)
//! Slice: mp_cr_base_ad_init:
//! Base address of main picture Cr component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_MP_CR_BASE_AD_INIT
#define MRV_MI_MP_CR_BASE_AD_INIT_MASK 0xFFFFFFF8U
#define MRV_MI_MP_CR_BASE_AD_INIT_SHIFT 3U

//! Register: mi_mp_cr_size_init: Size of main picture Cr component ring buffer (0x00000030)
//! Slice: mp_cr_size_init:
//! Size of main picture Cr component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_MP_CR_SIZE_INIT
#define MRV_MI_MP_CR_SIZE_INIT_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CR_SIZE_INIT_SHIFT 3U

//! Register: mi_mp_cr_offs_cnt_init: Offset counter init value for main picture Cr component ring buffer (0x00000034)
//! Slice: mp_cr_offs_cnt_init:
//! Offset counter init value of main picture Cr component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect. Check exceptional handling in skip modes.
#define MRV_MI_MP_CR_OFFS_CNT_INIT
#define MRV_MI_MP_CR_OFFS_CNT_INIT_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CR_OFFS_CNT_INIT_SHIFT 3U

//! Register: mi_mp_cr_offs_cnt_start: Offset counter start value for main picture Cr component ring buffer (0x00000038)
//! Slice: mp_cr_offs_cnt_start:
//! Offset counter value which points to the start address of the previously processed picture (main picture Cr component). Updated at frame end. 
// Note: Soft reset will reset the contents to reset value.
#define MRV_MI_MP_CR_OFFS_CNT_START
#define MRV_MI_MP_CR_OFFS_CNT_START_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CR_OFFS_CNT_START_SHIFT 3U

//! Register: mi_sp_y_base_ad_init: Base address for self picture Y component ring buffer (0x0000003c)
//! Slice: sp_y_base_ad_init:
//! Base address of self picture Y component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_Y_BASE_AD_INIT
#define MRV_MI_SP_Y_BASE_AD_INIT_MASK 0xFFFFFFF8U
#define MRV_MI_SP_Y_BASE_AD_INIT_SHIFT 3U

//! Register: mi_sp_y_size_init: Size of self picture Y component ring buffer (0x00000040)
//! Slice: sp_y_size_init:
//! Size of self picture Y component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_Y_SIZE_INIT
#define MRV_MI_SP_Y_SIZE_INIT_MASK 0x1FFFFFF8U
#define MRV_MI_SP_Y_SIZE_INIT_SHIFT 3U

//! Register: mi_sp_y_offs_cnt_init: Offset counter init value for self picture Y component ring buffer (0x00000044)
//! Slice: sp_y_offs_cnt_init:
//! Offset counter init value of self picture Y component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_Y_OFFS_CNT_INIT
#define MRV_MI_SP_Y_OFFS_CNT_INIT_MASK 0x1FFFFFF8U
#define MRV_MI_SP_Y_OFFS_CNT_INIT_SHIFT 3U

//! Register: mi_sp_y_offs_cnt_start: Offset counter start value for self picture Y component ring buffer (0x00000048)
//! Slice: sp_y_offs_cnt_start:
//! Offset counter value which points to the start address of the previously processed picture (self picture Y component). Updated at frame end. 
// Note: Soft reset will reset the contents to reset value.
#define MRV_MI_SP_Y_OFFS_CNT_START
#define MRV_MI_SP_Y_OFFS_CNT_START_MASK 0x1FFFFFF8U
#define MRV_MI_SP_Y_OFFS_CNT_START_SHIFT 3U

//! Register: mi_sp_y_llength: Line length of self picture Y component (0x0000004c)
//! Slice: sp_y_llength:
//! Line length of self picture Y component or RGB picture in pixel, also known as line stride. 
// If no line stride is used, line length must match image width. 
// For Y component the line length in 4:2:x planar mode must be a multiple of 8, for all other component modes a multiple of 4 and for RGB 565 a multiple of 2. There are no restrictions for RGB 888/666. 
// In planar mode the line length of the Cb and Cr component is assumed according to the YCbCr format, i.e. half for 4:2:x and the same size for 4:4:4. In semi planar 4:2:x mode the line length of the Cb and Cr component is assumed the same size. 
// Note: Line length always refers to the line length of the output image. This is particularly important when rotating. 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_SP_Y_LLENGTH
#define MRV_MI_SP_Y_LLENGTH_MASK 0x00007FFFU
#define MRV_MI_SP_Y_LLENGTH_SHIFT 0U

//! Register: mi_sp_cb_base_ad_init: Base address for self picture Cb component ring buffer (0x00000050)
//! Slice: sp_cb_base_ad_init:
//! Base address of self picture Cb component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_CB_BASE_AD_INIT
#define MRV_MI_SP_CB_BASE_AD_INIT_MASK 0xFFFFFFF8U
#define MRV_MI_SP_CB_BASE_AD_INIT_SHIFT 3U

//! Register: mi_sp_cb_size_init: Size of self picture Cb component ring buffer (0x00000054)
//! Slice: sp_cb_size_init:
//! Size of self picture Cb component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_CB_SIZE_INIT
#define MRV_MI_SP_CB_SIZE_INIT_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CB_SIZE_INIT_SHIFT 3U

//! Register: mi_sp_cb_offs_cnt_init: Offset counter init value for self picture Cb component ring buffer (0x00000058)
//! Slice: sp_cb_offs_cnt_init:
//! Offset counter init value of self picture Cb component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_CB_OFFS_CNT_INIT
#define MRV_MI_SP_CB_OFFS_CNT_INIT_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CB_OFFS_CNT_INIT_SHIFT 3U

//! Register: mi_sp_cb_offs_cnt_start: Offset counter start value for self picture Cb component ring buffer (0x0000005c)
//! Slice: sp_cb_offs_cnt_start:
//! Offset counter value which points to the start address of the previously processed picture (self picture Cb component). Updated at frame end. 
// Note: Soft reset will reset the contents to reset value.
#define MRV_MI_SP_CB_OFFS_CNT_START
#define MRV_MI_SP_CB_OFFS_CNT_START_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CB_OFFS_CNT_START_SHIFT 3U

//! Register: mi_sp_cr_base_ad_init: Base address for self picture Cr component ring buffer (0x00000060)
//! Slice: sp_cr_base_ad_init:
//! Base address of self picture Cr component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_CR_BASE_AD_INIT
#define MRV_MI_SP_CR_BASE_AD_INIT_MASK 0xFFFFFFF8U
#define MRV_MI_SP_CR_BASE_AD_INIT_SHIFT 3U

//! Register: mi_sp_cr_size_init: Size of self picture Cr component ring buffer (0x00000064)
//! Slice: sp_cr_size_init:
//! Size of self picture Cr component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_CR_SIZE_INIT
#define MRV_MI_SP_CR_SIZE_INIT_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CR_SIZE_INIT_SHIFT 3U

//! Register: mi_sp_cr_offs_cnt_init: Offset counter init value for self picture Cr component ring buffer (0x00000068)
//! Slice: sp_cr_offs_cnt_init:
//! Offset counter init value of self picture Cr component ring buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_CR_OFFS_CNT_INIT
#define MRV_MI_SP_CR_OFFS_CNT_INIT_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CR_OFFS_CNT_INIT_SHIFT 3U

//! Register: mi_sp_cr_offs_cnt_start: Offset counter start value for self picture Cr component ring buffer (0x0000006c)
//! Slice: sp_cr_offs_cnt_start:
//! Offset counter value which points to the start address of the previously processed picture (self picture Cr component). Updated at frame end.
#define MRV_MI_SP_CR_OFFS_CNT_START
#define MRV_MI_SP_CR_OFFS_CNT_START_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CR_OFFS_CNT_START_SHIFT 3U

//! Register: mi_byte_cnt: Counter value of JPEG or RAW data bytes (0x00000070)
//! Slice: byte_cnt:
//! Counter value specifies the number of JPEG or RAW data bytes of the last transmitted frame. Updated at frame end. 
// A soft reset will set the byte counter to zero.
#define MRV_MI_BYTE_CNT
#define MRV_MI_BYTE_CNT_MASK 0x0FFFFFFFU
#define MRV_MI_BYTE_CNT_SHIFT 0U

//! Register: mi_ctrl_shd: global control internal shadow register (0x00000074)
//! Slice: path_enable_out:
//! path_enable shadow register for module MI_OUT (former raw_enable_out, jpeg_enable_out, sp_enable_out, mp_enable_out)
#define MRV_MI_PATH_ENABLE_OUT
#define MRV_MI_PATH_ENABLE_OUT_MASK 0x000F0000U
#define MRV_MI_PATH_ENABLE_OUT_SHIFT 16U
//! Slice: path_enable_in:
//! path_enable shadow register for module MI_IN (former raw_enable_in, jpeg_enable_in, sp_enable_in, mp_enable_in)
#define MRV_MI_PATH_ENABLE_IN
#define MRV_MI_PATH_ENABLE_IN_MASK 0x0000000FU
#define MRV_MI_PATH_ENABLE_IN_SHIFT 0U

//! Register: mi_mp_y_base_ad_shd: Base address shadow register for main picture Y component, JPEG or raw data ring buffer (0x00000078)
//! Slice: mp_y_base_ad:
//! Base address of main picture Y component ring buffer, JPEG ring buffer or raw data ring buffer.
#define MRV_MI_MP_Y_BASE_AD
#define MRV_MI_MP_Y_BASE_AD_MASK 0xFFFFFFF8U
#define MRV_MI_MP_Y_BASE_AD_SHIFT 3U

//! Register: mi_mp_y_size_shd: Size shadow register of main picture Y component, JPEG or raw data (0x0000007c)
//! Slice: mp_y_size:
//! Size of main picture Y component ring buffer, JPEG ring buffer or raw data ring buffer.
#define MRV_MI_MP_Y_SIZE
#define MRV_MI_MP_Y_SIZE_MASK 0x1FFFFFF8U
#define MRV_MI_MP_Y_SIZE_SHIFT 3U

//! Register: mi_mp_y_offs_cnt_shd: Current offset counter of main picture Y component, JPEG or raw data ring buffer (0x00000080)
//! Slice: mp_y_offs_cnt:
//! Current offset counter of main picture Y component, JPEG or raw data ring buffer for address generation 
// Note: Soft reset will reset the contents to reset value.
#define MRV_MI_MP_Y_OFFS_CNT
#define MRV_MI_MP_Y_OFFS_CNT_MASK 0x1FFFFFF8U
#define MRV_MI_MP_Y_OFFS_CNT_SHIFT 3U

//! Register: mi_mp_y_irq_offs_shd: Shadow register of fill level interrupt offset value for main picture Y component, JPEG or raw data (0x00000084)
//! Slice: mp_y_irq_offs:
//! Reaching this offset value by the current offset counter for addressing main picture Y component, JPEG or raw data leads to generation of fill level interrupt fill_mp_y.
#define MRV_MI_MP_Y_IRQ_OFFS
#define MRV_MI_MP_Y_IRQ_OFFS_MASK 0x1FFFFFF8U
#define MRV_MI_MP_Y_IRQ_OFFS_SHIFT 3U

//! Register: mi_mp_cb_base_ad_shd: Base address shadow register for main picture Cb component ring buffer (0x00000088)
//! Slice: mp_cb_base_ad:
//! Base address of main picture Cb component ring buffer.
#define MRV_MI_MP_CB_BASE_AD
#define MRV_MI_MP_CB_BASE_AD_MASK 0xFFFFFFF8U
#define MRV_MI_MP_CB_BASE_AD_SHIFT 3U

//! Register: mi_mp_cb_size_shd: Size shadow register of main picture Cb component ring buffer (0x0000008c)
//! Slice: mp_cb_size:
//! Size of main picture Cb component ring buffer.
#define MRV_MI_MP_CB_SIZE
#define MRV_MI_MP_CB_SIZE_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CB_SIZE_SHIFT 3U

//! Register: mi_mp_cb_offs_cnt_shd: Current offset counter of main picture Cb component ring buffer (0x00000090)
//! Slice: mp_cb_offs_cnt:
//! Current offset counter of main picture Cb component ring buffer for address generation 
// Note: Soft reset will reset the contents to reset value.
#define MRV_MI_MP_CB_OFFS_CNT
#define MRV_MI_MP_CB_OFFS_CNT_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CB_OFFS_CNT_SHIFT 3U

//! Register: mi_mp_cr_base_ad_shd: Base address shadow register for main picture Cr component ring buffer (0x00000094)
//! Slice: mp_cr_base_ad:
//! Base address of main picture Cr component ring buffer.
#define MRV_MI_MP_CR_BASE_AD
#define MRV_MI_MP_CR_BASE_AD_MASK 0xFFFFFFF8U
#define MRV_MI_MP_CR_BASE_AD_SHIFT 3U

//! Register: mi_mp_cr_size_shd: Size shadow register of main picture Cr component ring buffer (0x00000098)
//! Slice: mp_cr_size:
//! Size of main picture Cr component ring buffer.
#define MRV_MI_MP_CR_SIZE
#define MRV_MI_MP_CR_SIZE_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CR_SIZE_SHIFT 3U

//! Register: mi_mp_cr_offs_cnt_shd: Current offset counter of main picture Cr component ring buffer (0x0000009c)
//! Slice: mp_cr_offs_cnt:
//! Current offset counter of main picture Cr component ring buffer for address generation 
// Note: Soft reset will reset the contents to reset value.
#define MRV_MI_MP_CR_OFFS_CNT
#define MRV_MI_MP_CR_OFFS_CNT_MASK 0x0FFFFFF8U
#define MRV_MI_MP_CR_OFFS_CNT_SHIFT 3U

//! Register: mi_sp_y_base_ad_shd: Base address shadow register for self picture Y component ring buffer (0x000000a0)
//! Slice: sp_y_base_ad:
//! Base address of self picture Y component ring buffer.
#define MRV_MI_SP_Y_BASE_AD
#define MRV_MI_SP_Y_BASE_AD_MASK 0xFFFFFFF8U
#define MRV_MI_SP_Y_BASE_AD_SHIFT 3U

//! Register: mi_sp_y_size_shd: Size shadow register of self picture Y component ring buffer (0x000000a4)
//! Slice: sp_y_size:
//! Size of self picture Y component ring buffer.
#define MRV_MI_SP_Y_SIZE
#define MRV_MI_SP_Y_SIZE_MASK 0x1FFFFFF8U
#define MRV_MI_SP_Y_SIZE_SHIFT 3U

//! Register: mi_sp_y_offs_cnt_shd: Current offset counter of self picture Y component ring buffer (0x000000a8)
//! Slice: sp_y_offs_cnt:
//! Current offset counter of self picture Y component ring buffer for address generation 
// Note: Soft reset will reset the contents to reset value.
#define MRV_MI_SP_Y_OFFS_CNT
#define MRV_MI_SP_Y_OFFS_CNT_MASK 0x1FFFFFF8U
#define MRV_MI_SP_Y_OFFS_CNT_SHIFT 3U

//! Register: mi_sp_cb_base_ad_shd: Base address shadow register for self picture Cb component ring buffer (0x000000b0)
//! Slice: sp_cb_base_ad:
//! Base address of self picture Cb component ring buffer.
#define MRV_MI_SP_CB_BASE_AD
#define MRV_MI_SP_CB_BASE_AD_MASK 0xFFFFFFF8U
#define MRV_MI_SP_CB_BASE_AD_SHIFT 3U

//! Register: mi_sp_cb_size_shd: Size shadow register of self picture Cb component ring buffer (0x000000b4)
//! Slice: sp_cb_size:
//! Size of self picture Cb component ring buffer.
#define MRV_MI_SP_CB_SIZE
#define MRV_MI_SP_CB_SIZE_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CB_SIZE_SHIFT 3U

//! Register: mi_sp_cb_offs_cnt_shd: Current offset counter of self picture Cb component ring buffer (0x000000b8)
//! Slice: sp_cb_offs_cnt:
//! Current offset counter of self picture Cb component ring buffer for address generation 
// Note: Soft reset will reset the contents to reset value.
#define MRV_MI_SP_CB_OFFS_CNT
#define MRV_MI_SP_CB_OFFS_CNT_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CB_OFFS_CNT_SHIFT 3U

//! Register: mi_sp_cr_base_ad_shd: Base address shadow register for self picture Cr component ring buffer (0x000000bc)
//! Slice: sp_cr_base_ad:
//! Base address of self picture Cr component ring buffer.
#define MRV_MI_SP_CR_BASE_AD
#define MRV_MI_SP_CR_BASE_AD_MASK 0xFFFFFFF8U
#define MRV_MI_SP_CR_BASE_AD_SHIFT 3U

//! Register: mi_sp_cr_size_shd: Size shadow register of self picture Cr component ring buffer (0x000000c0)
//! Slice: sp_cr_size:
//! Size of self picture Cr component ring buffer.
#define MRV_MI_SP_CR_SIZE
#define MRV_MI_SP_CR_SIZE_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CR_SIZE_SHIFT 3U

//! Register: mi_sp_cr_offs_cnt_shd: Current offset counter of self picture Cr component ring buffer (0x000000c4)
//! Slice: sp_cr_offs_cnt:
//! Current offset counter of self picture Cr component ring buffer for address generation 
// Note: Soft reset will reset the contents to reset value.
#define MRV_MI_SP_CR_OFFS_CNT
#define MRV_MI_SP_CR_OFFS_CNT_MASK 0x0FFFFFF8U
#define MRV_MI_SP_CR_OFFS_CNT_SHIFT 3U

//! Register: mi_dma_y_pic_start_ad: Y component image start address (0x000000c8)
//! Slice: dma_y_pic_start_ad:
//! Image start address of the y component 
// Note: Must be multiple of 4 in interleaved mode.
#define MRV_MI_DMA_Y_PIC_START_AD
#define MRV_MI_DMA_Y_PIC_START_AD_MASK 0xFFFFFFFFU
#define MRV_MI_DMA_Y_PIC_START_AD_SHIFT 0U

//! Register: mi_dma_y_pic_width: Y component image width (0x000000cc)
//! Slice: dma_y_pic_width:
//! Image width of the Y component in pixel. 
// For YCbCr 4:2:x the image width must be a multiple of 2. 
// In planar mode the image width of the Cb and Cr component is assumed according to the YCbCr format, i.e. half for 4:2:x and the same size for 4:4:4. In semi planar 4:2:x mode the image width of the Cb component (which includes Cr) is assumed the same size. In interleave mode no Cb/Cr image width is used.
#define MRV_MI_DMA_Y_PIC_WIDTH
#define MRV_MI_DMA_Y_PIC_WIDTH_MASK 0x00007FFFU
#define MRV_MI_DMA_Y_PIC_WIDTH_SHIFT 0U

//! Register: mi_dma_y_llength: Y component original line length (0x000000d0)
//! Slice: dma_y_llength:
//! Line length of the Y component of the original image in memory  
// For an uncropped image, where lines follow each other without offset (no line stride), line length must match image width. 
// For Y component the line length in 4:2:x planar mode must be a multiple of 8, for all other component modes a multiple of 4. 
// In planar mode the line length of the Cb and Cr component is assumed according to the YCbCr format, i.e. half for 4:2:x and the same size for 4:4:4. In semi planar 4:2:x mode the line length of the Cb component (which includes Cr) is assumed the same size. In interleave mode no Cb/Cr line length is used.
#define MRV_MI_DMA_Y_LLENGTH
#define MRV_MI_DMA_Y_LLENGTH_MASK 0x00007FFFU
#define MRV_MI_DMA_Y_LLENGTH_SHIFT 0U

//! Register: mi_dma_y_pic_size: Y component image size (0x000000d4)
//! Slice: dma_y_pic_size:
//! Image size of the Y component in pixel which has to be the Y line length multiplied by the Y image height (dma_y_llength * dma_y_pic_height). 
// In planar mode the image size of the Cb and Cr component is assumed according to the YCbCr format, i.e. a quarter for 4:2:0, half for 4:2:2 and the same for 4:4:4. In semi planar mode the image size of the Cb component (which includes Cr) is assumed half for 4:2:0 and the same size for 4:2:2. In interleave mode no Cb/Cr image size is used.
#define MRV_MI_DMA_Y_PIC_SIZE
#define MRV_MI_DMA_Y_PIC_SIZE_MASK 0x0FFFFFFFU
#define MRV_MI_DMA_Y_PIC_SIZE_SHIFT 0U

//! Register: mi_dma_cb_pic_start_ad: Cb component image start address (0x000000d8)
//! Slice: dma_cb_pic_start_ad:
//! Image start address of the Cb component 
// Note: Must be multiple of 2 in semi-planar mode.
#define MRV_MI_DMA_CB_PIC_START_AD
#define MRV_MI_DMA_CB_PIC_START_AD_MASK 0xFFFFFFFFU
#define MRV_MI_DMA_CB_PIC_START_AD_SHIFT 0U

//! Register: mi_dma_cr_pic_start_ad: Cr component image start address (0x000000e8)
//! Slice: dma_cr_pic_start_ad:
//! Image start address of the Cr component
#define MRV_MI_DMA_CR_PIC_START_AD
#define MRV_MI_DMA_CR_PIC_START_AD_MASK 0xFFFFFFFFU
#define MRV_MI_DMA_CR_PIC_START_AD_SHIFT 0U

//! Register: mi_imsc: Interrupt Mask (1: interrupt active, 0: interrupt masked) (0x000000f8)
//! Slice: dma_ready:
//! Mask bit for dma ready interrupt
#define MRV_MI_DMA_READY
#define MRV_MI_DMA_READY_MASK 0x00000800U
#define MRV_MI_DMA_READY_SHIFT 11U
//! Slice: wrap_sp_cr:
//! Mask bit for self picture Cr address wrap interrupt
#define MRV_MI_WRAP_SP_CR
#define MRV_MI_WRAP_SP_CR_MASK 0x00000200U
#define MRV_MI_WRAP_SP_CR_SHIFT 9U
//! Slice: wrap_sp_cb:
//! Mask bit for self picture Cb address wrap interrupt
#define MRV_MI_WRAP_SP_CB
#define MRV_MI_WRAP_SP_CB_MASK 0x00000100U
#define MRV_MI_WRAP_SP_CB_SHIFT 8U
//! Slice: wrap_sp_y:
//! Mask bit for self picture Y address wrap interrupt
#define MRV_MI_WRAP_SP_Y
#define MRV_MI_WRAP_SP_Y_MASK 0x00000080U
#define MRV_MI_WRAP_SP_Y_SHIFT 7U
//! Slice: wrap_mp_cr:
//! Mask bit for main picture Cr address wrap interrupt
#define MRV_MI_WRAP_MP_CR
#define MRV_MI_WRAP_MP_CR_MASK 0x00000040U
#define MRV_MI_WRAP_MP_CR_SHIFT 6U
//! Slice: wrap_mp_cb:
//! Mask bit for main picture Cb address wrap interrupt
#define MRV_MI_WRAP_MP_CB
#define MRV_MI_WRAP_MP_CB_MASK 0x00000020U
#define MRV_MI_WRAP_MP_CB_SHIFT 5U
//! Slice: wrap_mp_y:
//! Mask bit for main picture Y address wrap interrupt
#define MRV_MI_WRAP_MP_Y
#define MRV_MI_WRAP_MP_Y_MASK 0x00000010U
#define MRV_MI_WRAP_MP_Y_SHIFT 4U
//! Slice: fill_mp_y:
//! Mask bit for fill level interrupt of main picture Y, JPEG or raw data
#define MRV_MI_FILL_MP_Y
#define MRV_MI_FILL_MP_Y_MASK 0x00000008U
#define MRV_MI_FILL_MP_Y_SHIFT 3U
//! Slice: mblk_line:
//! Mask bit for makroblock line interrupt of main picture (16 lines of Y, 8 lines of Cb and 8 lines of Cr are written into RAM)
#define MRV_MI_MBLK_LINE
#define MRV_MI_MBLK_LINE_MASK 0x00000004U
#define MRV_MI_MBLK_LINE_SHIFT 2U
//! Slice: sp_frame_end:
//! Mask self picture end of frame interrupt
#define MRV_MI_SP_FRAME_END
#define MRV_MI_SP_FRAME_END_MASK 0x00000002U
#define MRV_MI_SP_FRAME_END_SHIFT 1U
//! Slice: mp_frame_end:
//! Mask main picture end of frame interrupt
#define MRV_MI_MP_FRAME_END
#define MRV_MI_MP_FRAME_END_MASK 0x00000001U
#define MRV_MI_MP_FRAME_END_SHIFT 0U

//! Register: mi_ris: Raw Interrupt Status (0x000000fc)
//! Slice: dma_ready:
//! Raw status of dma ready interrupt
#define MRV_MI_DMA_READY
#define MRV_MI_DMA_READY_MASK 0x00000800U
#define MRV_MI_DMA_READY_SHIFT 11U
//! Slice: wrap_sp_cr:
//! Raw status of self picture Cr address wrap interrupt
#define MRV_MI_WRAP_SP_CR
#define MRV_MI_WRAP_SP_CR_MASK 0x00000200U
#define MRV_MI_WRAP_SP_CR_SHIFT 9U
//! Slice: wrap_sp_cb:
//! Raw status of self picture Cb address wrap interrupt
#define MRV_MI_WRAP_SP_CB
#define MRV_MI_WRAP_SP_CB_MASK 0x00000100U
#define MRV_MI_WRAP_SP_CB_SHIFT 8U
//! Slice: wrap_sp_y:
//! Raw status of self picture Y address wrap interrupt
#define MRV_MI_WRAP_SP_Y
#define MRV_MI_WRAP_SP_Y_MASK 0x00000080U
#define MRV_MI_WRAP_SP_Y_SHIFT 7U
//! Slice: wrap_mp_cr:
//! Raw status of main picture Cr address wrap interrupt
#define MRV_MI_WRAP_MP_CR
#define MRV_MI_WRAP_MP_CR_MASK 0x00000040U
#define MRV_MI_WRAP_MP_CR_SHIFT 6U
//! Slice: wrap_mp_cb:
//! Raw status of main picture Cb address wrap interrupt
#define MRV_MI_WRAP_MP_CB
#define MRV_MI_WRAP_MP_CB_MASK 0x00000020U
#define MRV_MI_WRAP_MP_CB_SHIFT 5U
//! Slice: wrap_mp_y:
//! Raw status of main picture Y address wrap interrupt
#define MRV_MI_WRAP_MP_Y
#define MRV_MI_WRAP_MP_Y_MASK 0x00000010U
#define MRV_MI_WRAP_MP_Y_SHIFT 4U
//! Slice: fill_mp_y:
//! Raw status of fill level interrupt of main picture Y, JPEG or raw data
#define MRV_MI_FILL_MP_Y
#define MRV_MI_FILL_MP_Y_MASK 0x00000008U
#define MRV_MI_FILL_MP_Y_SHIFT 3U
//! Slice: mblk_line:
//! Raw status of makroblock line interrupt of main picture (16 lines of Y, 8 lines of Cb and 8 lines of Cr are written into RAM, valid only for planar and semi-planar mode)
#define MRV_MI_MBLK_LINE
#define MRV_MI_MBLK_LINE_MASK 0x00000004U
#define MRV_MI_MBLK_LINE_SHIFT 2U
//! Slice: sp_frame_end:
//! Raw status of self picture end of frame interrupt
#define MRV_MI_SP_FRAME_END
#define MRV_MI_SP_FRAME_END_MASK 0x00000002U
#define MRV_MI_SP_FRAME_END_SHIFT 1U
//! Slice: mp_frame_end:
//! Raw status of main picture end of frame interrupt
#define MRV_MI_MP_FRAME_END
#define MRV_MI_MP_FRAME_END_MASK 0x00000001U
#define MRV_MI_MP_FRAME_END_SHIFT 0U

//! Register: mi_mis: Masked Interrupt Status (0x00000100)
//! Slice: dma_ready:
//! Masked status of dma ready interrupt
#define MRV_MI_DMA_READY
#define MRV_MI_DMA_READY_MASK 0x00000800U
#define MRV_MI_DMA_READY_SHIFT 11U
//! Slice: wrap_sp_cr:
//! Masked status of self picture Cr address wrap interrupt
#define MRV_MI_WRAP_SP_CR
#define MRV_MI_WRAP_SP_CR_MASK 0x00000200U
#define MRV_MI_WRAP_SP_CR_SHIFT 9U
//! Slice: wrap_sp_cb:
//! Masked status of self picture Cb address wrap interrupt
#define MRV_MI_WRAP_SP_CB
#define MRV_MI_WRAP_SP_CB_MASK 0x00000100U
#define MRV_MI_WRAP_SP_CB_SHIFT 8U
//! Slice: wrap_sp_y:
//! Masked status of self picture Y address wrap interrupt
#define MRV_MI_WRAP_SP_Y
#define MRV_MI_WRAP_SP_Y_MASK 0x00000080U
#define MRV_MI_WRAP_SP_Y_SHIFT 7U
//! Slice: wrap_mp_cr:
//! Masked status of main picture Cr address wrap interrupt
#define MRV_MI_WRAP_MP_CR
#define MRV_MI_WRAP_MP_CR_MASK 0x00000040U
#define MRV_MI_WRAP_MP_CR_SHIFT 6U
//! Slice: wrap_mp_cb:
//! Masked status of main picture Cb address wrap interrupt
#define MRV_MI_WRAP_MP_CB
#define MRV_MI_WRAP_MP_CB_MASK 0x00000020U
#define MRV_MI_WRAP_MP_CB_SHIFT 5U
//! Slice: wrap_mp_y:
//! Masked status of main picture Y address wrap interrupt
#define MRV_MI_WRAP_MP_Y
#define MRV_MI_WRAP_MP_Y_MASK 0x00000010U
#define MRV_MI_WRAP_MP_Y_SHIFT 4U
//! Slice: fill_mp_y:
//! Masked status of fill level interrupt of main picture Y, JPEG or raw data
#define MRV_MI_FILL_MP_Y
#define MRV_MI_FILL_MP_Y_MASK 0x00000008U
#define MRV_MI_FILL_MP_Y_SHIFT 3U
//! Slice: mblk_line:
//! Masked status of makroblock line interrupt of main picture (16 lines of Y, 8 lines of Cb and 8 lines of Cr are written into RAM, valid only for planar and semi-planar mode)
#define MRV_MI_MBLK_LINE
#define MRV_MI_MBLK_LINE_MASK 0x00000004U
#define MRV_MI_MBLK_LINE_SHIFT 2U
//! Slice: sp_frame_end:
//! Masked status of self picture end of frame interrupt
#define MRV_MI_SP_FRAME_END
#define MRV_MI_SP_FRAME_END_MASK 0x00000002U
#define MRV_MI_SP_FRAME_END_SHIFT 1U
//! Slice: mp_frame_end:
//! Masked status of main picture end of frame interrupt
#define MRV_MI_MP_FRAME_END
#define MRV_MI_MP_FRAME_END_MASK 0x00000001U
#define MRV_MI_MP_FRAME_END_SHIFT 0U

//! Register: mi_icr: Interrupt Clear Register (0x00000104)
//! Slice: dma_ready:
//! Clear dma ready interrupt
#define MRV_MI_DMA_READY
#define MRV_MI_DMA_READY_MASK 0x00000800U
#define MRV_MI_DMA_READY_SHIFT 11U
//! Slice: wrap_sp_cr:
//! Clear self picture Cr address wrap interrupt
#define MRV_MI_WRAP_SP_CR
#define MRV_MI_WRAP_SP_CR_MASK 0x00000200U
#define MRV_MI_WRAP_SP_CR_SHIFT 9U
//! Slice: wrap_sp_cb:
//! Clear self picture Cb address wrap interrupt
#define MRV_MI_WRAP_SP_CB
#define MRV_MI_WRAP_SP_CB_MASK 0x00000100U
#define MRV_MI_WRAP_SP_CB_SHIFT 8U
//! Slice: wrap_sp_y:
//! Clear self picture Y address wrap interrupt
#define MRV_MI_WRAP_SP_Y
#define MRV_MI_WRAP_SP_Y_MASK 0x00000080U
#define MRV_MI_WRAP_SP_Y_SHIFT 7U
//! Slice: wrap_mp_cr:
//! Clear main picture Cr address wrap interrupt
#define MRV_MI_WRAP_MP_CR
#define MRV_MI_WRAP_MP_CR_MASK 0x00000040U
#define MRV_MI_WRAP_MP_CR_SHIFT 6U
//! Slice: wrap_mp_cb:
//! Clear main picture Cb address wrap interrupt
#define MRV_MI_WRAP_MP_CB
#define MRV_MI_WRAP_MP_CB_MASK 0x00000020U
#define MRV_MI_WRAP_MP_CB_SHIFT 5U
//! Slice: wrap_mp_y:
//! Clear main picture Y address wrap interrupt
#define MRV_MI_WRAP_MP_Y
#define MRV_MI_WRAP_MP_Y_MASK 0x00000010U
#define MRV_MI_WRAP_MP_Y_SHIFT 4U
//! Slice: fill_mp_y:
//! Clear fill level interrupt
#define MRV_MI_FILL_MP_Y
#define MRV_MI_FILL_MP_Y_MASK 0x00000008U
#define MRV_MI_FILL_MP_Y_SHIFT 3U
//! Slice: mblk_line:
//! Clear makroblock line interrupt
#define MRV_MI_MBLK_LINE
#define MRV_MI_MBLK_LINE_MASK 0x00000004U
#define MRV_MI_MBLK_LINE_SHIFT 2U
//! Slice: sp_frame_end:
//! Clear self picture end of frame interrupt
#define MRV_MI_SP_FRAME_END
#define MRV_MI_SP_FRAME_END_MASK 0x00000002U
#define MRV_MI_SP_FRAME_END_SHIFT 1U
//! Slice: mp_frame_end:
//! Clear main picture end of frame interrupt
#define MRV_MI_MP_FRAME_END
#define MRV_MI_MP_FRAME_END_MASK 0x00000001U
#define MRV_MI_MP_FRAME_END_SHIFT 0U

//! Register: mi_isr: Interrupt Set Register (0x00000108)
//! Slice: dma_ready:
//! Set dma ready interrupt
#define MRV_MI_DMA_READY
#define MRV_MI_DMA_READY_MASK 0x00000800U
#define MRV_MI_DMA_READY_SHIFT 11U
//! Slice: wrap_sp_cr:
//! Set self picture Cr address wrap interrupt
#define MRV_MI_WRAP_SP_CR
#define MRV_MI_WRAP_SP_CR_MASK 0x00000200U
#define MRV_MI_WRAP_SP_CR_SHIFT 9U
//! Slice: wrap_sp_cb:
//! Set self picture Cb address wrap interrupt
#define MRV_MI_WRAP_SP_CB
#define MRV_MI_WRAP_SP_CB_MASK 0x00000100U
#define MRV_MI_WRAP_SP_CB_SHIFT 8U
//! Slice: wrap_sp_y:
//! Set self picture Y address wrap interrupt
#define MRV_MI_WRAP_SP_Y
#define MRV_MI_WRAP_SP_Y_MASK 0x00000080U
#define MRV_MI_WRAP_SP_Y_SHIFT 7U
//! Slice: wrap_mp_cr:
//! Set main picture Cr address wrap interrupt
#define MRV_MI_WRAP_MP_CR
#define MRV_MI_WRAP_MP_CR_MASK 0x00000040U
#define MRV_MI_WRAP_MP_CR_SHIFT 6U
//! Slice: wrap_mp_cb:
//! Set main picture Cb address wrap interrupt
#define MRV_MI_WRAP_MP_CB
#define MRV_MI_WRAP_MP_CB_MASK 0x00000020U
#define MRV_MI_WRAP_MP_CB_SHIFT 5U
//! Slice: wrap_mp_y:
//! Set main picture Y address wrap interrupt
#define MRV_MI_WRAP_MP_Y
#define MRV_MI_WRAP_MP_Y_MASK 0x00000010U
#define MRV_MI_WRAP_MP_Y_SHIFT 4U
//! Slice: fill_mp_y:
//! Set fill level interrupt
#define MRV_MI_FILL_MP_Y
#define MRV_MI_FILL_MP_Y_MASK 0x00000008U
#define MRV_MI_FILL_MP_Y_SHIFT 3U
//! Slice: mblk_line:
//! Set makroblock line interrupt
#define MRV_MI_MBLK_LINE
#define MRV_MI_MBLK_LINE_MASK 0x00000004U
#define MRV_MI_MBLK_LINE_SHIFT 2U
//! Slice: sp_frame_end:
//! Set self picture end of frame interrupt
#define MRV_MI_SP_FRAME_END
#define MRV_MI_SP_FRAME_END_MASK 0x00000002U
#define MRV_MI_SP_FRAME_END_SHIFT 1U
//! Slice: mp_frame_end:
//! Set main picture end of frame interrupt
#define MRV_MI_MP_FRAME_END
#define MRV_MI_MP_FRAME_END_MASK 0x00000001U
#define MRV_MI_MP_FRAME_END_SHIFT 0U

//! Register: mi_status: MI Status Register (0x0000010c)
//! Slice: sp_cr_fifo_full:
//! FIFO full flag of Cr FIFO in self path asserted since last clear
#define MRV_MI_SP_CR_FIFO_FULL
#define MRV_MI_SP_CR_FIFO_FULL_MASK 0x00000040U
#define MRV_MI_SP_CR_FIFO_FULL_SHIFT 6U
//! Slice: sp_cb_fifo_full:
//! FIFO full flag of Cb FIFO in self path asserted since last clear
#define MRV_MI_SP_CB_FIFO_FULL
#define MRV_MI_SP_CB_FIFO_FULL_MASK 0x00000020U
#define MRV_MI_SP_CB_FIFO_FULL_SHIFT 5U
//! Slice: sp_y_fifo_full:
//! FIFO full flag of Y FIFO in self path asserted since last clear
#define MRV_MI_SP_Y_FIFO_FULL
#define MRV_MI_SP_Y_FIFO_FULL_MASK 0x00000010U
#define MRV_MI_SP_Y_FIFO_FULL_SHIFT 4U
//! Slice: mp_cr_fifo_full:
//! FIFO full flag of Cr FIFO in main path asserted since last clear
#define MRV_MI_MP_CR_FIFO_FULL
#define MRV_MI_MP_CR_FIFO_FULL_MASK 0x00000004U
#define MRV_MI_MP_CR_FIFO_FULL_SHIFT 2U
//! Slice: mp_cb_fifo_full:
//! FIFO full flag of Cb FIFO in main path asserted since last clear
#define MRV_MI_MP_CB_FIFO_FULL
#define MRV_MI_MP_CB_FIFO_FULL_MASK 0x00000002U
#define MRV_MI_MP_CB_FIFO_FULL_SHIFT 1U
//! Slice: mp_y_fifo_full:
//! FIFO full flag of Y FIFO in main path asserted since last clear
#define MRV_MI_MP_Y_FIFO_FULL
#define MRV_MI_MP_Y_FIFO_FULL_MASK 0x00000001U
#define MRV_MI_MP_Y_FIFO_FULL_SHIFT 0U

//! Register: mi_status_clr: MI Status Clear Register (0x00000110)
//! Slice: sp_cr_fifo_full:
//! Clear status of Cr FIFO full flag in self path
#define MRV_MI_SP_CR_FIFO_FULL
#define MRV_MI_SP_CR_FIFO_FULL_MASK 0x00000040U
#define MRV_MI_SP_CR_FIFO_FULL_SHIFT 6U
//! Slice: sp_cb_fifo_full:
//! Clear status of Cb FIFO full flag in self path
#define MRV_MI_SP_CB_FIFO_FULL
#define MRV_MI_SP_CB_FIFO_FULL_MASK 0x00000020U
#define MRV_MI_SP_CB_FIFO_FULL_SHIFT 5U
//! Slice: sp_y_fifo_full:
//! Clear status of Y FIFO full flag in self path
#define MRV_MI_SP_Y_FIFO_FULL
#define MRV_MI_SP_Y_FIFO_FULL_MASK 0x00000010U
#define MRV_MI_SP_Y_FIFO_FULL_SHIFT 4U
//! Slice: mp_cr_fifo_full:
//! Clear status of Cr FIFO full flag in main path
#define MRV_MI_MP_CR_FIFO_FULL
#define MRV_MI_MP_CR_FIFO_FULL_MASK 0x00000004U
#define MRV_MI_MP_CR_FIFO_FULL_SHIFT 2U
//! Slice: mp_cb_fifo_full:
//! Clear status of Cb FIFO full flag in main path
#define MRV_MI_MP_CB_FIFO_FULL
#define MRV_MI_MP_CB_FIFO_FULL_MASK 0x00000002U
#define MRV_MI_MP_CB_FIFO_FULL_SHIFT 1U
//! Slice: mp_y_fifo_full:
//! Clear status of Y FIFO full flag in main path
#define MRV_MI_MP_Y_FIFO_FULL
#define MRV_MI_MP_Y_FIFO_FULL_MASK 0x00000001U
#define MRV_MI_MP_Y_FIFO_FULL_SHIFT 0U

//! Register: mi_sp_y_pic_width: Y component image width (0x00000114)
//! Slice: sp_y_pic_width:
//! Image width of the self picture Y component or RGB picture in pixel. 
// For YCbCr 4:2:x and RGB 565 the image width must be a multiple of 2. If no line stride is used but flipping required, the image width must be a multiple of 8 for 4:2:x planar or 4 for 4:4:4 planar/4:2:x semi planar. There are no restrictions for RGB 888/666. 
// In planar mode the image width of the Cb and Cr component is assumed according to the YCbCr format, i.e. half for 4:2:x and the same size for 4:4:4. In semi planar 4:2:x mode the image width of the Cb component (which includes Cr) is assumed the same size. In interleave mode no Cb/Cr image width is used. 
// Note: Image width always refers to the picture width of the output image. This is particularly important when rotating. 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_SP_Y_PIC_WIDTH
#define MRV_MI_SP_Y_PIC_WIDTH_MASK 0x00007FFFU
#define MRV_MI_SP_Y_PIC_WIDTH_SHIFT 0U

//! Register: mi_sp_y_pic_height: Y component image height (0x00000118)
//! Slice: sp_y_pic_height:
//! Image height of the y component or RGB picture in pixel. 
// In planar and semi planar mode the image width of the cb and cr component is assumed according to the YCbCr format, i.e. half for 4:2:0 and the same for 4:2:2 and 4:4:4. 
// Note: Image height always refers to the picture height of the output image. This is particularly important when rotating. 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_SP_Y_PIC_HEIGHT
#define MRV_MI_SP_Y_PIC_HEIGHT_MASK 0x00007FFFU
#define MRV_MI_SP_Y_PIC_HEIGHT_SHIFT 0U

//! Register: mi_sp_y_pic_size: Y component image size (0x0000011c)
//! Slice: sp_y_pic_size:
//! Image size of the Y component or RGB picture in pixel which has to be the Y line length multiplied by the Y image height (sp_y_llength * sp_y_pic_height). 
// In planar mode the image size of the Cb and Cr component is assumed according to the YCbCr format, i.e. a quarter for 4:2:0, half for 4:2:2 and the same for 4:4:4. In semi planar mode the image size of the Cb and Cr component is assumed half for 4:2:0 and the same size for 4:2:2. 
// Note: Programmed value becomes effective immediately. So write to the register only if no picture data is sent to the self path.
#define MRV_MI_SP_Y_PIC_SIZE
#define MRV_MI_SP_Y_PIC_SIZE_MASK 0x01FFFFFFU
#define MRV_MI_SP_Y_PIC_SIZE_SHIFT 0U

//! Register: mi_dma_ctrl: DMA control register (0x00000120)
//! Slice: dma_rgb_format:
//! Selects RGB Bayer data of read DMA picture 
// 00: no DMA RGB Bayer data 
// 01: 8 bit RGB Bayer data 
// 10: 16 bit RGB Bayer data (12 bit used) 
// bytes are organized MSB first and 4 lower bits of LSB remain unused: 
// byte_even -> bayer[11:4], byte_odd[7:4] -> bayer[3:0] 
// 11: reserved.
#define MRV_MI_DMA_RGB_FORMAT
#define MRV_MI_DMA_RGB_FORMAT_MASK 0x00003000U
#define MRV_MI_DMA_RGB_FORMAT_SHIFT 12U
//! Slice: dma_frame_end_disable:
//! Suppresses v_end so that no frame end can be detected by following instances. Note: The dma_ready interrupt is raised as usual, but the dma_frame_end interrupt will not be generated until v_end has been enabled again.
#define MRV_MI_DMA_FRAME_END_DISABLE
#define MRV_MI_DMA_FRAME_END_DISABLE_MASK 0x00000400U
#define MRV_MI_DMA_FRAME_END_DISABLE_SHIFT 10U
//! Slice: dma_continuous_en:
//! Enables continuous mode. If set the same frame is read back over and over. A start pulse on dma_start is needed only for the first time. To stop continuous mode reset this bit (takes effect after the next frame end) or execute a soft reset. This bit is intended to be used in conjunction with the Superimpose feature.
#define MRV_MI_DMA_CONTINUOUS_EN
#define MRV_MI_DMA_CONTINUOUS_EN_MASK 0x00000200U
#define MRV_MI_DMA_CONTINUOUS_EN_SHIFT 9U
//! Slice: dma_byte_swap:
//! Enables change of DMA byte order of the 32 bit input word at read port 
// 1: byte order is mirrored but the bit order within one byte doesnt change 
// 0: no byte mirroring
#define MRV_MI_DMA_BYTE_SWAP
#define MRV_MI_DMA_BYTE_SWAP_MASK 0x00000100U
#define MRV_MI_DMA_BYTE_SWAP_SHIFT 8U
//! Slice: dma_inout_format:
//! Selects input/output format of DMA picture. 
// 11: YCbCr  4:4:4 
// 10: YCbCr  4:2:2 
// 01: YCbCr  4:2:0 
// 00: YCbCr  4:0:0
#define MRV_MI_DMA_INOUT_FORMAT
#define MRV_MI_DMA_INOUT_FORMAT_MASK 0x000000C0U
#define MRV_MI_DMA_INOUT_FORMAT_SHIFT 6U
//! Slice: dma_read_format:
//! Defines how YCbCr picture data is read from memory. 
// 00: planar 
// 01: semi planar, for YCbCr 4:2:x 
// 10: interleaved (combined), for YCbCr 4:2:2 and RGB only 
// 11: reserved
#define MRV_MI_DMA_READ_FORMAT
#define MRV_MI_DMA_READ_FORMAT_MASK 0x00000030U
#define MRV_MI_DMA_READ_FORMAT_SHIFT 4U
//! Slice: dma_burst_len_chrom:
//! Burst length for Cb or Cr data affecting DMA read port. 
// 00: 4-beat bursts 
// 01: 8-beat bursts 
// 10: 16-beat bursts 
// 11: reserved 
// Ignored if 8- or 16-beat bursts are not supported.
#define MRV_MI_DMA_BURST_LEN_CHROM
#define MRV_MI_DMA_BURST_LEN_CHROM_MASK 0x0000000CU
#define MRV_MI_DMA_BURST_LEN_CHROM_SHIFT 2U
//! Slice: dma_burst_len_lum:
//! Burst length for Y data affecting DMA read port. 
// 00: 4-beat bursts 
// 01: 8-beat bursts 
// 10: 16-beat bursts 
// 11: reserved 
// Ignored if 8- or 16-beat bursts are not supported.
#define MRV_MI_DMA_BURST_LEN_LUM
#define MRV_MI_DMA_BURST_LEN_LUM_MASK 0x00000003U
#define MRV_MI_DMA_BURST_LEN_LUM_SHIFT 0U

//! Register: mi_dma_start: DMA start register (0x00000124)
//! Slice: dma_start:
//! Enables DMA access. Additionally main or self path has to be enabled separately.
#define MRV_MI_DMA_START
#define MRV_MI_DMA_START_MASK 0x00000001U
#define MRV_MI_DMA_START_SHIFT 0U

//! Register: mi_dma_status: DMA status register (0x00000128)
//! Slice: dma_active:
//! If set DMA access is active.
#define MRV_MI_DMA_ACTIVE
#define MRV_MI_DMA_ACTIVE_MASK 0x00000001U
#define MRV_MI_DMA_ACTIVE_SHIFT 0U

//! Register: mi_pixel_cnt: Counter value for defect pixel list (0x0000012c)
//! Slice: pix_cnt:
//! Counter value specifies the number of pixels of the defect pixel list generated by DPCC of the last transmitted frame. Updated at frame end. 
// A soft reset will set the counter to zero.
#define MRV_MI_PIX_CNT
#define MRV_MI_PIX_CNT_MASK 0x0FFFFFFFU
#define MRV_MI_PIX_CNT_SHIFT 0U

//! Register: mi_mp_y_base_ad_init2: Base address 2 (ping pong) for main picture Y component, JPEG or raw data (0x00000130)
//! Slice: mp_y_base_ad_init2:
//! 2nd ping pong base address of main picture Y component buffer, JPEG buffer or raw data buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_MP_Y_BASE_AD_INIT2
#define MRV_MI_MP_Y_BASE_AD_INIT2_MASK 0xFFFFFFF8U
#define MRV_MI_MP_Y_BASE_AD_INIT2_SHIFT 3U

//! Register: mi_mp_cb_base_ad_init2: Base address 2 (pingpong) for main picture Cb component (0x00000134)
//! Slice: mp_cb_base_ad_init2:
//! 2nd ping pong base address of main picture Cb component buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_MP_CB_BASE_AD_INIT2
#define MRV_MI_MP_CB_BASE_AD_INIT2_MASK 0xFFFFFFF8U
#define MRV_MI_MP_CB_BASE_AD_INIT2_SHIFT 3U

//! Register: mi_mp_cr_base_ad_init2: Base address 2 (pingpong) for main picture Cr component ring buffer (0x00000138)
//! Slice: mp_cr_base_ad_init2:
//! 2nd ping pong Base address of main picture Cr component buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_MP_CR_BASE_AD_INIT2
#define MRV_MI_MP_CR_BASE_AD_INIT2_MASK 0xFFFFFFF8U
#define MRV_MI_MP_CR_BASE_AD_INIT2_SHIFT 3U

//! Register: mi_sp_y_base_ad_init2: Base address 2 (ping pong) for main picture Y component, JPEG or raw data (0x0000013c)
//! Slice: sp_y_base_ad_init2:
//! 2nd ping pong base address of main picture Y component buffer, JPEG buffer or raw data buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_Y_BASE_AD_INIT2
#define MRV_MI_SP_Y_BASE_AD_INIT2_MASK 0xFFFFFFF8U
#define MRV_MI_SP_Y_BASE_AD_INIT2_SHIFT 3U

//! Register: mi_sp_cb_base_ad_init2: Base address 2 (pingpong) for main picture Cb component (0x00000140)
//! Slice: sp_cb_base_ad_init2:
//! 2nd ping pong base address of main picture Cb component buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_CB_BASE_AD_INIT2
#define MRV_MI_SP_CB_BASE_AD_INIT2_MASK 0xFFFFFFF8U
#define MRV_MI_SP_CB_BASE_AD_INIT2_SHIFT 3U

//! Register: mi_sp_cr_base_ad_init2: Base address 2 (pingpong) for main picture Cr component ring buffer (0x00000144)
//! Slice: sp_cr_base_ad_init2:
//! 2nd ping pong Base address of main picture Cr component buffer. 
// Programmed value becomes effective (visible in corresponding shadow register) after a soft reset, a forced software update or an automatic config update. 
// Note: Set control bit init_base_en before updating so that a forced or automatic update can take effect.
#define MRV_MI_SP_CR_BASE_AD_INIT2
#define MRV_MI_SP_CR_BASE_AD_INIT2_MASK 0xFFFFFFF8U
#define MRV_MI_SP_CR_BASE_AD_INIT2_SHIFT 3U

//! Register: mi_xtd_format_ctrl: Extended Storage Format Control for main, self and dma read path (0x00000148)
//! Slice: nv21_dma_read:
//! 0: dma read path: use NV12 storage format for semi-planar YCbCr 4:2:x mode, Cb is located on even addresses. 
//1: dma read path: use NV21 storage format for semi-planar YCbCr 4:2:x mode, Cr is located on even addresses.
#define MRV_MI_NV21_DMA_READ
#define MRV_MI_NV21_DMA_READ_MASK 0x00000004U
#define MRV_MI_NV21_DMA_READ_SHIFT 2U
//! Slice: nv21_self:
//! 0: self path: use NV12 storage format for semi-planar YCbCr 4:2:x mode, Cb is located on even addresses. 
//1: self path: use NV21 storage format for semi-planar YCbCr 4:2:x mode, Cr is located on even addresses.
#define MRV_MI_NV21_SELF
#define MRV_MI_NV21_SELF_MASK 0x00000002U
#define MRV_MI_NV21_SELF_SHIFT 1U
//! Slice: nv21_main:
//! 0: main path: use NV12 storage format for semi-planar YCbCr 4:2:x mode, Cb is located on even addresses. 
//1: main path: use NV21 storage format for semi-planar YCbCr 4:2:x mode, Cr is located on even addresses.
#define MRV_MI_NV21_MAIN
#define MRV_MI_NV21_MAIN_MASK 0x00000001U
#define MRV_MI_NV21_MAIN_SHIFT 0U

//! Register: jpe_gen_header: command to start stream header generation (0x00000000)
//! Slice: gen_header:
//! "1" = Start command to generate stream header; 
// auto reset to zero after one clock cycle
#define MRV_JPE_GEN_HEADER
#define MRV_JPE_GEN_HEADER_MASK 0x00000001U
#define MRV_JPE_GEN_HEADER_SHIFT 0U

//! Register: jpe_encode: Start command to start JFIF stream encoding (0x00000004)
//! Slice: encode:
//! "1" = Start command to start JFIF stream encoding; 
// auto reset to zero after one clock cycle. 
// This bit is write-only: reading result is always zero!
#define MRV_JPE_ENCODE
#define MRV_JPE_ENCODE_MASK 0x00000001U
#define MRV_JPE_ENCODE_SHIFT 0U

//! Register: jpe_init: Automatic configuration update (INIT) (0x00000008)
//! Slice: JP_INIT:
//! "1" = Immediate start of JPEG encoder.  
// This bit has to be set after "Encode" to start the JPEG encoder. The "Encode" command becomes active either with JP_INIT or with the input signal "CFG_UPD". 
// auto reset to zero after one clock cycle !!!
#define MRV_JPE_JP_INIT
#define MRV_JPE_JP_INIT_MASK 0x00000001U
#define MRV_JPE_JP_INIT_SHIFT 0U

//! Register: jpe_y_scale_en: Y value scaling control register (0x0000000c)
//! Slice: y_scale_en:
//! Y scale flag 
// 1: scaling Y input from [16..235] to [0..255] 
// 0: no Y input scaling
#define MRV_JPE_Y_SCALE_EN
#define MRV_JPE_Y_SCALE_EN_MASK 0x00000001U
#define MRV_JPE_Y_SCALE_EN_SHIFT 0U

//! Register: jpe_cbcr_scale_en: Cb/Cr value scaling control register (0x00000010)
//! Slice: cbcr_scale_en:
//! Cb/Cr scale flag 
// 1: scaling Cb/Cr input from [16..240] to [0..255] 
// 0: no Cb/Cr input scaling
#define MRV_JPE_CBCR_SCALE_EN
#define MRV_JPE_CBCR_SCALE_EN_MASK 0x00000001U
#define MRV_JPE_CBCR_SCALE_EN_SHIFT 0U

//! Register: jpe_table_flush: header generation debug register (0x00000014)
//! Slice: table_flush:
//! header generation debug control flag 
// (controls transmission of last header bytes if the 64 bit output buffer is not completely filled) 
// 1: immediately transmit last header bytes  
// 0: wait for encoded image data to fill output buffer
#define MRV_JPE_TABLE_FLUSH
#define MRV_JPE_TABLE_FLUSH_MASK 0x00000001U
#define MRV_JPE_TABLE_FLUSH_SHIFT 0U

//! Register: jpe_enc_hsize: JPEG codec horizontal image size for encoding (0x00000018)
//! Slice: enc_hsize:
//! JPEG codec horizontal image size for R2B and SGEN blocks. 
// Note: If the active camerIC version does not support 64 megapixel only those bits will be used which are required and the respective most significant bits will be ignored. Example: 5MP camerIC uses only bits [12:0] and ignores bits [14:13].
#define MRV_JPE_ENC_HSIZE
#define MRV_JPE_ENC_HSIZE_MASK 0x00007FFFU
#define MRV_JPE_ENC_HSIZE_SHIFT 0U

//! Register: jpe_enc_vsize: JPEG codec vertical image size for encoding (0x0000001c)
//! Slice: enc_vsize:
//! JPEG codec vertical image size for R2B and SGEN blocks
#define MRV_JPE_ENC_VSIZE
#define MRV_JPE_ENC_VSIZE_MASK 0x00003FFFU
#define MRV_JPE_ENC_VSIZE_SHIFT 0U

//! Register: jpe_pic_format: JPEG picture encoding format (0x00000020)
//! Slice: enc_pic_format:
//! "0:0:1"  = 4:2:2 format 
// "1:x:x"  = 4:0:0 format
#define MRV_JPE_ENC_PIC_FORMAT
#define MRV_JPE_ENC_PIC_FORMAT_MASK 0x00000007U
#define MRV_JPE_ENC_PIC_FORMAT_SHIFT 0U

//! Register: jpe_restart_interval: restart marker insertion register (0x00000024)
//! Slice: restart_interval:
//! No of MCU in  reset interval via host
#define MRV_JPE_RESTART_INTERVAL
#define MRV_JPE_RESTART_INTERVAL_MASK 0x0000FFFFU
#define MRV_JPE_RESTART_INTERVAL_SHIFT 0U

//! Register: jpe_tq_y_select: Q- table selector 0, quant. table for Y component (0x00000028)
//! Slice: tq0_select:
//! "00" = qtable 0 
// "01" = qtable 1 
// "10" = qtable 2 
// "11" = qtable 3
#define MRV_JPE_TQ0_SELECT
#define MRV_JPE_TQ0_SELECT_MASK 0x00000003U
#define MRV_JPE_TQ0_SELECT_SHIFT 0U

//! Register: jpe_tq_u_select: Q- table selector 1, quant. table for U component (0x0000002c)
//! Slice: tq1_select:
//! "00" = qtable 0 
// "01" = qtable 1 
// "10" = qtable 2 
// "11" = qtable 3
#define MRV_JPE_TQ1_SELECT
#define MRV_JPE_TQ1_SELECT_MASK 0x00000003U
#define MRV_JPE_TQ1_SELECT_SHIFT 0U

//! Register: jpe_tq_v_select: Q- table selector 2, quant. table for V component (0x00000030)
//! Slice: tq2_select:
//! "00" = qtable 0 
// "01" = qtable 1 
// "10" = qtable 2 
// "11" = qtable 3
#define MRV_JPE_TQ2_SELECT
#define MRV_JPE_TQ2_SELECT_MASK 0x00000003U
#define MRV_JPE_TQ2_SELECT_SHIFT 0U

//! Register: jpe_dc_table_select: Huffman table selector for DC values (0x00000034)
//! Slice: dc_table_select_v:
//! "0" = dc table 0; color component 2 (V) 
// "1" = dc table 1; color component 2 (V)
#define MRV_JPE_DC_TABLE_SELECT_V
#define MRV_JPE_DC_TABLE_SELECT_V_MASK 0x00000004U
#define MRV_JPE_DC_TABLE_SELECT_V_SHIFT 2U
//! Slice: dc_table_select_u:
//! "0" = dc table 0; color component 1 (U) 
// "1" = dc table 1; color component 1 (U)
#define MRV_JPE_DC_TABLE_SELECT_U
#define MRV_JPE_DC_TABLE_SELECT_U_MASK 0x00000002U
#define MRV_JPE_DC_TABLE_SELECT_U_SHIFT 1U
//! Slice: dc_table_select_y:
//! "0" = dc table 0; color component 0 (Y) 
// "1" = dc table 1; color component 0 (Y)
#define MRV_JPE_DC_TABLE_SELECT_Y
#define MRV_JPE_DC_TABLE_SELECT_Y_MASK 0x00000001U
#define MRV_JPE_DC_TABLE_SELECT_Y_SHIFT 0U

//! Register: jpe_ac_table_select: Huffman table selector for AC values (0x00000038)
//! Slice: ac_table_select_v:
//! "0" = ac table 0; component 2 (V) 
// "1" = ac table 1; component 2 (V)
#define MRV_JPE_AC_TABLE_SELECT_V
#define MRV_JPE_AC_TABLE_SELECT_V_MASK 0x00000004U
#define MRV_JPE_AC_TABLE_SELECT_V_SHIFT 2U
//! Slice: ac_table_select_u:
//! "0" = ac table 0; component 1 (U) 
// "1" = ac table 1; component 1 (U)
#define MRV_JPE_AC_TABLE_SELECT_U
#define MRV_JPE_AC_TABLE_SELECT_U_MASK 0x00000002U
#define MRV_JPE_AC_TABLE_SELECT_U_SHIFT 1U
//! Slice: ac_table_select_y:
//! "0" = ac table 0; component 0 (Y) 
// "1" = ac table 1; component 0 (Y)
#define MRV_JPE_AC_TABLE_SELECT_Y
#define MRV_JPE_AC_TABLE_SELECT_Y_MASK 0x00000001U
#define MRV_JPE_AC_TABLE_SELECT_Y_SHIFT 0U

//! Register: jpe_table_data: table programming register (0x0000003c)
//! Slice: table_wdata_h:
//! Table data MSB
#define MRV_JPE_TABLE_WDATA_H
#define MRV_JPE_TABLE_WDATA_H_MASK 0x0000FF00U
#define MRV_JPE_TABLE_WDATA_H_SHIFT 8U
//! Slice: table_wdata_l:
//! Table data LSB
#define MRV_JPE_TABLE_WDATA_L
#define MRV_JPE_TABLE_WDATA_L_MASK 0x000000FFU
#define MRV_JPE_TABLE_WDATA_L_SHIFT 0U

//! Register: jpe_table_id: table programming select register (0x00000040)
//! Slice: table_id:
//! select table 
// "0000" : Q-table 0 
// "0001" : Q-table 1 
// "0010" : Q-table 2 
// "0011" : Q-table 3 
// "0100" : VLC DC-table 0 
// "0101" : VLC AC-table 0 
// "0110" : VLC DC-table 1 
// "0111" : VLC AC-table 1 
// "1xxx" : reserved for debug
#define MRV_JPE_TABLE_ID
#define MRV_JPE_TABLE_ID_MASK 0x0000000FU
#define MRV_JPE_TABLE_ID_SHIFT 0U

//! Register: jpe_tac0_len: Huffman AC table 0 length (0x00000044)
//! Slice: tac0_len:
//! Huffman table length for ac0 table
#define MRV_JPE_TAC0_LEN
#define MRV_JPE_TAC0_LEN_MASK 0x000000FFU
#define MRV_JPE_TAC0_LEN_SHIFT 0U

//! Register: jpe_tdc0_len: Huffman DC table 0 length (0x00000048)
//! Slice: tdc0_len:
//! Huffman table length for dc0 table
#define MRV_JPE_TDC0_LEN
#define MRV_JPE_TDC0_LEN_MASK 0x000000FFU
#define MRV_JPE_TDC0_LEN_SHIFT 0U

//! Register: jpe_tac1_len: Huffman AC table 1 length (0x0000004c)
//! Slice: tac1_len:
//! Huffman table length for ac1 table
#define MRV_JPE_TAC1_LEN
#define MRV_JPE_TAC1_LEN_MASK 0x000000FFU
#define MRV_JPE_TAC1_LEN_SHIFT 0U

//! Register: jpe_tdc1_len: Huffman DC table 1 length (0x00000050)
//! Slice: tdc1_len:
//! Huffman table length for dc1 table
#define MRV_JPE_TDC1_LEN
#define MRV_JPE_TDC1_LEN_MASK 0x000000FFU
#define MRV_JPE_TDC1_LEN_SHIFT 0U

//! Register: jpe_encoder_busy: encoder status flag (0x00000058)
//! Slice: codec_busy:
//! Bit 0 = "1" : JPEG codec in process
#define MRV_JPE_CODEC_BUSY
#define MRV_JPE_CODEC_BUSY_MASK 0x00000001U
#define MRV_JPE_CODEC_BUSY_SHIFT 0U

//! Register: jpe_header_mode: header mode definition (0x0000005c)
//! Slice: header_mode:
//! "00" = no header 
// "01" = reserved 
// "10" = JFIF 1.02 header 
// "11" = reserved
#define MRV_JPE_HEADER_MODE
#define MRV_JPE_HEADER_MODE_MASK 0x00000003U
#define MRV_JPE_HEADER_MODE_SHIFT 0U

//! Register: jpe_encode_mode: encode mode (0x00000060)
//! Slice: encode_mode:
//! Always  "1", because this is the encoder only edition
#define MRV_JPE_ENCODE_MODE
#define MRV_JPE_ENCODE_MODE_MASK 0x00000001U
#define MRV_JPE_ENCODE_MODE_SHIFT 0U

//! Register: jpe_debug: debug information register (0x00000064)
//! Slice: deb_bad_table_access:
//! Debug signal only (set if an access to the TABLE_DATA or to the TABLE_ID register is performed, when the JPEG_ENCODER is busy. In this case a default PVCI Acknowledge is generated. Thus the configuration bus is not blocked)
#define MRV_JPE_DEB_BAD_TABLE_ACCESS
#define MRV_JPE_DEB_BAD_TABLE_ACCESS_MASK 0x00000100U
#define MRV_JPE_DEB_BAD_TABLE_ACCESS_SHIFT 8U
//! Slice: deb_vlc_table_busy:
//! Debug signal only (vlc access to huff-tables)
#define MRV_JPE_DEB_VLC_TABLE_BUSY
#define MRV_JPE_DEB_VLC_TABLE_BUSY_MASK 0x00000020U
#define MRV_JPE_DEB_VLC_TABLE_BUSY_SHIFT 5U
//! Slice: deb_r2b_memory_full:
//! Debug signal only (line memory status of r2b)
#define MRV_JPE_DEB_R2B_MEMORY_FULL
#define MRV_JPE_DEB_R2B_MEMORY_FULL_MASK 0x00000010U
#define MRV_JPE_DEB_R2B_MEMORY_FULL_SHIFT 4U
//! Slice: deb_vlc_encode_busy:
//! Debug signal only (vlc encode processing active)
#define MRV_JPE_DEB_VLC_ENCODE_BUSY
#define MRV_JPE_DEB_VLC_ENCODE_BUSY_MASK 0x00000008U
#define MRV_JPE_DEB_VLC_ENCODE_BUSY_SHIFT 3U
//! Slice: deb_qiq_table_acc:
//! Debug signal only (QIQ table access)
#define MRV_JPE_DEB_QIQ_TABLE_ACC
#define MRV_JPE_DEB_QIQ_TABLE_ACC_MASK 0x00000004U
#define MRV_JPE_DEB_QIQ_TABLE_ACC_SHIFT 2U

//! Register: jpe_error_imr: JPEG error interrupt mask register (0x00000068)
//! Slice: vlc_table_err:
//! "1" = interrupt is  activated (masked in)
#define MRV_JPE_VLC_TABLE_ERR
#define MRV_JPE_VLC_TABLE_ERR_MASK 0x00000400U
#define MRV_JPE_VLC_TABLE_ERR_SHIFT 10U
//! Slice: r2b_IMG_size_err:
//! "1" = interrupt is  activated (masked in)
#define MRV_JPE_R2B_IMG_SIZE_ERR
#define MRV_JPE_R2B_IMG_SIZE_ERR_MASK 0x00000200U
#define MRV_JPE_R2B_IMG_SIZE_ERR_SHIFT 9U
//! Slice: DCT_ERR:
//! "1" = interrupt is  activated (masked in)
#define MRV_JPE_DCT_ERR
#define MRV_JPE_DCT_ERR_MASK 0x00000080U
#define MRV_JPE_DCT_ERR_SHIFT 7U
//! Slice: vlc_symbol_err:
//! "1" = interrupt is  activated (masked in)
#define MRV_JPE_VLC_SYMBOL_ERR
#define MRV_JPE_VLC_SYMBOL_ERR_MASK 0x00000010U
#define MRV_JPE_VLC_SYMBOL_ERR_SHIFT 4U

//! Register: jpe_error_ris: JPEG error raw  interrupt status register (0x0000006c)
//! Slice: vlc_table_err:
//! "1" = illegal table detected
#define MRV_JPE_VLC_TABLE_ERR
#define MRV_JPE_VLC_TABLE_ERR_MASK 0x00000400U
#define MRV_JPE_VLC_TABLE_ERR_SHIFT 10U
//! Slice: r2b_IMG_size_err:
//! "1" = mismatch of predefined h_size and v_size values with calculated values (encode mode)
#define MRV_JPE_R2B_IMG_SIZE_ERR
#define MRV_JPE_R2B_IMG_SIZE_ERR_MASK 0x00000200U
#define MRV_JPE_R2B_IMG_SIZE_ERR_SHIFT 9U
//! Slice: DCT_ERR:
//! "1" =  block start mismatch
#define MRV_JPE_DCT_ERR
#define MRV_JPE_DCT_ERR_MASK 0x00000080U
#define MRV_JPE_DCT_ERR_SHIFT 7U
//! Slice: vlc_symbol_err:
//! "1" = illegal symbol detected (encoding)
#define MRV_JPE_VLC_SYMBOL_ERR
#define MRV_JPE_VLC_SYMBOL_ERR_MASK 0x00000010U
#define MRV_JPE_VLC_SYMBOL_ERR_SHIFT 4U

//! Register: jpe_error_mis: JPEG error masked interrupt status register (0x00000070)
//! Slice: vlc_table_err:
//! "1" = illegal table detected
#define MRV_JPE_VLC_TABLE_ERR
#define MRV_JPE_VLC_TABLE_ERR_MASK 0x00000400U
#define MRV_JPE_VLC_TABLE_ERR_SHIFT 10U
//! Slice: r2b_IMG_size_err:
//! "1" = mismatch of predefined h_size and v_size values with calculated values (encode mode)
#define MRV_JPE_R2B_IMG_SIZE_ERR
#define MRV_JPE_R2B_IMG_SIZE_ERR_MASK 0x00000200U
#define MRV_JPE_R2B_IMG_SIZE_ERR_SHIFT 9U
//! Slice: DCT_ERR:
//! "1" =  block start mismatch
#define MRV_JPE_DCT_ERR
#define MRV_JPE_DCT_ERR_MASK 0x00000080U
#define MRV_JPE_DCT_ERR_SHIFT 7U
//! Slice: vlc_symbol_err:
//! "1" = illegal symbol detected (encoding)
#define MRV_JPE_VLC_SYMBOL_ERR
#define MRV_JPE_VLC_SYMBOL_ERR_MASK 0x00000010U
#define MRV_JPE_VLC_SYMBOL_ERR_SHIFT 4U

//! Register: jpe_error_icr: JPEG error interrupt set register (0x00000074)
//! Slice: vlc_table_err:
//! "1" = set error bit, bit is reset to zero after 1 clk
#define MRV_JPE_VLC_TABLE_ERR
#define MRV_JPE_VLC_TABLE_ERR_MASK 0x00000400U
#define MRV_JPE_VLC_TABLE_ERR_SHIFT 10U
//! Slice: r2b_IMG_size_err:
//! "1" = set error bit, bit is reset to zero after 1 clk
#define MRV_JPE_R2B_IMG_SIZE_ERR
#define MRV_JPE_R2B_IMG_SIZE_ERR_MASK 0x00000200U
#define MRV_JPE_R2B_IMG_SIZE_ERR_SHIFT 9U
//! Slice: DCT_ERR:
//! "1" = set error bit, bit is reset to zero after 1 clk
#define MRV_JPE_DCT_ERR
#define MRV_JPE_DCT_ERR_MASK 0x00000080U
#define MRV_JPE_DCT_ERR_SHIFT 7U
//! Slice: vlc_symbol_err:
//! "1" = set error bit, bit is reset to zero after 1 clk
#define MRV_JPE_VLC_SYMBOL_ERR
#define MRV_JPE_VLC_SYMBOL_ERR_MASK 0x00000010U
#define MRV_JPE_VLC_SYMBOL_ERR_SHIFT 4U

//! Register: jpe_error_isr: JPEG error interrupt clear register (0x00000078)
//! Slice: vlc_table_err:
//! "1" = clear status bit, bit is reset to zero after 1 clk
#define MRV_JPE_VLC_TABLE_ERR
#define MRV_JPE_VLC_TABLE_ERR_MASK 0x00000400U
#define MRV_JPE_VLC_TABLE_ERR_SHIFT 10U
//! Slice: r2b_IMG_size_err:
//! "1" = clear status bit, bit is reset to zero after 1 clk
#define MRV_JPE_R2B_IMG_SIZE_ERR
#define MRV_JPE_R2B_IMG_SIZE_ERR_MASK 0x00000200U
#define MRV_JPE_R2B_IMG_SIZE_ERR_SHIFT 9U
//! Slice: dct_err:
//! "1" = clear status bit, bit is reset to zero after 1 clk
#define MRV_JPE_DCT_ERR
#define MRV_JPE_DCT_ERR_MASK 0x00000080U
#define MRV_JPE_DCT_ERR_SHIFT 7U
//! Slice: vlc_symbol_err:
//! "1" = clear status bit, bit is reset to zero after 1 clk
#define MRV_JPE_VLC_SYMBOL_ERR
#define MRV_JPE_VLC_SYMBOL_ERR_MASK 0x00000010U
#define MRV_JPE_VLC_SYMBOL_ERR_SHIFT 4U

//! Register: jpe_status_imr: JPEG status interrupt mask register (0x0000007c)
//! Slice: gen_header_done:
//! "1" = interrupt is activated (masked in)
#define MRV_JPE_GEN_HEADER_DONE
#define MRV_JPE_GEN_HEADER_DONE_MASK 0x00000020U
#define MRV_JPE_GEN_HEADER_DONE_SHIFT 5U
//! Slice: encode_done:
//! "1" = interrupt is activated (masked in)
#define MRV_JPE_ENCODE_DONE
#define MRV_JPE_ENCODE_DONE_MASK 0x00000010U
#define MRV_JPE_ENCODE_DONE_SHIFT 4U

//! Register: jpe_status_ris: JPEG status raw interrupt status register (0x00000080)
//! Slice: gen_header_done:
//! "1" = Stream header generation finished
#define MRV_JPE_GEN_HEADER_DONE
#define MRV_JPE_GEN_HEADER_DONE_MASK 0x00000020U
#define MRV_JPE_GEN_HEADER_DONE_SHIFT 5U
//! Slice: encode_done:
//! "1" = Encode processing finished
#define MRV_JPE_ENCODE_DONE
#define MRV_JPE_ENCODE_DONE_MASK 0x00000010U
#define MRV_JPE_ENCODE_DONE_SHIFT 4U

//! Register: jpe_status_mis: JPEG status masked interrupt status register (0x00000084)
//! Slice: gen_header_done:
//! "1" = Stream header generation finished
#define MRV_JPE_GEN_HEADER_DONE
#define MRV_JPE_GEN_HEADER_DONE_MASK 0x00000020U
#define MRV_JPE_GEN_HEADER_DONE_SHIFT 5U
//! Slice: encode_done:
//! "1" = Encode processing finished
#define MRV_JPE_ENCODE_DONE
#define MRV_JPE_ENCODE_DONE_MASK 0x00000010U
#define MRV_JPE_ENCODE_DONE_SHIFT 4U

//! Register: jpe_status_icr: JPEG status interrupt clear register (0x00000088)
//! Slice: gen_header_done:
//! "1" = clear status bit, bit is reset to zero after 1 clk
#define MRV_JPE_GEN_HEADER_DONE
#define MRV_JPE_GEN_HEADER_DONE_MASK 0x00000020U
#define MRV_JPE_GEN_HEADER_DONE_SHIFT 5U
//! Slice: encode_done:
//! "1" = clear status bit, bit is reset to zero after 1 clk
#define MRV_JPE_ENCODE_DONE
#define MRV_JPE_ENCODE_DONE_MASK 0x00000010U
#define MRV_JPE_ENCODE_DONE_SHIFT 4U

//! Register: jpe_status_isr: JPEG status interrupt set register (0x0000008c)
//! Slice: gen_header_done:
//! "1" = set error bit, bit is reset to zero after 1 clk
#define MRV_JPE_GEN_HEADER_DONE
#define MRV_JPE_GEN_HEADER_DONE_MASK 0x00000020U
#define MRV_JPE_GEN_HEADER_DONE_SHIFT 5U
//! Slice: encode_done:
//! "1" = set error bit, bit is reset to zero after 1 clk
#define MRV_JPE_ENCODE_DONE
#define MRV_JPE_ENCODE_DONE_MASK 0x00000010U
#define MRV_JPE_ENCODE_DONE_SHIFT 4U

//! Register: jpe_config: JPEG configuration register (0x00000090)
//! Slice: speedview_en:
//! 1: speed view enabled 
// 0: speed view disabled
#define MRV_JPE_SPEEDVIEW_EN
#define MRV_JPE_SPEEDVIEW_EN_MASK 0x00000010U
#define MRV_JPE_SPEEDVIEW_EN_SHIFT 4U
//! Slice: cont_mode:
//! Encoder continous mode 
// "00": encoder stops at frame end (corresponds to former behavior) 
// "01": encoder starts automatically to encode the next frame 
// "10": unused 
// "11": encoder first generates next header and then encodes automatically the next frame 
// These settings are checked after encoding one frame. They are not auto-reset by hardware.
#define MRV_JPE_CONT_MODE
#define MRV_JPE_CONT_MODE_MASK 0x00000003U
#define MRV_JPE_CONT_MODE_SHIFT 0U

//! Register: smia_ctrl: global control register (0x00000000)
//! Slice: DMA_CHANNEL_SEL:
//! DMA channel selector for image data output
#define MRV_SMIA_DMA_CHANNEL_SEL
#define MRV_SMIA_DMA_CHANNEL_SEL_MASK 0x00000700U
#define MRV_SMIA_DMA_CHANNEL_SEL_SHIFT 8U
//! Slice: SHUTDOWN_LANE:
//! Shutdown Lane Module. Content of this register is directly connected to the output signal shutdown
#define MRV_SMIA_SHUTDOWN_LANE
#define MRV_SMIA_SHUTDOWN_LANE_MASK 0x00000008U
#define MRV_SMIA_SHUTDOWN_LANE_SHIFT 3U
//! Slice: CFG_UPD_ENA:
//! enables generation of cfg_upd signal at frame end
#define MRV_SMIA_CFG_UPD_ENA
#define MRV_SMIA_CFG_UPD_ENA_MASK 0x00000004U
#define MRV_SMIA_CFG_UPD_ENA_SHIFT 2U
//! Slice: FLUSH_FIFO:
//! writing '1' resets the write- and read pointers of the embedded data fifo.
#define MRV_SMIA_FLUSH_FIFO
#define MRV_SMIA_FLUSH_FIFO_MASK 0x00000002U
#define MRV_SMIA_FLUSH_FIFO_SHIFT 1U
//! Slice: OUTPUT_ENA:
//! '1': transmission to alomics output interface is enabled 
// '0': transmission is disabled
#define MRV_SMIA_OUTPUT_ENA
#define MRV_SMIA_OUTPUT_ENA_MASK 0x00000001U
#define MRV_SMIA_OUTPUT_ENA_SHIFT 0U

//! Register: smia_status: global status register (0x00000004)
//! Slice: DMA_CHANNEL:
//! DMA channel of currently received packet
#define MRV_SMIA_DMA_CHANNEL
#define MRV_SMIA_DMA_CHANNEL_MASK 0x00000700U
#define MRV_SMIA_DMA_CHANNEL_SHIFT 8U
//! Slice: EMB_DATA_AVAIL:
//! 1: embedded data fifo not empty
#define MRV_SMIA_EMB_DATA_AVAIL
#define MRV_SMIA_EMB_DATA_AVAIL_MASK 0x00000001U
#define MRV_SMIA_EMB_DATA_AVAIL_SHIFT 0U

//! Register: smia_imsc: Interrupt mask (0x00000008)
//! Slice: IMSC_FIFO_FILL_LEVEL:
//! enable interrupt (1) or mask out (0)
#define MRV_SMIA_IMSC_FIFO_FILL_LEVEL
#define MRV_SMIA_IMSC_FIFO_FILL_LEVEL_MASK 0x00000020U
#define MRV_SMIA_IMSC_FIFO_FILL_LEVEL_SHIFT 5U
//! Slice: IMSC_SYNC_FIFO_OVFLW:
//! enable interrupt (1) or mask out (0)
#define MRV_SMIA_IMSC_SYNC_FIFO_OVFLW
#define MRV_SMIA_IMSC_SYNC_FIFO_OVFLW_MASK 0x00000010U
#define MRV_SMIA_IMSC_SYNC_FIFO_OVFLW_SHIFT 4U
//! Slice: IMSC_ERR_CS:
//! enable interrupt (1) or mask out (0)
#define MRV_SMIA_IMSC_ERR_CS
#define MRV_SMIA_IMSC_ERR_CS_MASK 0x00000008U
#define MRV_SMIA_IMSC_ERR_CS_SHIFT 3U
//! Slice: IMSC_ERR_PROTOCOL:
//! enable interrupt (1) or mask out (0)
#define MRV_SMIA_IMSC_ERR_PROTOCOL
#define MRV_SMIA_IMSC_ERR_PROTOCOL_MASK 0x00000004U
#define MRV_SMIA_IMSC_ERR_PROTOCOL_SHIFT 2U
//! Slice: IMSC_EMB_DATA_OVFLW:
//! enable interrupt (1) or mask out (0)
#define MRV_SMIA_IMSC_EMB_DATA_OVFLW
#define MRV_SMIA_IMSC_EMB_DATA_OVFLW_MASK 0x00000002U
#define MRV_SMIA_IMSC_EMB_DATA_OVFLW_SHIFT 1U
//! Slice: IMSC_FRAME_END:
//! enable interrupt (1) or mask out (0)
#define MRV_SMIA_IMSC_FRAME_END
#define MRV_SMIA_IMSC_FRAME_END_MASK 0x00000001U
#define MRV_SMIA_IMSC_FRAME_END_SHIFT 0U

//! Register: smia_ris: Raw interrupt status (0x0000000c)
//! Slice: RIS_FIFO_FILL_LEVEL:
//! Programmed fill level was reached; will be raised as long as the fill level is greater the programmed value
#define MRV_SMIA_RIS_FIFO_FILL_LEVEL
#define MRV_SMIA_RIS_FIFO_FILL_LEVEL_MASK 0x00000020U
#define MRV_SMIA_RIS_FIFO_FILL_LEVEL_SHIFT 5U
//! Slice: RIS_SYNC_FIFO_OVFLW:
//! Sync fifo overflow error
#define MRV_SMIA_RIS_SYNC_FIFO_OVFLW
#define MRV_SMIA_RIS_SYNC_FIFO_OVFLW_MASK 0x00000010U
#define MRV_SMIA_RIS_SYNC_FIFO_OVFLW_SHIFT 4U
//! Slice: RIS_ERR_CS:
//! Checksum error
#define MRV_SMIA_RIS_ERR_CS
#define MRV_SMIA_RIS_ERR_CS_MASK 0x00000008U
#define MRV_SMIA_RIS_ERR_CS_SHIFT 3U
//! Slice: RIS_ERR_PROTOCOL:
//! Protocol error
#define MRV_SMIA_RIS_ERR_PROTOCOL
#define MRV_SMIA_RIS_ERR_PROTOCOL_MASK 0x00000004U
#define MRV_SMIA_RIS_ERR_PROTOCOL_SHIFT 2U
//! Slice: RIS_EMB_DATA_OVFLW:
//! Embedded data fifo overflow error
#define MRV_SMIA_RIS_EMB_DATA_OVFLW
#define MRV_SMIA_RIS_EMB_DATA_OVFLW_MASK 0x00000002U
#define MRV_SMIA_RIS_EMB_DATA_OVFLW_SHIFT 1U
//! Slice: RIS_FRAME_END:
//! Frame end reached
#define MRV_SMIA_RIS_FRAME_END
#define MRV_SMIA_RIS_FRAME_END_MASK 0x00000001U
#define MRV_SMIA_RIS_FRAME_END_SHIFT 0U

//! Register: smia_mis: Masked interrupt status (0x00000010)
//! Slice: MIS_FIFO_FILL_LEVEL:
//! Programmed fill level was reached; will be raised as long as the fill level is greater the programmed value
#define MRV_SMIA_MIS_FIFO_FILL_LEVEL
#define MRV_SMIA_MIS_FIFO_FILL_LEVEL_MASK 0x00000020U
#define MRV_SMIA_MIS_FIFO_FILL_LEVEL_SHIFT 5U
//! Slice: MIS_SYNC_FIFO_OVFLW:
//! Sync fifo overflow error
#define MRV_SMIA_MIS_SYNC_FIFO_OVFLW
#define MRV_SMIA_MIS_SYNC_FIFO_OVFLW_MASK 0x00000010U
#define MRV_SMIA_MIS_SYNC_FIFO_OVFLW_SHIFT 4U
//! Slice: MIS_ERR_CS:
//! Checksum error
#define MRV_SMIA_MIS_ERR_CS
#define MRV_SMIA_MIS_ERR_CS_MASK 0x00000008U
#define MRV_SMIA_MIS_ERR_CS_SHIFT 3U
//! Slice: MIS_ERR_PROTOCOL:
//! Protocol error
#define MRV_SMIA_MIS_ERR_PROTOCOL
#define MRV_SMIA_MIS_ERR_PROTOCOL_MASK 0x00000004U
#define MRV_SMIA_MIS_ERR_PROTOCOL_SHIFT 2U
//! Slice: MIS_EMB_DATA_OVFLW:
//! Embedded data fifo overflow error
#define MRV_SMIA_MIS_EMB_DATA_OVFLW
#define MRV_SMIA_MIS_EMB_DATA_OVFLW_MASK 0x00000002U
#define MRV_SMIA_MIS_EMB_DATA_OVFLW_SHIFT 1U
//! Slice: MIS_FRAME_END:
//! Frame end reached
#define MRV_SMIA_MIS_FRAME_END
#define MRV_SMIA_MIS_FRAME_END_MASK 0x00000001U
#define MRV_SMIA_MIS_FRAME_END_SHIFT 0U

//! Register: smia_icr: Interrupt clear register (0x00000014)
//! Slice: ICR_FIFO_FILL_LEVEL:
//! Write '1': clear interrupt; Write '0': no effect
#define MRV_SMIA_ICR_FIFO_FILL_LEVEL
#define MRV_SMIA_ICR_FIFO_FILL_LEVEL_MASK 0x00000020U
#define MRV_SMIA_ICR_FIFO_FILL_LEVEL_SHIFT 5U
//! Slice: ICR_SYNC_FIFO_OVFLW:
//! Write '1': clear interrupt; Write '0': no effect
#define MRV_SMIA_ICR_SYNC_FIFO_OVFLW
#define MRV_SMIA_ICR_SYNC_FIFO_OVFLW_MASK 0x00000010U
#define MRV_SMIA_ICR_SYNC_FIFO_OVFLW_SHIFT 4U
//! Slice: ICR_ERR_CS:
//! Write '1': clear interrupt; Write '0': no effect
#define MRV_SMIA_ICR_ERR_CS
#define MRV_SMIA_ICR_ERR_CS_MASK 0x00000008U
#define MRV_SMIA_ICR_ERR_CS_SHIFT 3U
//! Slice: ICR_ERR_PROTOCOL:
//! Write '1': clear interrupt; Write '0': no effect
#define MRV_SMIA_ICR_ERR_PROTOCOL
#define MRV_SMIA_ICR_ERR_PROTOCOL_MASK 0x00000004U
#define MRV_SMIA_ICR_ERR_PROTOCOL_SHIFT 2U
//! Slice: ICR_EMB_DATA_OVFLW:
//! Write '1': clear interrupt; Write '0': no effect
#define MRV_SMIA_ICR_EMB_DATA_OVFLW
#define MRV_SMIA_ICR_EMB_DATA_OVFLW_MASK 0x00000002U
#define MRV_SMIA_ICR_EMB_DATA_OVFLW_SHIFT 1U
//! Slice: ICR_FRAME_END:
//! Write '1': clear interrupt; Write '0': no effect
#define MRV_SMIA_ICR_FRAME_END
#define MRV_SMIA_ICR_FRAME_END_MASK 0x00000001U
#define MRV_SMIA_ICR_FRAME_END_SHIFT 0U

//! Register: smia_isr: Interrupt set register (0x00000018)
//! Slice: ISR_FIFO_FILL_LEVEL:
//! Write '1': set interrupt; Write '0': no effect
#define MRV_SMIA_ISR_FIFO_FILL_LEVEL
#define MRV_SMIA_ISR_FIFO_FILL_LEVEL_MASK 0x00000020U
#define MRV_SMIA_ISR_FIFO_FILL_LEVEL_SHIFT 5U
//! Slice: ISR_SYNC_FIFO_OVFLW:
//! Write '1': set interrupt; Write '0': no effect
#define MRV_SMIA_ISR_SYNC_FIFO_OVFLW
#define MRV_SMIA_ISR_SYNC_FIFO_OVFLW_MASK 0x00000010U
#define MRV_SMIA_ISR_SYNC_FIFO_OVFLW_SHIFT 4U
//! Slice: ISR_ERR_CS:
//! Write '1': set interrupt; Write '0': no effect
#define MRV_SMIA_ISR_ERR_CS
#define MRV_SMIA_ISR_ERR_CS_MASK 0x00000008U
#define MRV_SMIA_ISR_ERR_CS_SHIFT 3U
//! Slice: ISR_ERR_PROTOCOL:
//! Write '1': set interrupt; Write '0': no effect
#define MRV_SMIA_ISR_ERR_PROTOCOL
#define MRV_SMIA_ISR_ERR_PROTOCOL_MASK 0x00000004U
#define MRV_SMIA_ISR_ERR_PROTOCOL_SHIFT 2U
//! Slice: ISR_EMB_DATA_OVFLW:
//! Write '1': set interrupt; Write '0': no effect
#define MRV_SMIA_ISR_EMB_DATA_OVFLW
#define MRV_SMIA_ISR_EMB_DATA_OVFLW_MASK 0x00000002U
#define MRV_SMIA_ISR_EMB_DATA_OVFLW_SHIFT 1U
//! Slice: ISR_FRAME_END:
//! Write '1': set interrupt; Write '0': no effect
#define MRV_SMIA_ISR_FRAME_END
#define MRV_SMIA_ISR_FRAME_END_MASK 0x00000001U
#define MRV_SMIA_ISR_FRAME_END_SHIFT 0U

//! Register: smia_data_format_sel: data format selector register (0x0000001c)
//! Slice: DATA_FORMAT_SEL:
//! data format selector: 
// 0x0: YUV 422 
// 0x1: YUV 420 
// 0x4: RGB 444 
// 0x5: RGB 565 
// 0x6: RGB 888 
// 0x8: RAW 6 
// 0x9: RAW 7  
// 0xA: RAW 8  
// 0xB: RAW 10 
// 0xC: RAW 12 
// 0xD: RAW 8-bit to 10-bit decompression 
// 0xF: compressed 
// 0x2, 0x3, 0x7, 0xE: reserved, no output
#define MRV_SMIA_DATA_FORMAT_SEL
#define MRV_SMIA_DATA_FORMAT_SEL_MASK 0x0000000FU
#define MRV_SMIA_DATA_FORMAT_SEL_SHIFT 0U

//! Register: smia_sof_emb_data_lines: start of frame embedded data lines register (0x00000020)
//! Slice: SOF_EMB_DATA_LINES:
//! number of embedded data lines at frame start
#define MRV_SMIA_SOF_EMB_DATA_LINES
#define MRV_SMIA_SOF_EMB_DATA_LINES_MASK 0x00000007U
#define MRV_SMIA_SOF_EMB_DATA_LINES_SHIFT 0U

//! Register: smia_emb_hstart: embedded data hstart register (0x00000024)
//! Slice: EMB_HSTART:
//! horizontal start position of captured embedded data. 
// Must be 32-bit aligned (bit 0 and bit 1 are hard wired to "00")
#define MRV_SMIA_EMB_HSTART
#define MRV_SMIA_EMB_HSTART_MASK 0x00007FFCU
#define MRV_SMIA_EMB_HSTART_SHIFT 2U

//! Register: smia_emb_hsize: embedded data hsize register (0x00000028)
//! Slice: EMB_HSIZE:
//! number of captured embedded data dwords per line 
// '0' means no capturing of embedded data. 
// Must be 32-bit aligned (bit 0 and bit 1 are hard wired to "00")
#define MRV_SMIA_EMB_HSIZE
#define MRV_SMIA_EMB_HSIZE_MASK 0x00007FFCU
#define MRV_SMIA_EMB_HSIZE_SHIFT 2U

//! Register: smia_emb_vstart: embedded data vstart register (0x0000002c)
//! Slice: EMB_VSTART:
//! start line of embedded data extraction.  
// '0' means no capturing of embedded data
#define MRV_SMIA_EMB_VSTART
#define MRV_SMIA_EMB_VSTART_MASK 0x00003FFFU
#define MRV_SMIA_EMB_VSTART_SHIFT 0U

//! Register: smia_num_lines: image data lines register (0x00000030)
//! Slice: NUM_LINES:
//! number of image data lines per frame
#define MRV_SMIA_NUM_LINES
#define MRV_SMIA_NUM_LINES_MASK 0x00003FFFU
#define MRV_SMIA_NUM_LINES_SHIFT 0U

//! Register: smia_emb_data_fifo: Embedded Data Fifo (0x00000034)
//! Slice: EMB_DATA_FIFO:
//! lowest 4 bytes in embedded data fifo;  
// reading increments fifo read pointer. 
// First embedded data byte will be written to bits 7:0 of 32-bit data word, second data byte written to 15:8 etc.
#define MRV_SMIA_EMB_DATA_FIFO
#define MRV_SMIA_EMB_DATA_FIFO_MASK 0xFFFFFFFFU
#define MRV_SMIA_EMB_DATA_FIFO_SHIFT 0U

//! Register: smia_fifo_fill_level: Embedded Data FIFO Fill Level (0x00000038)
//! Slice: FIFO_FILL_LEVEL:
//! FIFO level in dwords for triggering the fill level interrupt. 
// Must be 32-bit aligned (bit 0 and bit 1 are hard wired to "00")
#define MRV_SMIA_FIFO_FILL_LEVEL
#define MRV_SMIA_FIFO_FILL_LEVEL_MASK 0x000003FFU
#define MRV_SMIA_FIFO_FILL_LEVEL_SHIFT 0U

//! Register: mipi_ctrl: global control register (0x00000000)
//! Slice: S_ENABLE_CLK:
//! Sensor clock lane enable signal. This register is directly connected to the output port "s_enableclk". 
// '1': enable sensor clock lane (DEFAULT) 
// '0': disable sensor clock lane
#define MRV_MIPI_S_ENABLE_CLK
#define MRV_MIPI_S_ENABLE_CLK_MASK 0x00040000U
#define MRV_MIPI_S_ENABLE_CLK_SHIFT 18U
//! Slice: ERR_SOT_SYNC_HS_SKIP:
//! 1: data within the current transmission is skipped if ErrSotSyncHS is detected (default) 
// 0: ErrSotSyncHS does not affect transmission
#define MRV_MIPI_ERR_SOT_SYNC_HS_SKIP
#define MRV_MIPI_ERR_SOT_SYNC_HS_SKIP_MASK 0x00020000U
#define MRV_MIPI_ERR_SOT_SYNC_HS_SKIP_SHIFT 17U
//! Slice: ERR_SOT_HS_SKIP:
//! 1: data within the current transmission is skipped if ErrSotHS is detected 
// 0: ErrSotHS does not affect transmission (default)
#define MRV_MIPI_ERR_SOT_HS_SKIP
#define MRV_MIPI_ERR_SOT_HS_SKIP_MASK 0x00010000U
#define MRV_MIPI_ERR_SOT_HS_SKIP_SHIFT 16U
//! Slice: NUM_LANES:
//! 00: Lane 1 is used 
// 01: Lanes 1 and 2 are used 
// 10: Lanes 1, 2 and 3 are used 
// 11: Lanes 1, 2, 3 and 4 are used (default)
#define MRV_MIPI_NUM_LANES
#define MRV_MIPI_NUM_LANES_MASK 0x00003000U
#define MRV_MIPI_NUM_LANES_SHIFT 12U
//! Slice: SHUTDOWN_LANE:
//! Shutdown Lane Module. Content of this register is directly connected to the output signal shutdown[n-1:0] where n denotes the lane number 1..4
#define MRV_MIPI_SHUTDOWN_LANE
#define MRV_MIPI_SHUTDOWN_LANE_MASK 0x00000F00U
#define MRV_MIPI_SHUTDOWN_LANE_SHIFT 8U
//! Slice: FLUSH_FIFO:
//! writing '1' resets the write- and read pointers of the additional data fifo, reading returns the status of the flush_fifo bit. This bit must be reset by software.
#define MRV_MIPI_FLUSH_FIFO
#define MRV_MIPI_FLUSH_FIFO_MASK 0x00000002U
#define MRV_MIPI_FLUSH_FIFO_SHIFT 1U
//! Slice: OUTPUT_ENA:
//! 1: output to add data fifo and to output interface is enabled 
// 0: output is disabled
#define MRV_MIPI_OUTPUT_ENA
#define MRV_MIPI_OUTPUT_ENA_MASK 0x00000001U
#define MRV_MIPI_OUTPUT_ENA_SHIFT 0U

//! Register: mipi_status: global status register (0x00000004)
//! Slice: S_ULP_ACTIVE_NOT_CLK:
//! sensor clock lane is in ULP state. This register is directly connected to the synchronized input signal "s_ulpsactivenotclk"
#define MRV_MIPI_S_ULP_ACTIVE_NOT_CLK
#define MRV_MIPI_S_ULP_ACTIVE_NOT_CLK_MASK 0x00002000U
#define MRV_MIPI_S_ULP_ACTIVE_NOT_CLK_SHIFT 13U
//! Slice: S_STOPSTATE_CLK:
//! sensor clock lane is in stopstate. This register is directly connected to the synchronized input signal "s_stopstateclk"
#define MRV_MIPI_S_STOPSTATE_CLK
#define MRV_MIPI_S_STOPSTATE_CLK_MASK 0x00001000U
#define MRV_MIPI_S_STOPSTATE_CLK_SHIFT 12U
//! Slice: STOPSTATE:
//! Data Lane is in stopstate. This register is directly connected to the synchronized input signal stopstate[n-1:0] where n denotes the lane number 1..4
#define MRV_MIPI_STOPSTATE
#define MRV_MIPI_STOPSTATE_MASK 0x00000F00U
#define MRV_MIPI_STOPSTATE_SHIFT 8U
//! Slice: ADD_DATA_AVAIL:
//! 1: additional data fifo contains data 
// 0: additional data fifo is empty
#define MRV_MIPI_ADD_DATA_AVAIL
#define MRV_MIPI_ADD_DATA_AVAIL_MASK 0x00000001U
#define MRV_MIPI_ADD_DATA_AVAIL_SHIFT 0U

//! Register: mipi_imsc: Interrupt mask (0x00000008)
//! Slice: IMSC_GEN_SHORT_PACK:
//! enable interrupt (1) or mask out (0)
#define MRV_MIPI_IMSC_GEN_SHORT_PACK
#define MRV_MIPI_IMSC_GEN_SHORT_PACK_MASK 0x08000000U
#define MRV_MIPI_IMSC_GEN_SHORT_PACK_SHIFT 27U
//! Slice: IMSC_ADD_DATA_FILL_LEVEL:
//! enable interrupt (1) or mask out (0)
#define MRV_MIPI_IMSC_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_IMSC_ADD_DATA_FILL_LEVEL_MASK 0x04000000U
#define MRV_MIPI_IMSC_ADD_DATA_FILL_LEVEL_SHIFT 26U
//! Slice: IMSC_ADD_DATA_OVFLW:
//! enable interrupt (1) or mask out (0)
#define MRV_MIPI_IMSC_ADD_DATA_OVFLW
#define MRV_MIPI_IMSC_ADD_DATA_OVFLW_MASK 0x02000000U
#define MRV_MIPI_IMSC_ADD_DATA_OVFLW_SHIFT 25U
//! Slice: IMSC_FRAME_END:
//! enable interrupt (1) or mask out (0)
#define MRV_MIPI_IMSC_FRAME_END
#define MRV_MIPI_IMSC_FRAME_END_MASK 0x01000000U
#define MRV_MIPI_IMSC_FRAME_END_SHIFT 24U
//! Slice: IMSC_ERR_CS:
//! enable interrupt (1) or mask out (0)
#define MRV_MIPI_IMSC_ERR_CS
#define MRV_MIPI_IMSC_ERR_CS_MASK 0x00800000U
#define MRV_MIPI_IMSC_ERR_CS_SHIFT 23U
//! Slice: IMSC_ERR_ECC1:
//! enable interrupt (1) or mask out (0)
#define MRV_MIPI_IMSC_ERR_ECC1
#define MRV_MIPI_IMSC_ERR_ECC1_MASK 0x00400000U
#define MRV_MIPI_IMSC_ERR_ECC1_SHIFT 22U
//! Slice: IMSC_ERR_ECC2:
//! enable interrupt (1) or mask out (0)
#define MRV_MIPI_IMSC_ERR_ECC2
#define MRV_MIPI_IMSC_ERR_ECC2_MASK 0x00200000U
#define MRV_MIPI_IMSC_ERR_ECC2_SHIFT 21U
//! Slice: IMSC_ERR_PROTOCOL:
//! enable interrupt (1) or mask out (0)
#define MRV_MIPI_IMSC_ERR_PROTOCOL
#define MRV_MIPI_IMSC_ERR_PROTOCOL_MASK 0x00100000U
#define MRV_MIPI_IMSC_ERR_PROTOCOL_SHIFT 20U
//! Slice: IMSC_ERR_CONTROL:
//! enable interrupt (1) or mask out (0) (one bit for each lane)
#define MRV_MIPI_IMSC_ERR_CONTROL
#define MRV_MIPI_IMSC_ERR_CONTROL_MASK 0x000F0000U
#define MRV_MIPI_IMSC_ERR_CONTROL_SHIFT 16U
//! Slice: IMSC_ERR_EOT_SYNC:
//! enable interrupt (1) or mask out (0) (one bit for each lane)
#define MRV_MIPI_IMSC_ERR_EOT_SYNC
#define MRV_MIPI_IMSC_ERR_EOT_SYNC_MASK 0x0000F000U
#define MRV_MIPI_IMSC_ERR_EOT_SYNC_SHIFT 12U
//! Slice: IMSC_ERR_SOT_SYNC:
//! enable interrupt (1) or mask out (0) (one bit for each lane)
#define MRV_MIPI_IMSC_ERR_SOT_SYNC
#define MRV_MIPI_IMSC_ERR_SOT_SYNC_MASK 0x00000F00U
#define MRV_MIPI_IMSC_ERR_SOT_SYNC_SHIFT 8U
//! Slice: IMSC_ERR_SOT:
//! enable interrupt (1) or mask out (0) (one bit for each lane)
#define MRV_MIPI_IMSC_ERR_SOT
#define MRV_MIPI_IMSC_ERR_SOT_MASK 0x000000F0U
#define MRV_MIPI_IMSC_ERR_SOT_SHIFT 4U
//! Slice: IMSC_SYNC_FIFO_OVFLW:
//! enable interrupt (1) or mask out (0) (one bit for each lane)
#define MRV_MIPI_IMSC_SYNC_FIFO_OVFLW
#define MRV_MIPI_IMSC_SYNC_FIFO_OVFLW_MASK 0x0000000FU
#define MRV_MIPI_IMSC_SYNC_FIFO_OVFLW_SHIFT 0U

//! Register: mipi_ris: Raw interrupt status (0x0000000c)
//! Slice: RIS_GEN_SHORT_PACK:
//! generic short packet was received (only available in version 2 of MIPI interface) 
// 
// When this interrupt is cleared, all the bits of the MIPI_GEN_SHORT_DT status register are cleared as well; Setting of this interrupt via MIPI_ISR register will set all the bits of the MIPI_GEN_SHORT_DT register.
#define MRV_MIPI_RIS_GEN_SHORT_PACK
#define MRV_MIPI_RIS_GEN_SHORT_PACK_MASK 0x08000000U
#define MRV_MIPI_RIS_GEN_SHORT_PACK_SHIFT 27U
//! Slice: RIS_ADD_DATA_FILL_LEVEL:
//! Programmed fill level was reached; will be raised as long as the fill level is greater than the programmed value
#define MRV_MIPI_RIS_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_RIS_ADD_DATA_FILL_LEVEL_MASK 0x04000000U
#define MRV_MIPI_RIS_ADD_DATA_FILL_LEVEL_SHIFT 26U
//! Slice: RIS_ADD_DATA_OVFLW:
//! additional data fifo overflow occurred
#define MRV_MIPI_RIS_ADD_DATA_OVFLW
#define MRV_MIPI_RIS_ADD_DATA_OVFLW_MASK 0x02000000U
#define MRV_MIPI_RIS_ADD_DATA_OVFLW_SHIFT 25U
//! Slice: RIS_FRAME_END:
//! frame end send to output interface
#define MRV_MIPI_RIS_FRAME_END
#define MRV_MIPI_RIS_FRAME_END_MASK 0x01000000U
#define MRV_MIPI_RIS_FRAME_END_SHIFT 24U
//! Slice: RIS_ERR_CS:
//! checksum error occurred
#define MRV_MIPI_RIS_ERR_CS
#define MRV_MIPI_RIS_ERR_CS_MASK 0x00800000U
#define MRV_MIPI_RIS_ERR_CS_SHIFT 23U
//! Slice: RIS_ERR_ECC1:
//! 1-bit ecc error occurred
#define MRV_MIPI_RIS_ERR_ECC1
#define MRV_MIPI_RIS_ERR_ECC1_MASK 0x00400000U
#define MRV_MIPI_RIS_ERR_ECC1_SHIFT 22U
//! Slice: RIS_ERR_ECC2:
//! 2-bit ecc error occurred
#define MRV_MIPI_RIS_ERR_ECC2
#define MRV_MIPI_RIS_ERR_ECC2_MASK 0x00200000U
#define MRV_MIPI_RIS_ERR_ECC2_SHIFT 21U
//! Slice: RIS_ERR_PROTOCOL:
//! packet start detected within current packet
#define MRV_MIPI_RIS_ERR_PROTOCOL
#define MRV_MIPI_RIS_ERR_PROTOCOL_MASK 0x00100000U
#define MRV_MIPI_RIS_ERR_PROTOCOL_SHIFT 20U
//! Slice: RIS_ERR_CONTROL:
//! PPI interface control error occured, one bit for each lane
#define MRV_MIPI_RIS_ERR_CONTROL
#define MRV_MIPI_RIS_ERR_CONTROL_MASK 0x000F0000U
#define MRV_MIPI_RIS_ERR_CONTROL_SHIFT 16U
//! Slice: RIS_ERR_EOT_SYNC:
//! PPI interface eot sync error occured, one bit for each lane
#define MRV_MIPI_RIS_ERR_EOT_SYNC
#define MRV_MIPI_RIS_ERR_EOT_SYNC_MASK 0x0000F000U
#define MRV_MIPI_RIS_ERR_EOT_SYNC_SHIFT 12U
//! Slice: RIS_ERR_SOT_SYNC:
//! PPI interface sot sync error occured, one bit for each lane
#define MRV_MIPI_RIS_ERR_SOT_SYNC
#define MRV_MIPI_RIS_ERR_SOT_SYNC_MASK 0x00000F00U
#define MRV_MIPI_RIS_ERR_SOT_SYNC_SHIFT 8U
//! Slice: RIS_ERR_SOT:
//! PPI interface sot error occured, one bit for each lane
#define MRV_MIPI_RIS_ERR_SOT
#define MRV_MIPI_RIS_ERR_SOT_MASK 0x000000F0U
#define MRV_MIPI_RIS_ERR_SOT_SHIFT 4U
//! Slice: RIS_SYNC_FIFO_OVFLW:
//! synchronization fifo overflow occurred, one bit for each lane
#define MRV_MIPI_RIS_SYNC_FIFO_OVFLW
#define MRV_MIPI_RIS_SYNC_FIFO_OVFLW_MASK 0x0000000FU
#define MRV_MIPI_RIS_SYNC_FIFO_OVFLW_SHIFT 0U

//! Register: mipi_mis: Masked interrupt status (0x00000010)
//! Slice: MIS_GEN_SHORT_PACK:
//! generic short packet was received (only available in version 2 of MIPI interface)
#define MRV_MIPI_MIS_GEN_SHORT_PACK
#define MRV_MIPI_MIS_GEN_SHORT_PACK_MASK 0x08000000U
#define MRV_MIPI_MIS_GEN_SHORT_PACK_SHIFT 27U
//! Slice: MIS_ADD_DATA_FILL_LEVEL:
//! Programmed fill level was reached; will be raised as long as the fill level is greater the programmed value
#define MRV_MIPI_MIS_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_MIS_ADD_DATA_FILL_LEVEL_MASK 0x04000000U
#define MRV_MIPI_MIS_ADD_DATA_FILL_LEVEL_SHIFT 26U
//! Slice: MIS_ADD_DATA_OVFLW:
//! additional data fifo overflow
#define MRV_MIPI_MIS_ADD_DATA_OVFLW
#define MRV_MIPI_MIS_ADD_DATA_OVFLW_MASK 0x02000000U
#define MRV_MIPI_MIS_ADD_DATA_OVFLW_SHIFT 25U
//! Slice: MIS_FRAME_END:
//! frame end send to output interface
#define MRV_MIPI_MIS_FRAME_END
#define MRV_MIPI_MIS_FRAME_END_MASK 0x01000000U
#define MRV_MIPI_MIS_FRAME_END_SHIFT 24U
//! Slice: MIS_ERR_CS:
//! checksum error occurred
#define MRV_MIPI_MIS_ERR_CS
#define MRV_MIPI_MIS_ERR_CS_MASK 0x00800000U
#define MRV_MIPI_MIS_ERR_CS_SHIFT 23U
//! Slice: MIS_ERR_ECC1:
//! 1-bit ecc error occurred
#define MRV_MIPI_MIS_ERR_ECC1
#define MRV_MIPI_MIS_ERR_ECC1_MASK 0x00400000U
#define MRV_MIPI_MIS_ERR_ECC1_SHIFT 22U
//! Slice: MIS_ERR_ECC2:
//! 2-bit ecc error occurred
#define MRV_MIPI_MIS_ERR_ECC2
#define MRV_MIPI_MIS_ERR_ECC2_MASK 0x00200000U
#define MRV_MIPI_MIS_ERR_ECC2_SHIFT 21U
//! Slice: MIS_ERR_PROTOCOL:
//! packet start detected within current packet
#define MRV_MIPI_MIS_ERR_PROTOCOL
#define MRV_MIPI_MIS_ERR_PROTOCOL_MASK 0x00100000U
#define MRV_MIPI_MIS_ERR_PROTOCOL_SHIFT 20U
//! Slice: MIS_ERR_CONTROL:
//! PPI interface control error occured, one bit for each lane
#define MRV_MIPI_MIS_ERR_CONTROL
#define MRV_MIPI_MIS_ERR_CONTROL_MASK 0x000F0000U
#define MRV_MIPI_MIS_ERR_CONTROL_SHIFT 16U
//! Slice: MIS_ERR_EOT_SYNC:
//! PPI interface eot sync error occured, one bit for each lane
#define MRV_MIPI_MIS_ERR_EOT_SYNC
#define MRV_MIPI_MIS_ERR_EOT_SYNC_MASK 0x0000F000U
#define MRV_MIPI_MIS_ERR_EOT_SYNC_SHIFT 12U
//! Slice: MIS_ERR_SOT_SYNC:
//! PPI interface sot sync error occured, one bit for each lane
#define MRV_MIPI_MIS_ERR_SOT_SYNC
#define MRV_MIPI_MIS_ERR_SOT_SYNC_MASK 0x00000F00U
#define MRV_MIPI_MIS_ERR_SOT_SYNC_SHIFT 8U
//! Slice: MIS_ERR_SOT:
//! PPI interface sot error occured, one bit for each lane
#define MRV_MIPI_MIS_ERR_SOT
#define MRV_MIPI_MIS_ERR_SOT_MASK 0x000000F0U
#define MRV_MIPI_MIS_ERR_SOT_SHIFT 4U
//! Slice: MIS_SYNC_FIFO_OVFLW:
//! synchronization fifo overflow occurred, one bit for each lane
#define MRV_MIPI_MIS_SYNC_FIFO_OVFLW
#define MRV_MIPI_MIS_SYNC_FIFO_OVFLW_MASK 0x0000000FU
#define MRV_MIPI_MIS_SYNC_FIFO_OVFLW_SHIFT 0U

//! Register: mipi_icr: Interrupt clear register (0x00000014)
//! Slice: ICR_GEN_SHORT_PACK:
//! 1: clear register; 0: nothing happens
#define MRV_MIPI_ICR_GEN_SHORT_PACK
#define MRV_MIPI_ICR_GEN_SHORT_PACK_MASK 0x08000000U
#define MRV_MIPI_ICR_GEN_SHORT_PACK_SHIFT 27U
//! Slice: ICR_ADD_DATA_FILL_LEVEL:
//! 1: clear register; 0: nothing happens
#define MRV_MIPI_ICR_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_ICR_ADD_DATA_FILL_LEVEL_MASK 0x04000000U
#define MRV_MIPI_ICR_ADD_DATA_FILL_LEVEL_SHIFT 26U
//! Slice: ICR_ADD_DATA_OVFLW:
//! 1: clear register; 0: nothing happens
#define MRV_MIPI_ICR_ADD_DATA_OVFLW
#define MRV_MIPI_ICR_ADD_DATA_OVFLW_MASK 0x02000000U
#define MRV_MIPI_ICR_ADD_DATA_OVFLW_SHIFT 25U
//! Slice: ICR_FRAME_END:
//! 1: clear register; 0: nothing happens
#define MRV_MIPI_ICR_FRAME_END
#define MRV_MIPI_ICR_FRAME_END_MASK 0x01000000U
#define MRV_MIPI_ICR_FRAME_END_SHIFT 24U
//! Slice: ICR_ERR_CS:
//! 1: clear register; 0: nothing happens
#define MRV_MIPI_ICR_ERR_CS
#define MRV_MIPI_ICR_ERR_CS_MASK 0x00800000U
#define MRV_MIPI_ICR_ERR_CS_SHIFT 23U
//! Slice: ICR_ERR_ECC1:
//! 1: clear register; 0: nothing happens
#define MRV_MIPI_ICR_ERR_ECC1
#define MRV_MIPI_ICR_ERR_ECC1_MASK 0x00400000U
#define MRV_MIPI_ICR_ERR_ECC1_SHIFT 22U
//! Slice: ICR_ERR_ECC2:
//! 1: clear register; 0: nothing happens
#define MRV_MIPI_ICR_ERR_ECC2
#define MRV_MIPI_ICR_ERR_ECC2_MASK 0x00200000U
#define MRV_MIPI_ICR_ERR_ECC2_SHIFT 21U
//! Slice: ICR_ERR_PROTOCOL:
//! 1: clear register; 0: nothing happens
#define MRV_MIPI_ICR_ERR_PROTOCOL
#define MRV_MIPI_ICR_ERR_PROTOCOL_MASK 0x00100000U
#define MRV_MIPI_ICR_ERR_PROTOCOL_SHIFT 20U
//! Slice: ICR_ERR_CONTROL:
//! 1: clear register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ICR_ERR_CONTROL
#define MRV_MIPI_ICR_ERR_CONTROL_MASK 0x000F0000U
#define MRV_MIPI_ICR_ERR_CONTROL_SHIFT 16U
//! Slice: ICR_ERR_EOT_SYNC:
//! 1: clear register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ICR_ERR_EOT_SYNC
#define MRV_MIPI_ICR_ERR_EOT_SYNC_MASK 0x0000F000U
#define MRV_MIPI_ICR_ERR_EOT_SYNC_SHIFT 12U
//! Slice: ICR_ERR_SOT_SYNC:
//! 1: clear register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ICR_ERR_SOT_SYNC
#define MRV_MIPI_ICR_ERR_SOT_SYNC_MASK 0x00000F00U
#define MRV_MIPI_ICR_ERR_SOT_SYNC_SHIFT 8U
//! Slice: ICR_ERR_SOT:
//! 1: clear register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ICR_ERR_SOT
#define MRV_MIPI_ICR_ERR_SOT_MASK 0x000000F0U
#define MRV_MIPI_ICR_ERR_SOT_SHIFT 4U
//! Slice: ICR_SYNC_FIFO_OVFLW:
//! 1: clear register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ICR_SYNC_FIFO_OVFLW
#define MRV_MIPI_ICR_SYNC_FIFO_OVFLW_MASK 0x0000000FU
#define MRV_MIPI_ICR_SYNC_FIFO_OVFLW_SHIFT 0U

//! Register: mipi_isr: Interrupt set register (0x00000018)
//! Slice: ISR_GEN_SHORT_PACK:
//! 1: set register; 0: nothing happens
#define MRV_MIPI_ISR_GEN_SHORT_PACK
#define MRV_MIPI_ISR_GEN_SHORT_PACK_MASK 0x08000000U
#define MRV_MIPI_ISR_GEN_SHORT_PACK_SHIFT 27U
//! Slice: ISR_ADD_DATA_FILL_LEVEL:
//! 1: set register; 0: nothing happens
#define MRV_MIPI_ISR_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_ISR_ADD_DATA_FILL_LEVEL_MASK 0x04000000U
#define MRV_MIPI_ISR_ADD_DATA_FILL_LEVEL_SHIFT 26U
//! Slice: ISR_ADD_DATA_OVFLW:
//! 1: set register; 0: nothing happens
#define MRV_MIPI_ISR_ADD_DATA_OVFLW
#define MRV_MIPI_ISR_ADD_DATA_OVFLW_MASK 0x02000000U
#define MRV_MIPI_ISR_ADD_DATA_OVFLW_SHIFT 25U
//! Slice: ISR_FRAME_END:
//! 1: set register; 0: nothing happens
#define MRV_MIPI_ISR_FRAME_END
#define MRV_MIPI_ISR_FRAME_END_MASK 0x01000000U
#define MRV_MIPI_ISR_FRAME_END_SHIFT 24U
//! Slice: ISR_ERR_CS:
//! 1: set register; 0: nothing happens
#define MRV_MIPI_ISR_ERR_CS
#define MRV_MIPI_ISR_ERR_CS_MASK 0x00800000U
#define MRV_MIPI_ISR_ERR_CS_SHIFT 23U
//! Slice: ISR_ERR_ECC1:
//! 1: set register; 0: nothing happens
#define MRV_MIPI_ISR_ERR_ECC1
#define MRV_MIPI_ISR_ERR_ECC1_MASK 0x00400000U
#define MRV_MIPI_ISR_ERR_ECC1_SHIFT 22U
//! Slice: ISR_ERR_ECC2:
//! 1: set register; 0: nothing happens
#define MRV_MIPI_ISR_ERR_ECC2
#define MRV_MIPI_ISR_ERR_ECC2_MASK 0x00200000U
#define MRV_MIPI_ISR_ERR_ECC2_SHIFT 21U
//! Slice: ISR_ERR_PROTOCOL:
//! 1: set register; 0: nothing happens
#define MRV_MIPI_ISR_ERR_PROTOCOL
#define MRV_MIPI_ISR_ERR_PROTOCOL_MASK 0x00100000U
#define MRV_MIPI_ISR_ERR_PROTOCOL_SHIFT 20U
//! Slice: ISR_ERR_CONTROL:
//! 1: set register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ISR_ERR_CONTROL
#define MRV_MIPI_ISR_ERR_CONTROL_MASK 0x000F0000U
#define MRV_MIPI_ISR_ERR_CONTROL_SHIFT 16U
//! Slice: ISR_ERR_EOT_SYNC:
//! 1: set register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ISR_ERR_EOT_SYNC
#define MRV_MIPI_ISR_ERR_EOT_SYNC_MASK 0x0000F000U
#define MRV_MIPI_ISR_ERR_EOT_SYNC_SHIFT 12U
//! Slice: ISR_ERR_SOT_SYNC:
//! 1: set register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ISR_ERR_SOT_SYNC
#define MRV_MIPI_ISR_ERR_SOT_SYNC_MASK 0x00000F00U
#define MRV_MIPI_ISR_ERR_SOT_SYNC_SHIFT 8U
//! Slice: ISR_ERR_SOT:
//! 1: set register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ISR_ERR_SOT
#define MRV_MIPI_ISR_ERR_SOT_MASK 0x000000F0U
#define MRV_MIPI_ISR_ERR_SOT_SHIFT 4U
//! Slice: ISR_SYNC_FIFO_OVFLW:
//! 1: set register; 0: nothing happens (one bit for each lane)
#define MRV_MIPI_ISR_SYNC_FIFO_OVFLW
#define MRV_MIPI_ISR_SYNC_FIFO_OVFLW_MASK 0x0000000FU
#define MRV_MIPI_ISR_SYNC_FIFO_OVFLW_SHIFT 0U

//! Register: mipi_cur_data_id: Current Data Identifier (0x0000001c)
//! Slice: VIRTUAL_CHANNEL:
//! virtual channel of currently received packet
#define MRV_MIPI_VIRTUAL_CHANNEL
#define MRV_MIPI_VIRTUAL_CHANNEL_MASK 0x000000C0U
#define MRV_MIPI_VIRTUAL_CHANNEL_SHIFT 6U
//! Slice: DATA_TYPE:
//! data type of currently received packet
#define MRV_MIPI_DATA_TYPE
#define MRV_MIPI_DATA_TYPE_MASK 0x0000003FU
#define MRV_MIPI_DATA_TYPE_SHIFT 0U

//! Register: mipi_img_data_sel: Image Data Selector (0x00000020)
//! Slice: VIRTUAL_CHANNEL_SEL:
//! virtual channel selector for image data output
#define MRV_MIPI_VIRTUAL_CHANNEL_SEL
#define MRV_MIPI_VIRTUAL_CHANNEL_SEL_MASK 0x000000C0U
#define MRV_MIPI_VIRTUAL_CHANNEL_SEL_SHIFT 6U
//! Slice: DATA_TYPE_SEL:
//! data type selector for image data output: 
// 0x08...0x0F generic short packets 
// 0x12	embedded 8-bit data 
// 0x18	YUV 420 8-bit 
// 0x19	YUV 420 10-bit 
// 0x1A	Legacy YUV 420 8-bit 
// 0x1C	YUV 420 8-bit (CSPS) 
// 0x1D	YUV 420 10-bit (CSPS) 
// 0x1E	YUV 422 8-bit 
// 0x1F	YUV 422 10-bit 
// 0x20	RGB 444 
// 0x21	RGB 555 
// 0x22	RGB 565 
// 0x23	RGB 666 
// 0x24	RGB 888 
// 0x28	RAW 6 
// 0x29	RAW 7 
// 0x2A	RAW 8 
// 0x2B	RAW 10 
// 0x2C	RAW 12 
// 0x30...0x37 User Defined Byte-based data
#define MRV_MIPI_DATA_TYPE_SEL
#define MRV_MIPI_DATA_TYPE_SEL_MASK 0x0000003FU
#define MRV_MIPI_DATA_TYPE_SEL_SHIFT 0U

//! Register: mipi_add_data_sel_1: Additional Data Selector 1 (0x00000024)
//! Slice: ADD_DATA_VC_1:
//! virtual channel selector for additional data output
#define MRV_MIPI_ADD_DATA_VC_1
#define MRV_MIPI_ADD_DATA_VC_1_MASK 0x000000C0U
#define MRV_MIPI_ADD_DATA_VC_1_SHIFT 6U
//! Slice: ADD_DATA_TYPE_1:
//! data type selector for additional data output
#define MRV_MIPI_ADD_DATA_TYPE_1
#define MRV_MIPI_ADD_DATA_TYPE_1_MASK 0x0000003FU
#define MRV_MIPI_ADD_DATA_TYPE_1_SHIFT 0U

//! Register: mipi_add_data_sel_2: Additional Data Selector 2 (0x00000028)
//! Slice: ADD_DATA_VC_2:
//! virtual channel selector for additional data output
#define MRV_MIPI_ADD_DATA_VC_2
#define MRV_MIPI_ADD_DATA_VC_2_MASK 0x000000C0U
#define MRV_MIPI_ADD_DATA_VC_2_SHIFT 6U
//! Slice: ADD_DATA_TYPE_2:
//! data type selector for additional data output
#define MRV_MIPI_ADD_DATA_TYPE_2
#define MRV_MIPI_ADD_DATA_TYPE_2_MASK 0x0000003FU
#define MRV_MIPI_ADD_DATA_TYPE_2_SHIFT 0U

//! Register: mipi_add_data_sel_3: Additional Data Selector 3 (0x0000002c)
//! Slice: ADD_DATA_VC_3:
//! virtual channel selector for additional data output
#define MRV_MIPI_ADD_DATA_VC_3
#define MRV_MIPI_ADD_DATA_VC_3_MASK 0x000000C0U
#define MRV_MIPI_ADD_DATA_VC_3_SHIFT 6U
//! Slice: ADD_DATA_TYPE_3:
//! data type selector for additional data output
#define MRV_MIPI_ADD_DATA_TYPE_3
#define MRV_MIPI_ADD_DATA_TYPE_3_MASK 0x0000003FU
#define MRV_MIPI_ADD_DATA_TYPE_3_SHIFT 0U

//! Register: mipi_add_data_sel_4: Additional Data Selector 4 (0x00000030)
//! Slice: ADD_DATA_VC_4:
//! virtual channel selector for additional data output
#define MRV_MIPI_ADD_DATA_VC_4
#define MRV_MIPI_ADD_DATA_VC_4_MASK 0x000000C0U
#define MRV_MIPI_ADD_DATA_VC_4_SHIFT 6U
//! Slice: ADD_DATA_TYPE_4:
//! data type selector for additional data output
#define MRV_MIPI_ADD_DATA_TYPE_4
#define MRV_MIPI_ADD_DATA_TYPE_4_MASK 0x0000003FU
#define MRV_MIPI_ADD_DATA_TYPE_4_SHIFT 0U

//! Register: mipi_add_data_fifo: Additional Data Fifo (0x00000034)
//! Slice: ADD_DATA_FIFO:
//! lowest 4 bytes in additional data fifo;  
// reading increments fifo read pointer. 
// First embedded data byte will be written to bits 7:0 of 32-bit data word, second data byte written to 15:8 etc.
#define MRV_MIPI_ADD_DATA_FIFO
#define MRV_MIPI_ADD_DATA_FIFO_MASK 0xFFFFFFFFU
#define MRV_MIPI_ADD_DATA_FIFO_SHIFT 0U

//! Register: mipi_add_data_fill_level: Additional Data FIFO Fill Level (0x00000038)
//! Slice: ADD_DATA_FILL_LEVEL:
//! FIFO level in dwords for triggering the FILL_LEVEL interrupt, 
// must be 32-bit aligned (bit 0 and bit 1 are hard wired to "00")
#define MRV_MIPI_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_ADD_DATA_FILL_LEVEL_MASK 0x00001FFFU
#define MRV_MIPI_ADD_DATA_FILL_LEVEL_SHIFT 0U

//! Register: mipi_compressed_mode: controls processing of compressed raw data types (0x0000003c)
//! Slice: predictor_sel:
//! predictor to be used: 
// 0: predictor 1 
// 1: predictor 2
#define MRV_MIPI_PREDICTOR_SEL
#define MRV_MIPI_PREDICTOR_SEL_MASK 0x00000100U
#define MRV_MIPI_PREDICTOR_SEL_SHIFT 8U
//! Slice: comp_scheme:
//! data compression scheme: 
// 0: 12812 
// 1: 12712 
// 2: 12612 
// 3: 10810 
// 4: 10710 
// 5: 10610 
// 6..7: reserved
#define MRV_MIPI_COMP_SCHEME
#define MRV_MIPI_COMP_SCHEME_MASK 0x00000070U
#define MRV_MIPI_COMP_SCHEME_SHIFT 4U
//! Slice: compress_en:
//! 1: enable compressed mode processing 
// 0: disable compressed mode
#define MRV_MIPI_COMPRESS_EN
#define MRV_MIPI_COMPRESS_EN_MASK 0x00000001U
#define MRV_MIPI_COMPRESS_EN_SHIFT 0U

//! Register: mipi_frame: frame number from frame start and frame end short packets (0x00000040)
//! Slice: frame_number_fe:
//! 16 bit frame number from Frame End (FE) short packet
#define MRV_MIPI_FRAME_NUMBER_FE
#define MRV_MIPI_FRAME_NUMBER_FE_MASK 0xFFFF0000U
#define MRV_MIPI_FRAME_NUMBER_FE_SHIFT 16U
//! Slice: frame_number_fs:
//! 16 bit frame number from Frame Start (FS) short packet
#define MRV_MIPI_FRAME_NUMBER_FS
#define MRV_MIPI_FRAME_NUMBER_FS_MASK 0x0000FFFFU
#define MRV_MIPI_FRAME_NUMBER_FS_SHIFT 0U

//! Register: mipi_gen_short_dt: data type flags for received generic short packets (0x00000044)
//! Slice: GEN_SHORT_DT_0xF:
//! 1: generic short packet of data type 0xF received 
// 0: data type 0xF not received
#define MRV_MIPI_GEN_SHORT_DT_0XF
#define MRV_MIPI_GEN_SHORT_DT_0XF_MASK 0x00000080U
#define MRV_MIPI_GEN_SHORT_DT_0XF_SHIFT 7U
//! Slice: GEN_SHORT_DT_0xE:
//! 1: generic short packet of data type 0xE received 
// 0: data type 0xE not received
#define MRV_MIPI_GEN_SHORT_DT_0XE
#define MRV_MIPI_GEN_SHORT_DT_0XE_MASK 0x00000040U
#define MRV_MIPI_GEN_SHORT_DT_0XE_SHIFT 6U
//! Slice: GEN_SHORT_DT_0xD:
//! 1: generic short packet of data type 0xD received  
// 0: data type 0xD not received
#define MRV_MIPI_GEN_SHORT_DT_0XD
#define MRV_MIPI_GEN_SHORT_DT_0XD_MASK 0x00000020U
#define MRV_MIPI_GEN_SHORT_DT_0XD_SHIFT 5U
//! Slice: GEN_SHORT_DT_0xC:
//! 1: generic short packet of data type 0xC received  
// 0: data type 0xC not received
#define MRV_MIPI_GEN_SHORT_DT_0XC
#define MRV_MIPI_GEN_SHORT_DT_0XC_MASK 0x00000010U
#define MRV_MIPI_GEN_SHORT_DT_0XC_SHIFT 4U
//! Slice: GEN_SHORT_DT_0xB:
//! 1: generic short packet of data type 0xB received 
// 0: data type 0xB not received
#define MRV_MIPI_GEN_SHORT_DT_0XB
#define MRV_MIPI_GEN_SHORT_DT_0XB_MASK 0x00000008U
#define MRV_MIPI_GEN_SHORT_DT_0XB_SHIFT 3U
//! Slice: GEN_SHORT_DT_0xA:
//! 1: generic short packet of data type 0xA received 
// 0: data type 0xA not received
#define MRV_MIPI_GEN_SHORT_DT_0XA
#define MRV_MIPI_GEN_SHORT_DT_0XA_MASK 0x00000004U
#define MRV_MIPI_GEN_SHORT_DT_0XA_SHIFT 2U
//! Slice: GEN_SHORT_DT_0x9:
//! 1: generic short packet of data type 0x9 received 
// 0: data type 0x9 not received
#define MRV_MIPI_GEN_SHORT_DT_0X9
#define MRV_MIPI_GEN_SHORT_DT_0X9_MASK 0x00000002U
#define MRV_MIPI_GEN_SHORT_DT_0X9_SHIFT 1U
//! Slice: GEN_SHORT_DT_0x8:
//! 1: generic short packet of data type 0x8 received 
// 0: data type 0x8 not received
#define MRV_MIPI_GEN_SHORT_DT_0X8
#define MRV_MIPI_GEN_SHORT_DT_0X8_MASK 0x00000001U
#define MRV_MIPI_GEN_SHORT_DT_0X8_SHIFT 0U

//! Register: mipi_gen_short_8_9: data field for generic short packets of data type 0x8 and 0x9 (0x00000048)
//! Slice: data_field_9:
//! 16 bit user defined data field from last generic short packet of data type 0x9
#define MRV_MIPI_DATA_FIELD_9
#define MRV_MIPI_DATA_FIELD_9_MASK 0xFFFF0000U
#define MRV_MIPI_DATA_FIELD_9_SHIFT 16U
//! Slice: data_field_8:
//! 16 bit user defined data field from last generic short packet of data type 0x8
#define MRV_MIPI_DATA_FIELD_8
#define MRV_MIPI_DATA_FIELD_8_MASK 0x0000FFFFU
#define MRV_MIPI_DATA_FIELD_8_SHIFT 0U

//! Register: mipi_gen_short_a_b: data field for generic short packets of data type 0xA and 0xB (0x0000004c)
//! Slice: data_field_B:
//! 16 bit user defined data field from last generic short packet of data type 0xB
#define MRV_MIPI_DATA_FIELD_B
#define MRV_MIPI_DATA_FIELD_B_MASK 0xFFFF0000U
#define MRV_MIPI_DATA_FIELD_B_SHIFT 16U
//! Slice: data_field_A:
//! 16 bit user defined data field from last generic short packet of data type 0xA
#define MRV_MIPI_DATA_FIELD_A
#define MRV_MIPI_DATA_FIELD_A_MASK 0x0000FFFFU
#define MRV_MIPI_DATA_FIELD_A_SHIFT 0U

//! Register: mipi_gen_short_c_d: data field for generic short packets of data type 0xC and 0xD (0x00000050)
//! Slice: data_field_D:
//! 16 bit user defined data field from last generic short packet of data type 0xD
#define MRV_MIPI_DATA_FIELD_D
#define MRV_MIPI_DATA_FIELD_D_MASK 0xFFFF0000U
#define MRV_MIPI_DATA_FIELD_D_SHIFT 16U
//! Slice: data_field_C:
//! 16 bit user defined data field from last generic short packet of data type 0xC
#define MRV_MIPI_DATA_FIELD_C
#define MRV_MIPI_DATA_FIELD_C_MASK 0x0000FFFFU
#define MRV_MIPI_DATA_FIELD_C_SHIFT 0U

//! Register: mipi_gen_short_e_f: data field for generic short packets of data type 0xE and 0xF (0x00000054)
//! Slice: data_field_F:
//! 16 bit user defined data field from last generic short packet of data type 0xF
#define MRV_MIPI_DATA_FIELD_F
#define MRV_MIPI_DATA_FIELD_F_MASK 0xFFFF0000U
#define MRV_MIPI_DATA_FIELD_F_SHIFT 16U
//! Slice: data_field_E:
//! 16 bit user defined data field from last generic short packet of data type 0xE
#define MRV_MIPI_DATA_FIELD_E
#define MRV_MIPI_DATA_FIELD_E_MASK 0x0000FFFFU
#define MRV_MIPI_DATA_FIELD_E_SHIFT 0U

//! Register: isp_afm_ctrl: This is the control register for AF measurement unit (0x00000000)
//! Slice: afm_en:
//! AF measurement enable 
// 0: AF measurement is disabled 
// 1: AF measurement is enabled 
// Writing a 1 to this register starts a new measurement and resets the afm_fin (measurement finished) interrupt to 0. 
// As long as the afm_en is 1, the AFM unit calculates new sharpness values for each frame.
#define MRV_AFM_AFM_EN
#define MRV_AFM_AFM_EN_MASK 0x00000001U
#define MRV_AFM_AFM_EN_SHIFT 0U

//! Register: isp_afm_lt_a: Top Left corner of measure window A (0x00000004)
//! Slice: a_h_l:
//! first pixel of window A (horizontal left row), value must be greater or equal 5
#define MRV_AFM_A_H_L
#define MRV_AFM_A_H_L_MASK 0x1FFF0000U
#define MRV_AFM_A_H_L_SHIFT 16U
//! Slice: a_v_t:
//! first line of window A (vertical top line), value must be greater or equal 2
#define MRV_AFM_A_V_T
#define MRV_AFM_A_V_T_MASK 0x00001FFFU
#define MRV_AFM_A_V_T_SHIFT 0U

//! Register: isp_afm_rb_a: Bottom right corner of measure window A (0x00000008)
//! Slice: a_h_r:
//! last pixel of window A (horizontal right row)
#define MRV_AFM_A_H_R
#define MRV_AFM_A_H_R_MASK 0x1FFF0000U
#define MRV_AFM_A_H_R_SHIFT 16U
//! Slice: a_v_b:
//! last line of window A (vertical bottom line), value must be lower than (number of lines  2)
#define MRV_AFM_A_V_B
#define MRV_AFM_A_V_B_MASK 0x00001FFFU
#define MRV_AFM_A_V_B_SHIFT 0U

//! Register: isp_afm_lt_b: Top left corner of measure window B (0x0000000c)
//! Slice: b_h_l:
//! first pixel of window B (horizontal left row), value must be greater or equal 5
#define MRV_AFM_B_H_L
#define MRV_AFM_B_H_L_MASK 0x1FFF0000U
#define MRV_AFM_B_H_L_SHIFT 16U
//! Slice: b_v_t:
//! first line of window B (vertical top line), value must be greater or equal 2
#define MRV_AFM_B_V_T
#define MRV_AFM_B_V_T_MASK 0x00001FFFU
#define MRV_AFM_B_V_T_SHIFT 0U

//! Register: isp_afm_rb_b: Bottom right corner of measure window B (0x00000010)
//! Slice: b_h_r:
//! last pixel of window B (horizontal right row)
#define MRV_AFM_B_H_R
#define MRV_AFM_B_H_R_MASK 0x1FFF0000U
#define MRV_AFM_B_H_R_SHIFT 16U
//! Slice: b_v_b:
//! last line of window B (vertical bottom line), value must be lower than (number of lines  2)
#define MRV_AFM_B_V_B
#define MRV_AFM_B_V_B_MASK 0x00001FFFU
#define MRV_AFM_B_V_B_SHIFT 0U

//! Register: isp_afm_lt_c: Top left corner of measure window C (0x00000014)
//! Slice: c_h_l:
//! first pixel of window C (horizontal left row), value must be greater or equal 5
#define MRV_AFM_C_H_L
#define MRV_AFM_C_H_L_MASK 0x1FFF0000U
#define MRV_AFM_C_H_L_SHIFT 16U
//! Slice: c_v_t:
//! first line of window C (vertical top line), value must be greater or equal 2
#define MRV_AFM_C_V_T
#define MRV_AFM_C_V_T_MASK 0x00001FFFU
#define MRV_AFM_C_V_T_SHIFT 0U

//! Register: isp_afm_rb_c: Bottom right corner of measure window C (0x00000018)
//! Slice: c_h_r:
//! last pixel of window C (horizontal right row)
#define MRV_AFM_C_H_R
#define MRV_AFM_C_H_R_MASK 0x1FFF0000U
#define MRV_AFM_C_H_R_SHIFT 16U
//! Slice: c_v_b:
//! last line of window C (vertical bottom line), value must be lower than (number of lines  2)
#define MRV_AFM_C_V_B
#define MRV_AFM_C_V_B_MASK 0x00001FFFU
#define MRV_AFM_C_V_B_SHIFT 0U

//! Register: isp_afm_thres: Threshold register (0x0000001c)
//! Slice: afm_thres:
//! AF measurement threshold 
// This register defines a threshold which can be used for minimizing the influence of noise in the measurement result.
#define MRV_AFM_AFM_THRES
#define MRV_AFM_AFM_THRES_MASK 0x0000FFFFU
#define MRV_AFM_AFM_THRES_SHIFT 0U

//! Register: isp_afm_var_shift: Variable shift register (0x00000020)
//! Slice: lum_var_shift:
//! variable shift for luminance summation 
// The lum_var_shift defines the number of bits for the shift operation of the value of the current pixel before summation. The shift operation is used to avoid a luminance sum overflow.
#define MRV_AFM_LUM_VAR_SHIFT
#define MRV_AFM_LUM_VAR_SHIFT_MASK 0x00070000U
#define MRV_AFM_LUM_VAR_SHIFT_SHIFT 16U
//! Slice: afm_var_shift:
//! variable shift for AF measurement 
// The afm_var_shift defines the number of bits for the shift operation at the end of the calculation chain. The shift operation is used to avoid an AF measurement sum overflow.
#define MRV_AFM_AFM_VAR_SHIFT
#define MRV_AFM_AFM_VAR_SHIFT_MASK 0x00000007U
#define MRV_AFM_AFM_VAR_SHIFT_SHIFT 0U

//! Register: isp_afm_sum_a: Sharpness Value Status Register of Window A (0x00000024)
//! Slice: afm_sum_a:
//! sharpness value of window A
#define MRV_AFM_AFM_SUM_A
#define MRV_AFM_AFM_SUM_A_MASK 0xFFFFFFFFU
#define MRV_AFM_AFM_SUM_A_SHIFT 0U

//! Register: isp_afm_sum_b: Sharpness Value Status Register of Window B (0x00000028)
//! Slice: afm_sum_b:
//! sharpness value of window B
#define MRV_AFM_AFM_SUM_B
#define MRV_AFM_AFM_SUM_B_MASK 0xFFFFFFFFU
#define MRV_AFM_AFM_SUM_B_SHIFT 0U

//! Register: isp_afm_sum_c: Sharpness Value Status Register of Window C (0x0000002c)
//! Slice: afm_sum_c:
//! sharpness value of window C
#define MRV_AFM_AFM_SUM_C
#define MRV_AFM_AFM_SUM_C_MASK 0xFFFFFFFFU
#define MRV_AFM_AFM_SUM_C_SHIFT 0U

//! Register: isp_afm_lum_a: Luminance Value Status Register of Window A (0x00000030)
//! Slice: afm_lum_a:
//! luminance value of window A
#define MRV_AFM_AFM_LUM_A
#define MRV_AFM_AFM_LUM_A_MASK 0x00FFFFFFU
#define MRV_AFM_AFM_LUM_A_SHIFT 0U

//! Register: isp_afm_lum_b: Luminance Value Status Register of Window B (0x00000034)
//! Slice: afm_lum_b:
//! luminance value of window B
#define MRV_AFM_AFM_LUM_B
#define MRV_AFM_AFM_LUM_B_MASK 0x00FFFFFFU
#define MRV_AFM_AFM_LUM_B_SHIFT 0U

//! Register: isp_afm_lum_c: Luminance Value Status Register of Window C (0x00000038)
//! Slice: afm_lum_c:
//! luminance value of window C
#define MRV_AFM_AFM_LUM_C
#define MRV_AFM_AFM_LUM_C_MASK 0x00FFFFFFU
#define MRV_AFM_AFM_LUM_C_SHIFT 0U

//! Register: isp_lsc_ctrl: Lens shade control (0x00000000)
//! Slice: lsc_en:
//! 0: activation request for lens shading correction 
// 1: deactivation reqeust for lens shading correction 
// Activation/Deactivation is object of a shadowing mechnism. The current status is visible at ISP_LSC_STATUS::lsc_enable_status
#define MRV_LSC_LSC_EN
#define MRV_LSC_LSC_EN_MASK 0x00000001U
#define MRV_LSC_LSC_EN_SHIFT 0U

//! Register: isp_lsc_r_table_addr: Table RAM Address for red component (0x00000004)
//! Slice: r_ram_addr:
//! table address in RAM for samples of the R color component. 
// Will be automatically incremented by each read or write access to the table. 
// Valid addresses are in the range 0 to 152.
#define MRV_LSC_R_RAM_ADDR
#define MRV_LSC_R_RAM_ADDR_MASK 0x000001FFU
#define MRV_LSC_R_RAM_ADDR_SHIFT 0U

//! Register: isp_lsc_gr_table_addr: Table RAM Address for green (red) component (0x00000008)
//! Slice: gr_ram_addr:
//! table address in RAM for samples of the G_R color component. 
// Will be automatically incremented by each read or write access to the table.
#define MRV_LSC_GR_RAM_ADDR
#define MRV_LSC_GR_RAM_ADDR_MASK 0x000001FFU
#define MRV_LSC_GR_RAM_ADDR_SHIFT 0U

//! Register: isp_lsc_b_table_addr: Table RAM Address for blue component (0x0000000c)
//! Slice: b_ram_addr:
//! table address in RAM for samples of the B color component.  
// Will be automatically incremented by each read or write access to the table.
#define MRV_LSC_B_RAM_ADDR
#define MRV_LSC_B_RAM_ADDR_MASK 0x000001FFU
#define MRV_LSC_B_RAM_ADDR_SHIFT 0U

//! Register: isp_lsc_gb_table_addr: Table RAM Address for green (blue) component (0x00000010)
//! Slice: gb_ram_addr:
//! table address in RAM for samples of the G_B color component. 
// Will be automatically incremented by each read or write access to the table.
#define MRV_LSC_GB_RAM_ADDR
#define MRV_LSC_GB_RAM_ADDR_MASK 0x000001FFU
#define MRV_LSC_GB_RAM_ADDR_SHIFT 0U

//! Register: isp_lsc_r_table_data: Sample table red (0x00000014)
//! Slice: r_sample_1:
//! correction factor at sample point (fixed point number: 2 bits integer with 10-bit fractional part, range 1..3.999)
#define MRV_LSC_R_SAMPLE_1
#define MRV_LSC_R_SAMPLE_1_MASK 0x00FFF000U
#define MRV_LSC_R_SAMPLE_1_SHIFT 12U
//! Slice: r_sample_0:
//! correction factor at sample point (fixed point number: 2 bits integer with 10-bit fractional part, range 1..3.999)
#define MRV_LSC_R_SAMPLE_0
#define MRV_LSC_R_SAMPLE_0_MASK 0x00000FFFU
#define MRV_LSC_R_SAMPLE_0_SHIFT 0U

//! Register: isp_lsc_gr_table_data: Sample table green (red) (0x00000018)
//! Slice: gr_sample_1:
//! correction factor at sample point (fixed point number: 2 bits integer with 10-bit fractional part, range 1..3.999)
#define MRV_LSC_GR_SAMPLE_1
#define MRV_LSC_GR_SAMPLE_1_MASK 0x00FFF000U
#define MRV_LSC_GR_SAMPLE_1_SHIFT 12U
//! Slice: gr_sample_0:
//! correction factor at sample point (fixed point number: 2 bits integer with 10-bit fractional part, range 1..3.999)
#define MRV_LSC_GR_SAMPLE_0
#define MRV_LSC_GR_SAMPLE_0_MASK 0x00000FFFU
#define MRV_LSC_GR_SAMPLE_0_SHIFT 0U

//! Register: isp_lsc_b_table_data: Sample table blue (0x0000001c)
//! Slice: b_sample_1:
//! correction factor at sample point (fixed point number: 2 bits integer with 10-bit fractional part, range 1..3.999)
#define MRV_LSC_B_SAMPLE_1
#define MRV_LSC_B_SAMPLE_1_MASK 0x00FFF000U
#define MRV_LSC_B_SAMPLE_1_SHIFT 12U
//! Slice: b_sample_0:
//! correction factor at sample point (fixed point number: 2 bits integer with 10-bit fractional part, range 1..3.999)
#define MRV_LSC_B_SAMPLE_0
#define MRV_LSC_B_SAMPLE_0_MASK 0x00000FFFU
#define MRV_LSC_B_SAMPLE_0_SHIFT 0U

//! Register: isp_lsc_gb_table_data: Sample table green (blue) (0x00000020)
//! Slice: gb_sample_1:
//! correction factor at sample point (fixed point number: 2 bits integer with 10-bit fractional part, range 1..3.999)
#define MRV_LSC_GB_SAMPLE_1
#define MRV_LSC_GB_SAMPLE_1_MASK 0x00FFF000U
#define MRV_LSC_GB_SAMPLE_1_SHIFT 12U
//! Slice: gb_sample_0:
//! correction factor at sample point (fixed point number: 2 bits integer with 10-bit fractional part, range 1..3.999)
#define MRV_LSC_GB_SAMPLE_0
#define MRV_LSC_GB_SAMPLE_0_MASK 0x00000FFFU
#define MRV_LSC_GB_SAMPLE_0_SHIFT 0U

//! Register: isp_lsc_xgrad_01: Gradient table x (0x00000024)
//! Slice: xgrad_1:
//! factor for x-gradient calculation of sector 1
#define MRV_LSC_XGRAD_1
#define MRV_LSC_XGRAD_1_MASK 0x0FFF0000U
#define MRV_LSC_XGRAD_1_SHIFT 16U
//! Slice: xgrad_0:
//! factor for x-gradient calculation of sector 0
#define MRV_LSC_XGRAD_0
#define MRV_LSC_XGRAD_0_MASK 0x00000FFFU
#define MRV_LSC_XGRAD_0_SHIFT 0U

//! Register: isp_lsc_xgrad_23: Gradient table x (0x00000028)
//! Slice: xgrad_3:
//! factor for x-gradient calculation of sector 3
#define MRV_LSC_XGRAD_3
#define MRV_LSC_XGRAD_3_MASK 0x0FFF0000U
#define MRV_LSC_XGRAD_3_SHIFT 16U
//! Slice: xgrad_2:
//! factor for x-gradient calculation of sector 2
#define MRV_LSC_XGRAD_2
#define MRV_LSC_XGRAD_2_MASK 0x00000FFFU
#define MRV_LSC_XGRAD_2_SHIFT 0U

//! Register: isp_lsc_xgrad_45: Gradient table x (0x0000002c)
//! Slice: xgrad_5:
//! factor for x-gradient calculation of sector 5
#define MRV_LSC_XGRAD_5
#define MRV_LSC_XGRAD_5_MASK 0x0FFF0000U
#define MRV_LSC_XGRAD_5_SHIFT 16U
//! Slice: xgrad_4:
//! factor for x-gradient calculation of sector 4
#define MRV_LSC_XGRAD_4
#define MRV_LSC_XGRAD_4_MASK 0x00000FFFU
#define MRV_LSC_XGRAD_4_SHIFT 0U

//! Register: isp_lsc_xgrad_67: Gradient table x (0x00000030)
//! Slice: xgrad_7:
//! factor for x-gradient calculation of sector 7
#define MRV_LSC_XGRAD_7
#define MRV_LSC_XGRAD_7_MASK 0x0FFF0000U
#define MRV_LSC_XGRAD_7_SHIFT 16U
//! Slice: xgrad_6:
//! factor for x-gradient calculation of sector 6
#define MRV_LSC_XGRAD_6
#define MRV_LSC_XGRAD_6_MASK 0x00000FFFU
#define MRV_LSC_XGRAD_6_SHIFT 0U

//! Register: isp_lsc_ygrad_01: Gradient table y (0x00000034)
//! Slice: ygrad_1:
//! factor for y-gradient calculation of sector 1
#define MRV_LSC_YGRAD_1
#define MRV_LSC_YGRAD_1_MASK 0x0FFF0000U
#define MRV_LSC_YGRAD_1_SHIFT 16U
//! Slice: ygrad_0:
//! factor for y-gradient calculation of sector 0
#define MRV_LSC_YGRAD_0
#define MRV_LSC_YGRAD_0_MASK 0x00000FFFU
#define MRV_LSC_YGRAD_0_SHIFT 0U

//! Register: isp_lsc_ygrad_23: Gradient table y (0x00000038)
//! Slice: ygrad_3:
//! factor for y-gradient calculation of sector 3
#define MRV_LSC_YGRAD_3
#define MRV_LSC_YGRAD_3_MASK 0x0FFF0000U
#define MRV_LSC_YGRAD_3_SHIFT 16U
//! Slice: ygrad_2:
//! factor for y-gradient calculation of sector 2
#define MRV_LSC_YGRAD_2
#define MRV_LSC_YGRAD_2_MASK 0x00000FFFU
#define MRV_LSC_YGRAD_2_SHIFT 0U

//! Register: isp_lsc_ygrad_45: Gradient table y (0x0000003c)
//! Slice: ygrad_5:
//! factor for y-gradient calculation of sector 5
#define MRV_LSC_YGRAD_5
#define MRV_LSC_YGRAD_5_MASK 0x0FFF0000U
#define MRV_LSC_YGRAD_5_SHIFT 16U
//! Slice: ygrad_4:
//! factor for y-gradient calculation of sector 4
#define MRV_LSC_YGRAD_4
#define MRV_LSC_YGRAD_4_MASK 0x00000FFFU
#define MRV_LSC_YGRAD_4_SHIFT 0U

//! Register: isp_lsc_ygrad_67: Gradient table y (0x00000040)
//! Slice: ygrad_7:
//! factor for y-gradient calculation of sector 7
#define MRV_LSC_YGRAD_7
#define MRV_LSC_YGRAD_7_MASK 0x0FFF0000U
#define MRV_LSC_YGRAD_7_SHIFT 16U
//! Slice: ygrad_6:
//! factor for y-gradient calculation of sector 6
#define MRV_LSC_YGRAD_6
#define MRV_LSC_YGRAD_6_MASK 0x00000FFFU
#define MRV_LSC_YGRAD_6_SHIFT 0U

//! Register: isp_lsc_xsize_01: Size table (0x00000044)
//! Slice: x_sect_size_1:
//! sector size 1 in x-direction
#define MRV_LSC_X_SECT_SIZE_1
#define MRV_LSC_X_SECT_SIZE_1_MASK 0x03FF0000U
#define MRV_LSC_X_SECT_SIZE_1_SHIFT 16U
//! Slice: x_sect_size_0:
//! sector size 0 in x-direction
#define MRV_LSC_X_SECT_SIZE_0
#define MRV_LSC_X_SECT_SIZE_0_MASK 0x000003FFU
#define MRV_LSC_X_SECT_SIZE_0_SHIFT 0U

//! Register: isp_lsc_xsize_23: Size table (0x00000048)
//! Slice: x_sect_size_3:
//! sector size 3 in x-direction
#define MRV_LSC_X_SECT_SIZE_3
#define MRV_LSC_X_SECT_SIZE_3_MASK 0x03FF0000U
#define MRV_LSC_X_SECT_SIZE_3_SHIFT 16U
//! Slice: x_sect_size_2:
//! sector size 2 in x-direction
#define MRV_LSC_X_SECT_SIZE_2
#define MRV_LSC_X_SECT_SIZE_2_MASK 0x000003FFU
#define MRV_LSC_X_SECT_SIZE_2_SHIFT 0U

//! Register: isp_lsc_xsize_45: Size table (0x0000004c)
//! Slice: x_sect_size_5:
//! sector size 5 in x-direction
#define MRV_LSC_X_SECT_SIZE_5
#define MRV_LSC_X_SECT_SIZE_5_MASK 0x03FF0000U
#define MRV_LSC_X_SECT_SIZE_5_SHIFT 16U
//! Slice: x_sect_size_4:
//! sector size 4in x-direction
#define MRV_LSC_X_SECT_SIZE_4
#define MRV_LSC_X_SECT_SIZE_4_MASK 0x000003FFU
#define MRV_LSC_X_SECT_SIZE_4_SHIFT 0U

//! Register: isp_lsc_xsize_67: Size table (0x00000050)
//! Slice: x_sect_size_7:
//! sector size 7 in x-direction
#define MRV_LSC_X_SECT_SIZE_7
#define MRV_LSC_X_SECT_SIZE_7_MASK 0x03FF0000U
#define MRV_LSC_X_SECT_SIZE_7_SHIFT 16U
//! Slice: x_sect_size_6:
//! sector size 6 in x-direction
#define MRV_LSC_X_SECT_SIZE_6
#define MRV_LSC_X_SECT_SIZE_6_MASK 0x000003FFU
#define MRV_LSC_X_SECT_SIZE_6_SHIFT 0U

//! Register: isp_lsc_ysize_01: Size table (0x00000054)
//! Slice: y_sect_size_1:
//! sector size 1 in y-direction
#define MRV_LSC_Y_SECT_SIZE_1
#define MRV_LSC_Y_SECT_SIZE_1_MASK 0x03FF0000U
#define MRV_LSC_Y_SECT_SIZE_1_SHIFT 16U
//! Slice: y_sect_size_0:
//! sector size 0 in y-direction
#define MRV_LSC_Y_SECT_SIZE_0
#define MRV_LSC_Y_SECT_SIZE_0_MASK 0x000003FFU
#define MRV_LSC_Y_SECT_SIZE_0_SHIFT 0U

//! Register: isp_lsc_ysize_23: Size table (0x00000058)
//! Slice: y_sect_size_3:
//! sector size 3 in y-direction
#define MRV_LSC_Y_SECT_SIZE_3
#define MRV_LSC_Y_SECT_SIZE_3_MASK 0x03FF0000U
#define MRV_LSC_Y_SECT_SIZE_3_SHIFT 16U
//! Slice: y_sect_size_2:
//! sector size 2 in y-direction
#define MRV_LSC_Y_SECT_SIZE_2
#define MRV_LSC_Y_SECT_SIZE_2_MASK 0x000003FFU
#define MRV_LSC_Y_SECT_SIZE_2_SHIFT 0U

//! Register: isp_lsc_ysize_45: Size table (0x0000005c)
//! Slice: y_sect_size_5:
//! sector size 5 in y-direction
#define MRV_LSC_Y_SECT_SIZE_5
#define MRV_LSC_Y_SECT_SIZE_5_MASK 0x03FF0000U
#define MRV_LSC_Y_SECT_SIZE_5_SHIFT 16U
//! Slice: y_sect_size_4:
//! sector size 4 in y-direction
#define MRV_LSC_Y_SECT_SIZE_4
#define MRV_LSC_Y_SECT_SIZE_4_MASK 0x000003FFU
#define MRV_LSC_Y_SECT_SIZE_4_SHIFT 0U

//! Register: isp_lsc_ysize_67: Size table (0x00000060)
//! Slice: y_sect_size_7:
//! sector size 7 in y-direction
#define MRV_LSC_Y_SECT_SIZE_7
#define MRV_LSC_Y_SECT_SIZE_7_MASK 0x03FF0000U
#define MRV_LSC_Y_SECT_SIZE_7_SHIFT 16U
//! Slice: y_sect_size_6:
//! sector size 6 in y-direction
#define MRV_LSC_Y_SECT_SIZE_6
#define MRV_LSC_Y_SECT_SIZE_6_MASK 0x000003FFU
#define MRV_LSC_Y_SECT_SIZE_6_SHIFT 0U

//! Register: isp_lsc_table_sel: Lens shade table set selection (0x00000064)
//! Slice: table_sel:
//! 0: next active tables set is table set 0.  
// 1: next active tables set is table set 1.  
// Table selection is object of a shadowing mechnism. The current status is visible at ISP_LSC_STATUS::active_table.
#define MRV_LSC_TABLE_SEL
#define MRV_LSC_TABLE_SEL_MASK 0x00000001U
#define MRV_LSC_TABLE_SEL_SHIFT 0U

//! Register: isp_lsc_status: Lens shade status (0x00000068)
//! Slice: active_table:
//! 0: currently active tables set is table set 0 
// 1: currently active tables set is table set 1
#define MRV_LSC_ACTIVE_TABLE
#define MRV_LSC_ACTIVE_TABLE_MASK 0x00000002U
#define MRV_LSC_ACTIVE_TABLE_SHIFT 1U
//! Slice: lsc_en_status:
//! 0: lens shading correction is currently off 
// 1: lens shading correction is currently on
#define MRV_LSC_LSC_EN_STATUS
#define MRV_LSC_LSC_EN_STATUS_MASK 0x00000001U
#define MRV_LSC_LSC_EN_STATUS_SHIFT 0U

//! Register: isp_is_ctrl: Image Stabilization Control Register (0x00000000)
//! Slice: is_en:
//! 1: image stabilization switched on 
// 0: image stabilization switched off
#define MRV_IS_IS_EN
#define MRV_IS_IS_EN_MASK 0x00000001U
#define MRV_IS_IS_EN_SHIFT 0U

//! Register: isp_is_recenter: Recenter register (0x00000004)
//! Slice: is_recenter:
//! 000: recenter feature switched off 
// 1..7: recentering by (cur_h/v_offs-H/V_OFFS)/2^RECENTER
#define MRV_IS_IS_RECENTER
#define MRV_IS_IS_RECENTER_MASK 0x00000007U
#define MRV_IS_IS_RECENTER_SHIFT 0U

//! Register: isp_is_h_offs: Horizontal offset of output window (0x00000008)
//! Slice: is_h_offs:
//! horizontal picture offset in pixel
#define MRV_IS_IS_H_OFFS
#define MRV_IS_IS_H_OFFS_MASK 0x00003FFFU
#define MRV_IS_IS_H_OFFS_SHIFT 0U

//! Register: isp_is_v_offs: Vertical offset of output window (0x0000000c)
//! Slice: is_v_offs:
//! vertical picture offset in lines
#define MRV_IS_IS_V_OFFS
#define MRV_IS_IS_V_OFFS_MASK 0x00003FFFU
#define MRV_IS_IS_V_OFFS_SHIFT 0U

//! Register: isp_is_h_size: Output horizontal picture size (0x00000010)
//! Slice: is_h_size:
//! horizontal picture size in pixel  
// if ISP_MODE is set to 
// 001-(ITU-R BT.656 YUV), 
// 010-( ITU-R BT.601 YUV), 
// 011-( ITU-R BT.601 Bayer RGB), 
// 101-( ITU-R BT.656 Bayer RGB) 
// only even numbers are accepted, because complete quadruples of YUYV(YCbYCr) are needed for the following modules. If an odd size is programmed the value will be truncated to even size.
#define MRV_IS_IS_H_SIZE
#define MRV_IS_IS_H_SIZE_MASK 0x00003FFFU
#define MRV_IS_IS_H_SIZE_SHIFT 0U

//! Register: isp_is_v_size: Output vertical picture size (0x00000014)
//! Slice: is_v_size:
//! vertical picture size in lines
#define MRV_IS_IS_V_SIZE
#define MRV_IS_IS_V_SIZE_MASK 0x00003FFFU
#define MRV_IS_IS_V_SIZE_SHIFT 0U

//! Register: isp_is_max_dx: Maximum Horizontal Displacement (0x00000018)
//! Slice: is_max_dx:
//! maximum allowed accumulated horizontal displacement in pixels
#define MRV_IS_IS_MAX_DX
#define MRV_IS_IS_MAX_DX_MASK 0x00001FFFU
#define MRV_IS_IS_MAX_DX_SHIFT 0U

//! Register: isp_is_max_dy: Maximum Vertical Displacement (0x0000001c)
//! Slice: is_max_dy:
//! maximum allowed accumulated vertical displacement in lines
#define MRV_IS_IS_MAX_DY
#define MRV_IS_IS_MAX_DY_MASK 0x00001FFFU
#define MRV_IS_IS_MAX_DY_SHIFT 0U

//! Register: isp_is_displace: Camera displacement (0x00000020)
//! Slice: dy:
//! ISP_IS will compensate for vertical camera displacement of DY lines in the next frame
#define MRV_IS_DY
#define MRV_IS_DY_MASK 0x1FFF0000U
#define MRV_IS_DY_SHIFT 16U
//! Slice: dx:
//! ISP_IS will compensate for horizontal camera displacement of DX pixels in the next frame
#define MRV_IS_DX
#define MRV_IS_DX_MASK 0x00001FFFU
#define MRV_IS_DX_SHIFT 0U

//! Register: isp_is_h_offs_shd: current horizontal offset of output window (shadow register) (0x00000024)
//! Slice: is_h_offs_shd:
//! current horizonatl picture offset in lines
#define MRV_IS_IS_H_OFFS_SHD
#define MRV_IS_IS_H_OFFS_SHD_MASK 0x00003FFFU
#define MRV_IS_IS_H_OFFS_SHD_SHIFT 0U

//! Register: isp_is_v_offs_shd: current vertical offset of output window (shadow register) (0x00000028)
//! Slice: is_v_offs_shd:
//! current vertical picture offset in lines
#define MRV_IS_IS_V_OFFS_SHD
#define MRV_IS_IS_V_OFFS_SHD_MASK 0x00003FFFU
#define MRV_IS_IS_V_OFFS_SHD_SHIFT 0U

//! Register: isp_is_h_size_shd: current output horizontal picture size (shadow register) (0x0000002c)
//! Slice: isp_h_size_shd:
//! current horizontal picture size in pixel
#define MRV_IS_ISP_H_SIZE_SHD
#define MRV_IS_ISP_H_SIZE_SHD_MASK 0x00003FFFU
#define MRV_IS_ISP_H_SIZE_SHD_SHIFT 0U

//! Register: isp_is_v_size_shd: current output vertical picture size (shadow register) (0x00000030)
//! Slice: isp_v_size_shd:
//! vertical picture size in lines
#define MRV_IS_ISP_V_SIZE_SHD
#define MRV_IS_ISP_V_SIZE_SHD_MASK 0x00003FFFU
#define MRV_IS_ISP_V_SIZE_SHD_SHIFT 0U

//! Register: isp_hist_prop: Histogram properties (0x00000000)
//! Slice: stepsize:
//! histogram predivider, process every (stepsize)th pixel, all other pixels are skipped 
// 0,1,2: not allowed 
// 3: process every third input pixel 
// 4: process every fourth input pixel 
// ... 
// 7FH: process every 127th pixel
#define MRV_HIST_STEPSIZE
#define MRV_HIST_STEPSIZE_MASK 0x000003F8U
#define MRV_HIST_STEPSIZE_SHIFT 3U
//! Slice: hist_mode:
//! histogram mode, luminance is taken at ISP output before output formatter, RGB is taken at xtalk output 
// 7, 6: must not be used 
// 5: Y (luminance) histogram 
// 4: B histogram 
// 3: G histogram 
// 2: R histogram 
// 1: RGB combined histogram 
// 0: disable, no measurements
#define MRV_HIST_MODE
#define MRV_HIST_MODE_MASK 0x00000007U
#define MRV_HIST_MODE_SHIFT 0U

//! Register: isp_hist_h_offs: Histogram window horizontal offset for first window of 25 sub-windows (0x00000004)
//! Slice: hist_h_offset:
//! Horizontal offset of first window in pixels.
#define MRV_HIST_H_OFFSET
#define MRV_HIST_H_OFFSET_MASK 0x00001FFFU
#define MRV_HIST_H_OFFSET_SHIFT 0U

//! Register: isp_hist_v_offs: Histogram window vertical offset for first window of 25 sub-windows (0x00000008)
//! Slice: hist_v_offset:
//! Vertical offset of first window in pixels.
#define MRV_HIST_V_OFFSET
#define MRV_HIST_V_OFFSET_MASK 0x00001FFFU
#define MRV_HIST_V_OFFSET_SHIFT 0U

//! Register: isp_hist_h_size: Horizontal (sub-)window size (0x0000000c)
//! Slice: hist_h_size:
//! Horizontal size in pixels of one sub-window, if histogram version 3 is implemented.
#define MRV_HIST_H_SIZE
#define MRV_HIST_H_SIZE_MASK 0x000007FFU
#define MRV_HIST_H_SIZE_SHIFT 0U

//! Register: isp_hist_v_size: Vertical (sub-)window size (0x00000010)
//! Slice: hist_v_size:
//! Vertical size in lines of one sub-window, if histogram version 3 is implemented.
#define MRV_HIST_V_SIZE
#define MRV_HIST_V_SIZE_MASK 0x000007FFU
#define MRV_HIST_V_SIZE_SHIFT 0U

//! Register array: isp_hist_bin: histogram measurement result bin (0x028 + n*0x4 (n=0..15))
//! Slice: hist_bin_n:
// measured bin count as 16-bit unsigned integer value plus 4 bit fractional part
#define MRV_HIST_BIN_N
#define MRV_HIST_BIN_N_MASK 0x000FFFFFU
#define MRV_HIST_BIN_N_SHIFT 0U

//! Register: isp_hist_weight_00to30: Weighting factor for sub-windows (0x00000054)
//! Slice: hist_weight_30:
//! weighting factor for sub-window 30
#define MRV_HIST_WEIGHT_30
#define MRV_HIST_WEIGHT_30_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_30_SHIFT 24U
//! Slice: hist_weight_20:
//! weighting factor for sub-window 20
#define MRV_HIST_WEIGHT_20
#define MRV_HIST_WEIGHT_20_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_20_SHIFT 16U
//! Slice: hist_weight_10:
//! weighting factor for sub-window 10
#define MRV_HIST_WEIGHT_10
#define MRV_HIST_WEIGHT_10_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_10_SHIFT 8U
//! Slice: hist_weight_00:
//! weighting factor for sub-window 00
#define MRV_HIST_WEIGHT_00
#define MRV_HIST_WEIGHT_00_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_00_SHIFT 0U

//! Register: isp_hist_weight_40to21: Weighting factor for sub-windows (0x00000058)
//! Slice: hist_weight_21:
//! weighting factor for sub-window 21
#define MRV_HIST_WEIGHT_21
#define MRV_HIST_WEIGHT_21_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_21_SHIFT 24U
//! Slice: hist_weight_11:
//! weighting factor for sub-window 11
#define MRV_HIST_WEIGHT_11
#define MRV_HIST_WEIGHT_11_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_11_SHIFT 16U
//! Slice: hist_weight_01:
//! weighting factor for sub-window 01
#define MRV_HIST_WEIGHT_01
#define MRV_HIST_WEIGHT_01_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_01_SHIFT 8U
//! Slice: hist_weight_40:
//! weighting factor for sub-window 40
#define MRV_HIST_WEIGHT_40
#define MRV_HIST_WEIGHT_40_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_40_SHIFT 0U

//! Register: isp_hist_weight_31to12: Weighting factor for sub-windows (0x0000005c)
//! Slice: hist_weight_12:
//! weighting factor for sub-window 12
#define MRV_HIST_WEIGHT_12
#define MRV_HIST_WEIGHT_12_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_12_SHIFT 24U
//! Slice: hist_weight_02:
//! weighting factor for sub-window 02
#define MRV_HIST_WEIGHT_02
#define MRV_HIST_WEIGHT_02_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_02_SHIFT 16U
//! Slice: hist_weight_41:
//! weighting factor for sub-window 41
#define MRV_HIST_WEIGHT_41
#define MRV_HIST_WEIGHT_41_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_41_SHIFT 8U
//! Slice: hist_weight_31:
//! weighting factor for sub-window 31
#define MRV_HIST_WEIGHT_31
#define MRV_HIST_WEIGHT_31_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_31_SHIFT 0U

//! Register: isp_hist_weight_22to03: Weighting factor for sub-windows (0x00000060)
//! Slice: hist_weight_03:
//! weighting factor for sub-window 03
#define MRV_HIST_WEIGHT_03
#define MRV_HIST_WEIGHT_03_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_03_SHIFT 24U
//! Slice: hist_weight_42:
//! weighting factor for sub-window 42
#define MRV_HIST_WEIGHT_42
#define MRV_HIST_WEIGHT_42_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_42_SHIFT 16U
//! Slice: hist_weight_32:
//! weighting factor for sub-window 32
#define MRV_HIST_WEIGHT_32
#define MRV_HIST_WEIGHT_32_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_32_SHIFT 8U
//! Slice: hist_weight_22:
//! weighting factor for sub-window 22
#define MRV_HIST_WEIGHT_22
#define MRV_HIST_WEIGHT_22_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_22_SHIFT 0U

//! Register: isp_hist_weight_13to43: Weighting factor for sub-windows (0x00000064)
//! Slice: hist_weight_43:
//! weighting factor for sub-window 43
#define MRV_HIST_WEIGHT_43
#define MRV_HIST_WEIGHT_43_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_43_SHIFT 24U
//! Slice: hist_weight_33:
//! weighting factor for sub-window 33
#define MRV_HIST_WEIGHT_33
#define MRV_HIST_WEIGHT_33_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_33_SHIFT 16U
//! Slice: hist_weight_23:
//! weighting factor for sub-window 23
#define MRV_HIST_WEIGHT_23
#define MRV_HIST_WEIGHT_23_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_23_SHIFT 8U
//! Slice: hist_weight_13:
//! weighting factor for sub-window 13
#define MRV_HIST_WEIGHT_13
#define MRV_HIST_WEIGHT_13_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_13_SHIFT 0U

//! Register: isp_hist_weight_04to34: Weighting factor for sub-windows (0x00000068)
//! Slice: hist_weight_34:
//! weighting factor for sub-window 34
#define MRV_HIST_WEIGHT_34
#define MRV_HIST_WEIGHT_34_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_34_SHIFT 24U
//! Slice: hist_weight_24:
//! weighting factor for sub-window 24
#define MRV_HIST_WEIGHT_24
#define MRV_HIST_WEIGHT_24_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_24_SHIFT 16U
//! Slice: hist_weight_14:
//! weighting factor for sub-window 14
#define MRV_HIST_WEIGHT_14
#define MRV_HIST_WEIGHT_14_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_14_SHIFT 8U
//! Slice: hist_weight_04:
//! weighting factor for sub-window 04
#define MRV_HIST_WEIGHT_04
#define MRV_HIST_WEIGHT_04_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_04_SHIFT 0U

//! Register: isp_hist_weight_44: Weighting factor for sub-windows (0x0000006c)
//! Slice: hist_weight_44:
//! weighting factor for sub-window 44
#define MRV_HIST_WEIGHT_44
#define MRV_HIST_WEIGHT_44_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_44_SHIFT 0U

//! Register: isp_filt_mode: mode control register for the filter block (0x00000000)
//! Slice: stage1_select:
//! Green filter stage 1 select (range 0x0...0x8) 
// 0x0 maximum blurring 
// 0x4 Default 
// 0x7 minimum blurring 
// 0x8 filter stage1 bypass 
// For a detailed description refer to chapter "ISP Filter Programming" of user manual
#define MRV_FILT_STAGE1_SELECT
#define MRV_FILT_STAGE1_SELECT_MASK 0x00000F00U
#define MRV_FILT_STAGE1_SELECT_SHIFT 8U
//! Slice: filt_chr_h_mode:
//! Chroma filter horizontal mode 
// 00 horizontal chroma filter bypass 
// 01 horizontal chroma filter 1 static mask = [10 12 10] 
// 10 horizontal chroma filter 2 (dynamic blur1) 
// 11 horizontal chroma filter 3 (dynamic blur2) Default
#define MRV_FILT_FILT_CHR_H_MODE
#define MRV_FILT_FILT_CHR_H_MODE_MASK 0x000000C0U
#define MRV_FILT_FILT_CHR_H_MODE_SHIFT 6U
//! Slice: filt_chr_v_mode:
//! Chroma filter vertical mode 
// 00 vertical chroma filter bypass 
// 01 vertical chroma filter 1 static [8 16 8] 
// 10 vertical chroma filter 2 static [10 12 10] 
// 11 vertical chroma filter 3 static [12 8 12] Default
#define MRV_FILT_FILT_CHR_V_MODE
#define MRV_FILT_FILT_CHR_V_MODE_MASK 0x00000030U
#define MRV_FILT_FILT_CHR_V_MODE_SHIFT 4U
//! Slice: filt_mode:
//! 0 green filter static mode (active filter factor = FILT_FAC_MID) 
// 1 dynamic noise reduction/sharpen Default
#define MRV_FILT_FILT_MODE
#define MRV_FILT_FILT_MODE_MASK 0x00000002U
#define MRV_FILT_FILT_MODE_SHIFT 1U
//! Slice: filt_enable:
//! 1 enable filter 
// 0 bypass filter Default
#define MRV_FILT_FILT_ENABLE
#define MRV_FILT_FILT_ENABLE_MASK 0x00000001U
#define MRV_FILT_FILT_ENABLE_SHIFT 0U

//! Register: isp_filt_thresh_bl0: Blurring threshold 0 (0x00000028)
//! Slice: filt_thresh_bl0:
//! If filt_thresh_bl1 < sum_grad < filt_thresh_bl0 then filt_fac_bl0 is selected
#define MRV_FILT_FILT_THRESH_BL0
#define MRV_FILT_FILT_THRESH_BL0_MASK 0x000003FFU
#define MRV_FILT_FILT_THRESH_BL0_SHIFT 0U

//! Register: isp_filt_thresh_bl1: Blurring threshold 1 (0x0000002c)
//! Slice: filt_thresh_bl1:
//! If sum_grad < filt_thresh_bl1 then filt_fac_bl1 is selected
#define MRV_FILT_FILT_THRESH_BL1
#define MRV_FILT_FILT_THRESH_BL1_MASK 0x000003FFU
#define MRV_FILT_FILT_THRESH_BL1_SHIFT 0U

//! Register: isp_filt_thresh_sh0: Sharpening threshold 0 (0x00000030)
//! Slice: filt_thresh_sh0:
//! If filt_thresh_sh0 < sum_grad < filt_thresh_sh1 then filt_thresh_sh0 is selected
#define MRV_FILT_FILT_THRESH_SH0
#define MRV_FILT_FILT_THRESH_SH0_MASK 0x000003FFU
#define MRV_FILT_FILT_THRESH_SH0_SHIFT 0U

//! Register: isp_filt_thresh_sh1: Sharpening threshold 1 (0x00000034)
//! Slice: filt_thresh_sh1:
//! If filt_thresh_sh1 < sum_grad then filt_thresh_sh1 is selected
#define MRV_FILT_FILT_THRESH_SH1
#define MRV_FILT_FILT_THRESH_SH1_MASK 0x000003FFU
#define MRV_FILT_FILT_THRESH_SH1_SHIFT 0U

//! Register: isp_filt_lum_weight: Parameters for luminance weight function (0x00000038)
//! Slice: lum_weight_gain:
//! Gain select of luminance weight function
#define MRV_FILT_LUM_WEIGHT_GAIN
#define MRV_FILT_LUM_WEIGHT_GAIN_MASK 0x00070000U
#define MRV_FILT_LUM_WEIGHT_GAIN_SHIFT 16U
//! Slice: lum_weight_kink:
//! Kink position of luminance weight function
#define MRV_FILT_LUM_WEIGHT_KINK
#define MRV_FILT_LUM_WEIGHT_KINK_MASK 0x0000FF00U
#define MRV_FILT_LUM_WEIGHT_KINK_SHIFT 8U
//! Slice: lum_weight_min:
//! Minimum value of luminance weight function
#define MRV_FILT_LUM_WEIGHT_MIN
#define MRV_FILT_LUM_WEIGHT_MIN_MASK 0x000000FFU
#define MRV_FILT_LUM_WEIGHT_MIN_SHIFT 0U

//! Register: isp_filt_fac_sh1: filter factor sharp1 (0x0000003c)
//! Slice: filt_fac_sh1:
//! Filter factor for sharp1 level
#define MRV_FILT_FILT_FAC_SH1
#define MRV_FILT_FILT_FAC_SH1_MASK 0x0000003FU
#define MRV_FILT_FILT_FAC_SH1_SHIFT 0U

//! Register: isp_filt_fac_sh0: filter factor sharp0 (0x00000040)
//! Slice: filt_fac_sh0:
//! Filter factor for sharp0 level
#define MRV_FILT_FILT_FAC_SH0
#define MRV_FILT_FILT_FAC_SH0_MASK 0x0000003FU
#define MRV_FILT_FILT_FAC_SH0_SHIFT 0U

//! Register: isp_filt_fac_mid: filter factor middle (0x00000044)
//! Slice: filt_fac_mid:
//! Filter factor for mid level and for static filter mode
#define MRV_FILT_FILT_FAC_MID
#define MRV_FILT_FILT_FAC_MID_MASK 0x0000003FU
#define MRV_FILT_FILT_FAC_MID_SHIFT 0U

//! Register: isp_filt_fac_bl0: Parameter for blur 0 filter (0x00000048)
//! Slice: filt_fac_bl0:
//! Filter factor for blur 0 level
#define MRV_FILT_FILT_FAC_BL0
#define MRV_FILT_FILT_FAC_BL0_MASK 0x0000003FU
#define MRV_FILT_FILT_FAC_BL0_SHIFT 0U

//! Register: isp_filt_fac_bl1: Parameter for blur 1 filter (0x0000004c)
//! Slice: filt_fac_bl1:
//! Filter factor for blur 1 level (max blur)
#define MRV_FILT_FILT_FAC_BL1
#define MRV_FILT_FILT_FAC_BL1_MASK 0x0000003FU
#define MRV_FILT_FILT_FAC_BL1_SHIFT 0U

//! Register: isp_cac_ctrl: Control register for chromatic aberration correction (0x00000000)
//! Slice: h_clip_mode:
//! Defines the maximum red/blue pixel shift in horizontal direction At pixel positions, that require a larger displacement, the maximum shift value is used instead (vector clipping) 
// 0: Set horizontal vector clipping to +/-4 pixel displacement (Default) 
// 1: Set horizontal vector clipping to +/-4 or +/-5 pixel displacement depending on pixel position inside the Bayer raster (dynamic switching between +/-4 and +/-5)
#define MRV_CAC_H_CLIP_MODE
#define MRV_CAC_H_CLIP_MODE_MASK 0x00000008U
#define MRV_CAC_H_CLIP_MODE_SHIFT 3U
//! Slice: v_clip_mode:
//! Defines the maximum red/blue pixel shift in vertical direction 
// 00: Set vertical vector clipping to +/-2 pixel ; fix filter_enable (Default) 
// 01: Set vertical vector clipping to +/-3 pixel; dynamic filter_enable for chroma low pass filter 
// 10: Set vertical vector clipping +/-3 or +/-4 pixel displacement depending on pixel position inside the Bayer raster (dynamic switching between +/-3 and +/-4) 
// 11: reserved
#define MRV_CAC_V_CLIP_MODE
#define MRV_CAC_V_CLIP_MODE_MASK 0x00000006U
#define MRV_CAC_V_CLIP_MODE_SHIFT 1U
//! Slice: cac_en:
//! 0: chromatic aberration correction off 
// 1: chromatic aberration correction on
#define MRV_CAC_CAC_EN
#define MRV_CAC_CAC_EN_MASK 0x00000001U
#define MRV_CAC_CAC_EN_SHIFT 0U

//! Register: isp_cac_count_start: Preload values for CAC pixel and line counter (0x00000004)
//! Slice: v_count_start:
//! 13 bit v_count preload value (range 8191 ... 1) of the vertical CAC line counter. Before frame start v_count has to be preloaded with (v_size/2 + v_center_offset), with 
// v_size the image height and 
// v_center_offset the vertical distance between image center and optical center. 
// 
// After frame start the v_count decrements with every line until a value of zero is reached for the line in the optical center. Than the v_sign bit toggles and the v_counter decrements with every line until end of frame.
#define MRV_CAC_V_COUNT_START
#define MRV_CAC_V_COUNT_START_MASK 0x1FFF0000U
#define MRV_CAC_V_COUNT_START_SHIFT 16U
//! Slice: h_count_start:
//! 13 bit h_count preload value (range 8191 .. 1) of the horizontal CAC pixel counter. Before line start h_count has to be preloaded with (h_size/2 + h_center_offset), with 
// h_size the image width and 
// h_center_offset the horizontal distance between image center and optical center. 
// 
// After line start the h_count decrements with every pixel until a value of zero is reached for the column in the optical center. Than the h_sign bit toggles and the h_counter increments with every pixel until end of line.
#define MRV_CAC_H_COUNT_START
#define MRV_CAC_H_COUNT_START_MASK 0x00001FFFU
#define MRV_CAC_H_COUNT_START_SHIFT 0U

//! Register: isp_cac_a: Linear Parameters for radial shift calculation (0x00000008)
//! Slice: A_Blue:
//! Parameter A_Blue for radial blue shift calculation, according to 
//(A_Blue * r  + B_Blue * r^2 + C_Blue * r^3). 
// It is a 9 bit twos complement integer with 4 fractional digits value and value range from -16 up to 15.9375.
#define MRV_CAC_A_BLUE
#define MRV_CAC_A_BLUE_MASK 0x01FF0000U
#define MRV_CAC_A_BLUE_SHIFT 16U
//! Slice: A_Red:
//! Parameter A_Red for radial red shift calculation, according to 
//(A_Red * r + B_Red * r^2 + C_Red * r^3). 
// It is a 9 bit twos complement integer with 4 fractional digits value and value range from -16 up to 15.9375.
#define MRV_CAC_A_RED
#define MRV_CAC_A_RED_MASK 0x000001FFU
#define MRV_CAC_A_RED_SHIFT 0U

//! Register: isp_cac_b: Square Parameters for radial shift calculation (0x0000000c)
//! Slice: B_Blue:
//! Parameter B_Blue for radial blue shift calculation, according to 
//(A_Blue * r  + B_Blue * r^2 + C_Blue * r^3). 
// It is a 9 bit twos complement integer with 4 fractional digits value and value range from -16 up to 15.9375.
#define MRV_CAC_B_BLUE
#define MRV_CAC_B_BLUE_MASK 0x01FF0000U
#define MRV_CAC_B_BLUE_SHIFT 16U
//! Slice: B_Red:
//! Parameter B_Red for radial red shift calculation, according to 
//(A_Red * r + B_Red * r^2 + C_Red * r^3). 
// It is a 9 bit twos complement integer with 4 fractional digits value and value range from -16 up to 15.9375.
#define MRV_CAC_B_RED
#define MRV_CAC_B_RED_MASK 0x000001FFU
#define MRV_CAC_B_RED_SHIFT 0U

//! Register: isp_cac_c: Cubical Parameters for radial shift calculation (0x00000010)
//! Slice: C_Blue:
//! Parameter C_Blue for radial blue shift calculation, according to 
//(A_Blue * r  + B_Blue * r^2 + C_Blue * r^3). 
// It is a 9 bit twos complement integer with 4 fractional digits value and value range from -16 up to 15.9375.
#define MRV_CAC_C_BLUE
#define MRV_CAC_C_BLUE_MASK 0x01FF0000U
#define MRV_CAC_C_BLUE_SHIFT 16U
//! Slice: C_Red:
//! Parameter C_Red for radial red shift calculation, according to 
//(A_Red * r + B_Red * r^2 + C_Red * r^3). 
// It is a 9 bit twos complement integer with 4 fractional digits value and value range from -16 up to 15.9375.
#define MRV_CAC_C_RED
#define MRV_CAC_C_RED_MASK 0x000001FFU
#define MRV_CAC_C_RED_SHIFT 0U

//! Register: isp_cac_x_norm: Normalization parameters for calculation of image coordinate x_d relative to optical center (0x00000014)
//! Slice: x_ns:
//! Horizontal normalization shift parameter x_ns (4 bit unsigned integer) in equation 
// x_d[7:0] = (((h_count <% 4) %> x_ns) * x_nf) >> 5
#define MRV_CAC_X_NS
#define MRV_CAC_X_NS_MASK 0x000F0000U
#define MRV_CAC_X_NS_SHIFT 16U
//! Slice: x_nf:
//! Horizontal scaling or normalization factor x_nf (5 bit unsigned integer) range 0 .. 31 in equation 
// x_d[7:0] = (((h_count <% 4) %> x_ns) * x_nf) >> 5
#define MRV_CAC_X_NF
#define MRV_CAC_X_NF_MASK 0x0000001FU
#define MRV_CAC_X_NF_SHIFT 0U

//! Register: isp_cac_y_norm: Normalization parameters for calculation of image coordinate y_d relative to optical center (0x00000018)
//! Slice: y_ns:
//! Vertical normalization shift parameter y_ns (4 bit unsigned integer) in equation 
// y_d[7:0] = (((v_count <% 4) %> y_ns) * y_nf) >> 5
#define MRV_CAC_Y_NS
#define MRV_CAC_Y_NS_MASK 0x000F0000U
#define MRV_CAC_Y_NS_SHIFT 16U
//! Slice: y_nf:
//! Vertical scaling or normalization factor y_nf (5 bit unsigned integer) range 0 .. 31 in equation 
// y_d[7:0] = (((v_count <% 4) %> y_ns) * y_nf) >> 5
#define MRV_CAC_Y_NF
#define MRV_CAC_Y_NF_MASK 0x0000001FU
#define MRV_CAC_Y_NF_SHIFT 0U

//! Register: isp_exp_ctrl: Exposure control (0x00000000)
//! Slice: exp_meas_mode:
//! '1' luminance calculation according to 
// Y=(R+G+B) x 0.332 (85/256) 
// '0' luminance calculation according to Y=16+0.25R+0.5G+0.1094B
#define MRV_AE_EXP_MEAS_MODE
#define MRV_AE_EXP_MEAS_MODE_MASK 0x80000000U
#define MRV_AE_EXP_MEAS_MODE_SHIFT 31U
//! Slice: autostop:
//! '1' stop measuring after a complete frame 
// '0' continous measurement
#define MRV_AE_AUTOSTOP
#define MRV_AE_AUTOSTOP_MASK 0x00000002U
#define MRV_AE_AUTOSTOP_SHIFT 1U
//! Slice: exp_start:
//! '1' start measuring a frame. The exp block will reset this bit and halt after completing one frame, if bit "autostop" is set to '1'.
#define MRV_AE_EXP_START
#define MRV_AE_EXP_START_MASK 0x00000001U
#define MRV_AE_EXP_START_SHIFT 0U

//! Register: isp_exp_h_offset: Horizontal offset for first block (0x00000004)
//! Slice: isp_exp_h_offset:
//! Horizontal offset of first block in pixels. 
// 0 <= value <= 2424
#define MRV_AE_ISP_EXP_H_OFFSET
#define MRV_AE_ISP_EXP_H_OFFSET_MASK 0x00001FFFU
#define MRV_AE_ISP_EXP_H_OFFSET_SHIFT 0U

//! Register: isp_exp_v_offset: Vertical offset for first block (0x00000008)
//! Slice: isp_exp_v_offset:
//! Vertical offset of first block in pixels. 
// 0 <= value <= 1806
#define MRV_AE_ISP_EXP_V_OFFSET
#define MRV_AE_ISP_EXP_V_OFFSET_MASK 0x00001FFFU
#define MRV_AE_ISP_EXP_V_OFFSET_SHIFT 0U

//! Register: isp_exp_h_size: Horizontal size of one block (0x0000000c)
//! Slice: isp_exp_h_size:
//! Horizontal size in pixels of one block. 
// 35 <= value <= 516
#define MRV_AE_ISP_EXP_H_SIZE
#define MRV_AE_ISP_EXP_H_SIZE_MASK 0x000007FFU
#define MRV_AE_ISP_EXP_H_SIZE_SHIFT 0U

//! Register: isp_exp_v_size: Vertical size of one block (0x00000010)
//! Slice: isp_exp_v_size:
//! Vertical size in pixels of one block. 
// 28 <= value <= 390
#define MRV_AE_ISP_EXP_V_SIZE
#define MRV_AE_ISP_EXP_V_SIZE_MASK 0x000007FEU
#define MRV_AE_ISP_EXP_V_SIZE_SHIFT 0U

//! Register: isp_exp_mean_00: Mean luminance value of block 00 (0x00000014)
//! Slice: isp_exp_mean_00:
//! Mean luminance value of block 00 (x,y)
#define MRV_AE_ISP_EXP_MEAN_00
#define MRV_AE_ISP_EXP_MEAN_00_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_00_SHIFT 0U

//! Register: isp_exp_mean_10: Mean luminance value of block 10 (0x00000018)
//! Slice: isp_exp_mean_10:
//! Mean luminance value of block 10 (x,y)
#define MRV_AE_ISP_EXP_MEAN_10
#define MRV_AE_ISP_EXP_MEAN_10_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_10_SHIFT 0U

//! Register: isp_exp_mean_20: Mean luminance value of block 20 (0x0000001c)
//! Slice: isp_exp_mean_20:
//! Mean luminance value of block 20 (x,y)
#define MRV_AE_ISP_EXP_MEAN_20
#define MRV_AE_ISP_EXP_MEAN_20_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_20_SHIFT 0U

//! Register: isp_exp_mean_30: Mean luminance value of block 30 (0x00000020)
//! Slice: isp_exp_mean_30:
//! Mean luminance value of block 30 (x,y)
#define MRV_AE_ISP_EXP_MEAN_30
#define MRV_AE_ISP_EXP_MEAN_30_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_30_SHIFT 0U

//! Register: isp_exp_mean_40: Mean luminance value of block 40 (0x00000024)
//! Slice: isp_exp_mean_40:
//! Mean luminance value of block 40 (x,y)
#define MRV_AE_ISP_EXP_MEAN_40
#define MRV_AE_ISP_EXP_MEAN_40_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_40_SHIFT 0U

//! Register: isp_exp_mean_01: Mean luminance value of block 01 (0x00000028)
//! Slice: isp_exp_mean_01:
//! Mean luminance value of block 01 (x,y)
#define MRV_AE_ISP_EXP_MEAN_01
#define MRV_AE_ISP_EXP_MEAN_01_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_01_SHIFT 0U

//! Register: isp_exp_mean_11: Mean luminance value of block 11 (0x0000002c)
//! Slice: isp_exp_mean_11:
//! Mean luminance value of block 11 (x,y)
#define MRV_AE_ISP_EXP_MEAN_11
#define MRV_AE_ISP_EXP_MEAN_11_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_11_SHIFT 0U

//! Register: isp_exp_mean_21: Mean luminance value of block 21 (0x00000030)
//! Slice: isp_exp_mean_21:
//! Mean luminance value of block 21 (x,y)
#define MRV_AE_ISP_EXP_MEAN_21
#define MRV_AE_ISP_EXP_MEAN_21_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_21_SHIFT 0U

//! Register: isp_exp_mean_31: Mean luminance value of block 31 (0x00000034)
//! Slice: isp_exp_mean_31:
//! Mean luminance value of block 31 (x,y)
#define MRV_AE_ISP_EXP_MEAN_31
#define MRV_AE_ISP_EXP_MEAN_31_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_31_SHIFT 0U

//! Register: isp_exp_mean_41: Mean luminance value of block 41 (0x00000038)
//! Slice: isp_exp_mean_41:
//! Mean luminance value of block 41 (x,y)
#define MRV_AE_ISP_EXP_MEAN_41
#define MRV_AE_ISP_EXP_MEAN_41_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_41_SHIFT 0U

//! Register: isp_exp_mean_02: Mean luminance value of block 02 (0x0000003c)
//! Slice: isp_exp_mean_02:
//! Mean luminance value of block 02 (x,y)
#define MRV_AE_ISP_EXP_MEAN_02
#define MRV_AE_ISP_EXP_MEAN_02_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_02_SHIFT 0U

//! Register: isp_exp_mean_12: Mean luminance value of block 12 (0x00000040)
//! Slice: isp_exp_mean_12:
//! Mean luminance value of block 12 (x,y)
#define MRV_AE_ISP_EXP_MEAN_12
#define MRV_AE_ISP_EXP_MEAN_12_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_12_SHIFT 0U

//! Register: isp_exp_mean_22: Mean luminance value of block 22 (0x00000044)
//! Slice: isp_exp_mean_22:
//! Mean luminance value of block 22 (x,y)
#define MRV_AE_ISP_EXP_MEAN_22
#define MRV_AE_ISP_EXP_MEAN_22_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_22_SHIFT 0U

//! Register: isp_exp_mean_32: Mean luminance value of block 32 (0x00000048)
//! Slice: isp_exp_mean_32:
//! Mean luminance value of block 32 (x,y)
#define MRV_AE_ISP_EXP_MEAN_32
#define MRV_AE_ISP_EXP_MEAN_32_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_32_SHIFT 0U

//! Register: isp_exp_mean_42: Mean luminance value of block 42 (0x0000004c)
//! Slice: isp_exp_mean_42:
//! Mean luminance value of block 42 (x,y)
#define MRV_AE_ISP_EXP_MEAN_42
#define MRV_AE_ISP_EXP_MEAN_42_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_42_SHIFT 0U

//! Register: isp_exp_mean_03: Mean luminance value of block 03 (0x00000050)
//! Slice: isp_exp_mean_03:
//! Mean luminance value of block 03 (x,y)
#define MRV_AE_ISP_EXP_MEAN_03
#define MRV_AE_ISP_EXP_MEAN_03_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_03_SHIFT 0U

//! Register: isp_exp_mean_13: Mean luminance value of block 13 (0x00000054)
//! Slice: isp_exp_mean_13:
//! Mean luminance value of block 13 (x,y)
#define MRV_AE_ISP_EXP_MEAN_13
#define MRV_AE_ISP_EXP_MEAN_13_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_13_SHIFT 0U

//! Register: isp_exp_mean_23: Mean luminance value of block 23 (0x00000058)
//! Slice: isp_exp_mean_23:
//! Mean luminance value of block 23 (x,y)
#define MRV_AE_ISP_EXP_MEAN_23
#define MRV_AE_ISP_EXP_MEAN_23_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_23_SHIFT 0U

//! Register: isp_exp_mean_33: Mean luminance value of block 33 (0x0000005c)
//! Slice: isp_exp_mean_33:
//! Mean luminance value of block 33 (x,y)
#define MRV_AE_ISP_EXP_MEAN_33
#define MRV_AE_ISP_EXP_MEAN_33_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_33_SHIFT 0U

//! Register: isp_exp_mean_43: Mean luminance value of block 43 (0x00000060)
//! Slice: isp_exp_mean_43:
//! Mean luminance value of block 43 (x,y)
#define MRV_AE_ISP_EXP_MEAN_43
#define MRV_AE_ISP_EXP_MEAN_43_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_43_SHIFT 0U

//! Register: isp_exp_mean_04: Mean luminance value of block 04 (0x00000064)
//! Slice: isp_exp_mean_04:
//! Mean luminance value of block 04 (x,y)
#define MRV_AE_ISP_EXP_MEAN_04
#define MRV_AE_ISP_EXP_MEAN_04_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_04_SHIFT 0U

//! Register: isp_exp_mean_14: Mean luminance value of block 14 (0x00000068)
//! Slice: isp_exp_mean_14:
//! Mean luminance value of block 14 (x,y)
#define MRV_AE_ISP_EXP_MEAN_14
#define MRV_AE_ISP_EXP_MEAN_14_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_14_SHIFT 0U

//! Register: isp_exp_mean_24: Mean luminance value of block 24 (0x0000006c)
//! Slice: isp_exp_mean_24:
//! Mean luminance value of block 24 (x,y)
#define MRV_AE_ISP_EXP_MEAN_24
#define MRV_AE_ISP_EXP_MEAN_24_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_24_SHIFT 0U

//! Register: isp_exp_mean_34: Mean luminance value of block 34 (0x00000070)
//! Slice: isp_exp_mean_34:
//! Mean luminance value of block 34 (x,y)
#define MRV_AE_ISP_EXP_MEAN_34
#define MRV_AE_ISP_EXP_MEAN_34_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_34_SHIFT 0U

//! Register: isp_exp_mean_44: Mean luminance value of block 44 (0x00000074)
//! Slice: isp_exp_mean_44:
//! Mean luminance value of block 44 (x,y)
#define MRV_AE_ISP_EXP_MEAN_44
#define MRV_AE_ISP_EXP_MEAN_44_MASK 0x000000FFU
#define MRV_AE_ISP_EXP_MEAN_44_SHIFT 0U

//! Register: isp_bls_ctrl: global control register (0x00000000)
//! Slice: WINDOW_ENABLE:
//! 0: no measuring is performed 
// 1: only window 1 is measured 
// 2: only window 2 is measured 
// 3: both windows are measured
#define MRV_BLS_WINDOW_ENABLE
#define MRV_BLS_WINDOW_ENABLE_MASK 0x0000000CU
#define MRV_BLS_WINDOW_ENABLE_SHIFT 2U
//! Slice: BLS_MODE:
//! 1: subtract measured values 
// 0: subtract fixed values
#define MRV_BLS_BLS_MODE
#define MRV_BLS_BLS_MODE_MASK 0x00000002U
#define MRV_BLS_BLS_MODE_SHIFT 1U
//! Slice: BLS_ENABLE:
//! 1: black level subtraction is enabled 
// 0: bypass the black level processing
#define MRV_BLS_BLS_ENABLE
#define MRV_BLS_BLS_ENABLE_MASK 0x00000001U
#define MRV_BLS_BLS_ENABLE_SHIFT 0U

//! Register: isp_bls_samples: samples register (0x00000004)
//! Slice: BLS_SAMPLES:
//! This number to the power of two gives the number of measure samples for each Bayer position. Range 0x00: 2^0=1  to  0x12: 2^18=262144. This number is also the divider for the accumulator for each Bayer position. 
// The accumulation will be stopped, if the number of measured pixels for the current Bayer position is equal to the number of samples. 
// The measure windows must be positioned that way that the number of included pixels of each Bayer position included by both windows is equal or greater than the number of measure samples calculated by 2^BLS_SAMPLES ! 
// NOTE: The number of pixels of one Bayer position is 1/4 of the number of all Pixels included by the measure windows.
#define MRV_BLS_BLS_SAMPLES
#define MRV_BLS_BLS_SAMPLES_MASK 0x0000001FU
#define MRV_BLS_BLS_SAMPLES_SHIFT 0U

//! Register: isp_bls_h1_start: window 1 horizontal start (0x00000008)
//! Slice: BLS_H1_START:
//! Black pixel window 1 horizontal start position
#define MRV_BLS_BLS_H1_START
#define MRV_BLS_BLS_H1_START_MASK 0x00003FFFU
#define MRV_BLS_BLS_H1_START_SHIFT 0U

//! Register: isp_bls_h1_stop: window 1 horizontal stop (0x0000000c)
//! Slice: BLS_H1_STOP:
//! Black pixel window 1 horizontal stop position
#define MRV_BLS_BLS_H1_STOP
#define MRV_BLS_BLS_H1_STOP_MASK 0x00003FFFU
#define MRV_BLS_BLS_H1_STOP_SHIFT 0U

//! Register: isp_bls_v1_start: window 1 vertical start (0x00000010)
//! Slice: BLS_V1_START:
//! Black pixel window 1 vertical start position
#define MRV_BLS_BLS_V1_START
#define MRV_BLS_BLS_V1_START_MASK 0x00003FFFU
#define MRV_BLS_BLS_V1_START_SHIFT 0U

//! Register: isp_bls_v1_stop: window 1 vertical stop (0x00000014)
//! Slice: BLS_V1_STOP:
//! Black pixel window 1 vertical stop position
#define MRV_BLS_BLS_V1_STOP
#define MRV_BLS_BLS_V1_STOP_MASK 0x00003FFFU
#define MRV_BLS_BLS_V1_STOP_SHIFT 0U

//! Register: isp_bls_h2_start: window 2 horizontal start (0x00000018)
//! Slice: BLS_H2_START:
//! Black pixel window 2 horizontal start position
#define MRV_BLS_BLS_H2_START
#define MRV_BLS_BLS_H2_START_MASK 0x00003FFFU
#define MRV_BLS_BLS_H2_START_SHIFT 0U

//! Register: isp_bls_h2_stop: window 2 horizontal stop (0x0000001c)
//! Slice: BLS_H2_STOP:
//! Black pixel window 2 horizontal stop position
#define MRV_BLS_BLS_H2_STOP
#define MRV_BLS_BLS_H2_STOP_MASK 0x00003FFFU
#define MRV_BLS_BLS_H2_STOP_SHIFT 0U

//! Register: isp_bls_v2_start: window 2 vertical start (0x00000020)
//! Slice: BLS_V2_START:
//! Black pixel window 2 vertical start position
#define MRV_BLS_BLS_V2_START
#define MRV_BLS_BLS_V2_START_MASK 0x00003FFFU
#define MRV_BLS_BLS_V2_START_SHIFT 0U

//! Register: isp_bls_v2_stop: window 2 vertical stop (0x00000024)
//! Slice: BLS_V2_STOP:
//! Black pixel window 2 vertical stop position
#define MRV_BLS_BLS_V2_STOP
#define MRV_BLS_BLS_V2_STOP_MASK 0x00003FFFU
#define MRV_BLS_BLS_V2_STOP_SHIFT 0U

//! Register: isp_bls_a_fixed: fixed black level A (0x00000028)
//! Slice: BLS_A_FIXED:
//! Fixed black level for A pixels  signed 
// two's complement, value range from -4096 to +4095, 
// a positive value will be subtracted from the pixel values
#define MRV_BLS_BLS_A_FIXED
#define MRV_BLS_BLS_A_FIXED_MASK 0x00001FFFU
#define MRV_BLS_BLS_A_FIXED_SHIFT 0U

//! Register: isp_bls_b_fixed: fixed black level B (0x0000002c)
//! Slice: BLS_B_FIXED:
//! Fixed black level for B pixels  signed 
// two's complement, value range from -4096 to +4095
#define MRV_BLS_BLS_B_FIXED
#define MRV_BLS_BLS_B_FIXED_MASK 0x00001FFFU
#define MRV_BLS_BLS_B_FIXED_SHIFT 0U

//! Register: isp_bls_c_fixed: fixed black level C (0x00000030)
//! Slice: BLS_C_FIXED:
//! Fixed black level for C pixels  signed 
// two's complement, value range from -4096 to +4095
#define MRV_BLS_BLS_C_FIXED
#define MRV_BLS_BLS_C_FIXED_MASK 0x00001FFFU
#define MRV_BLS_BLS_C_FIXED_SHIFT 0U

//! Register: isp_bls_d_fixed: fixed black level D (0x00000034)
//! Slice: BLS_D_FIXED:
//! Fixed black level for D pixels  - signed 
// two's complement, value range from -4096 to +4095
#define MRV_BLS_BLS_D_FIXED
#define MRV_BLS_BLS_D_FIXED_MASK 0x00001FFFU
#define MRV_BLS_BLS_D_FIXED_SHIFT 0U

//! Register: isp_bls_a_measured: measured black level A (0x00000038)
//! Slice: BLS_A_MEASURED:
//! Measured black level for A pixels
#define MRV_BLS_BLS_A_MEASURED
#define MRV_BLS_BLS_A_MEASURED_MASK 0x00000FFFU
#define MRV_BLS_BLS_A_MEASURED_SHIFT 0U

//! Register: isp_bls_b_measured: measured black level B (0x0000003c)
//! Slice: BLS_B_MEASURED:
//! Measured black level for B pixels
#define MRV_BLS_BLS_B_MEASURED
#define MRV_BLS_BLS_B_MEASURED_MASK 0x00000FFFU
#define MRV_BLS_BLS_B_MEASURED_SHIFT 0U

//! Register: isp_bls_c_measured: measured black level C (0x00000040)
//! Slice: BLS_C_MEASURED:
//! Measured black level for C pixels
#define MRV_BLS_BLS_C_MEASURED
#define MRV_BLS_BLS_C_MEASURED_MASK 0x00000FFFU
#define MRV_BLS_BLS_C_MEASURED_SHIFT 0U

//! Register: isp_bls_d_measured: measured black level D (0x00000044)
//! Slice: BLS_D_MEASURED:
//! Measured black level for D pixels
#define MRV_BLS_BLS_D_MEASURED
#define MRV_BLS_BLS_D_MEASURED_MASK 0x00000FFFU
#define MRV_BLS_BLS_D_MEASURED_SHIFT 0U

//! Register: isp_dpf_mode: Mode control for Denoising Pre-Filter block (0x00000000)
//! Slice: USE_NF_GAIN:
//! 1: DPF_NF_GAINs will be used.  
// 0: DPF_NF_GAINs will not be used.  *Default*
#define MRV_DPF_USE_NF_GAIN
#define MRV_DPF_USE_NF_GAIN_MASK 0x00000200U
#define MRV_DPF_USE_NF_GAIN_SHIFT 9U
//! Slice: LSC_GAIN_COMP:
//! 1: LSC gain will be processed   
// 0: LSC gain will not be processed. Use LSC gain factor of 1.  *Default*
#define MRV_DPF_LSC_GAIN_COMP
#define MRV_DPF_LSC_GAIN_COMP_MASK 0x00000100U
#define MRV_DPF_LSC_GAIN_COMP_SHIFT 8U
//! Slice: AWB_GAIN_COMP:
//! Only relevant when use_nf_gain == 0 && ISP_CTRL::ISP_AWB_ENABLE ==1 
//1: ISP_AWB gains will be processed   
// 0: ISP_AWB gains will not be processed. Use AWB gain factor of 1.  *Default*
#define MRV_DPF_AWB_GAIN_COMP
#define MRV_DPF_AWB_GAIN_COMP_MASK 0x00000080U
#define MRV_DPF_AWB_GAIN_COMP_SHIFT 7U
//! Slice: NLL_SEGMENTATION:
//! 1: optimized logarithmic like segmentation for Noise Level Lookup (NLL)   
// 0: equidistant segmentation for NLL  *Default*
#define MRV_DPF_NLL_SEGMENTATION
#define MRV_DPF_NLL_SEGMENTATION_MASK 0x00000040U
#define MRV_DPF_NLL_SEGMENTATION_SHIFT 6U
//! Slice: RB_FILTER_SIZE:
//! 1: Red and Blue filter kernel size of 9x9 (5x5 active) pixels 
// 0: Wide Red and Blue filter kernel size of 13x9 (7x5 active) pixels  *Default*
#define MRV_DPF_RB_FILTER_SIZE
#define MRV_DPF_RB_FILTER_SIZE_MASK 0x00000020U
#define MRV_DPF_RB_FILTER_SIZE_SHIFT 5U
//! Slice: R_FILTER_OFF:
//! 1: disable filter processing for red pixels (R) 
// 0: filter R pixels  *Default*
#define MRV_DPF_R_FILTER_OFF
#define MRV_DPF_R_FILTER_OFF_MASK 0x00000010U
#define MRV_DPF_R_FILTER_OFF_SHIFT 4U
//! Slice: GR_FILTER_OFF:
//! 1: disable filter processing for green pixels in green/red lines (GR) 
// 0: filter GR pixels  *Default*
#define MRV_DPF_GR_FILTER_OFF
#define MRV_DPF_GR_FILTER_OFF_MASK 0x00000008U
#define MRV_DPF_GR_FILTER_OFF_SHIFT 3U
//! Slice: GB_FILTER_OFF:
//! 1: disable filter processing for green pixels in green/blue lines (GB) 
// 0: filter GB pixels  *Default*
#define MRV_DPF_GB_FILTER_OFF
#define MRV_DPF_GB_FILTER_OFF_MASK 0x00000004U
#define MRV_DPF_GB_FILTER_OFF_SHIFT 2U
//! Slice: B_FILTER_OFF:
//! 1: disable filter processing for blue pixels (B) 
// 0: filter B pixels  *Default*
#define MRV_DPF_B_FILTER_OFF
#define MRV_DPF_B_FILTER_OFF_MASK 0x00000002U
#define MRV_DPF_B_FILTER_OFF_SHIFT 1U
//! Slice: DPF_ENABLE:
//! 1: enable dpf 
// 0: bypass dpf  *Default*
#define MRV_DPF_DPF_ENABLE
#define MRV_DPF_DPF_ENABLE_MASK 0x00000001U
#define MRV_DPF_DPF_ENABLE_SHIFT 0U

//! Register: isp_dpf_strength_r: filter strength of the RED filter (0x00000004)
//! Slice: INV_WEIGHT_R:
//! Filter strength of the filter is determined by weight. Default is a weight of 1. A higher weight increases the filter strength. In this register the unsigned 8 bit value 64/weight is stored.  
// 
//The following values show examples: 
// weight=0.251 -> 255, weight=0.5 -> 128,  
// weight=1 -> 64 *default*   
// weight=1.25  -> 51, weight=1.5 -> 42,  
// weight=1.75 -> 37, weight=2 -> 32
#define MRV_DPF_INV_WEIGHT_R
#define MRV_DPF_INV_WEIGHT_R_MASK 0x000000FFU
#define MRV_DPF_INV_WEIGHT_R_SHIFT 0U

//! Register: isp_dpf_strength_g: filter strength of the GREEN filter (0x00000008)
//! Slice: INV_WEIGHT_G:
//! Filter strength of the filter is determined by weight. Default is a weight of 1. A higher weight increases the filter strength. In this register the unsigned 8 bit value 64/weight is stored.  
// 
//The following values show examples: 
// weight=0.251 -> 255, weight=0.5 -> 128,  
// weight=1 -> 64 *default*   
// weight=1.25  -> 51, weight=1.5 -> 42,  
// weight=1.75 -> 37, weight=2 -> 32
#define MRV_DPF_INV_WEIGHT_G
#define MRV_DPF_INV_WEIGHT_G_MASK 0x000000FFU
#define MRV_DPF_INV_WEIGHT_G_SHIFT 0U

//! Register: isp_dpf_strength_b: filter strength of the BLUE filter (0x0000000c)
//! Slice: INV_WEIGHT_B:
//! Filter strength of the filter is determined by weight. Default is a weight of 1. A higher weight increases the filter strength. In this register the unsigned 8 bit value 64/weight is stored.  
// 
//The following values show examples: 
// weight=0.251 -> 255, weight=0.5 -> 128,  
// weight=1 -> 64 *default*   
// weight=1.25  -> 51, weight=1.5 -> 42,  
// weight=1.75 -> 37, weight=2 -> 32
#define MRV_DPF_INV_WEIGHT_B
#define MRV_DPF_INV_WEIGHT_B_MASK 0x000000FFU
#define MRV_DPF_INV_WEIGHT_B_SHIFT 0U

//! Register: isp_dpf_s_weight_g_1_4: Spatial Weights green channel 1 2 3 4 (0x00000010)
//! Slice: S_WEIGHT_G4:
//! Filter Coefficient green channel S_WEIGHT_G4 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_G4
#define MRV_DPF_S_WEIGHT_G4_MASK 0x1F000000U
#define MRV_DPF_S_WEIGHT_G4_SHIFT 24U
//! Slice: S_WEIGHT_G3:
//! Filter Coefficient green channel S_WEIGHT_G3 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_G3
#define MRV_DPF_S_WEIGHT_G3_MASK 0x001F0000U
#define MRV_DPF_S_WEIGHT_G3_SHIFT 16U
//! Slice: S_WEIGHT_G2:
//! Filter Coefficient green channel S_WEIGHT_G2 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_G2
#define MRV_DPF_S_WEIGHT_G2_MASK 0x00001F00U
#define MRV_DPF_S_WEIGHT_G2_SHIFT 8U
//! Slice: S_WEIGHT_G1:
//! Filter Coefficient green channel S_WEIGHT_G1 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_G1
#define MRV_DPF_S_WEIGHT_G1_MASK 0x0000001FU
#define MRV_DPF_S_WEIGHT_G1_SHIFT 0U

//! Register: isp_dpf_s_weight_g_5_6: Spatial Weights green channel 5 6 (0x00000014)
//! Slice: S_WEIGHT_G6:
//! Filter Coefficient green channel S_WEIGHT_G6 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_G6
#define MRV_DPF_S_WEIGHT_G6_MASK 0x00001F00U
#define MRV_DPF_S_WEIGHT_G6_SHIFT 8U
//! Slice: S_WEIGHT_G5:
//! Filter Coefficient green channel S_WEIGHT_G5 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_G5
#define MRV_DPF_S_WEIGHT_G5_MASK 0x0000001FU
#define MRV_DPF_S_WEIGHT_G5_SHIFT 0U

//! Register: isp_dpf_s_weight_rb_1_4: Spatial Weights red/blue channels 1 2 3 4 (0x00000018)
//! Slice: S_WEIGHT_RB4:
//! Filter Coefficient red/blue channels S_WEIGHT_RB4 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_RB4
#define MRV_DPF_S_WEIGHT_RB4_MASK 0x1F000000U
#define MRV_DPF_S_WEIGHT_RB4_SHIFT 24U
//! Slice: S_WEIGHT_RB3:
//! Filter Coefficient red/blue channels S_WEIGHT_RB3 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_RB3
#define MRV_DPF_S_WEIGHT_RB3_MASK 0x001F0000U
#define MRV_DPF_S_WEIGHT_RB3_SHIFT 16U
//! Slice: S_WEIGHT_RB2:
//! Filter Coefficient red/blue channels S_WEIGHT_RB2 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_RB2
#define MRV_DPF_S_WEIGHT_RB2_MASK 0x00001F00U
#define MRV_DPF_S_WEIGHT_RB2_SHIFT 8U
//! Slice: S_WEIGHT_RB1:
//! Filter Coefficient red/blue channels S_WEIGHT_RB1 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_RB1
#define MRV_DPF_S_WEIGHT_RB1_MASK 0x0000001FU
#define MRV_DPF_S_WEIGHT_RB1_SHIFT 0U

//! Register: isp_dpf_s_weight_rb_5_6: Spatial Weights red/blue channels 5 6 (0x0000001c)
//! Slice: S_WEIGHT_RB6:
//! Filter Coefficient red/blue channels S_WEIGHT_RB6 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_RB6
#define MRV_DPF_S_WEIGHT_RB6_MASK 0x00001F00U
#define MRV_DPF_S_WEIGHT_RB6_SHIFT 8U
//! Slice: S_WEIGHT_RB5:
//! Filter Coefficient red/blue channels S_WEIGHT_RB5 
// 5 bit unsigned, value range 1/16 to 16/16 
// Default value is 16/16 (*Default*)
#define MRV_DPF_S_WEIGHT_RB5
#define MRV_DPF_S_WEIGHT_RB5_MASK 0x0000001FU
#define MRV_DPF_S_WEIGHT_RB5_SHIFT 0U

//! Register array: isp_dpf_nll_coeff: Noise Level Lookup Coefficient (0x0040 + n*0x4 (n=0..16))
//! Slice: nll_coeff_n:
// Noise Level Lookup Table Coefficient nll_coeff_n 
// 10 bit unsigned, value range 1/1024 to 1023/1024 (*Default*)
#define MRV_DPF_NLL_COEFF_N
#define MRV_DPF_NLL_COEFF_N_MASK 0x000003FFU
#define MRV_DPF_NLL_COEFF_N_SHIFT 0U

//! Register: isp_dpf_nf_gain_r: noise function gain for red pixels (0x00000064)
//! Slice: DPF_NF_GAIN_R:
//! Noise Function (NF) Gain that replaces the AWB gain for red pixels. 
// 12 bit unsigned integer format: gain=1 -> 0x100
#define MRV_DPF_DPF_NF_GAIN_R
#define MRV_DPF_DPF_NF_GAIN_R_MASK 0x00000FFFU
#define MRV_DPF_DPF_NF_GAIN_R_SHIFT 0U

//! Register: isp_dpf_nf_gain_gr: noise function gain for green in red pixels (0x00000068)
//! Slice: DPF_NF_GAIN_GR:
//! Noise Function (NF) Gain that replaces the AWB gain for green pixels in a red line. 
// 12 bit unsigned integer format: gain=1 -> 0x100
#define MRV_DPF_DPF_NF_GAIN_GR
#define MRV_DPF_DPF_NF_GAIN_GR_MASK 0x00000FFFU
#define MRV_DPF_DPF_NF_GAIN_GR_SHIFT 0U

//! Register: isp_dpf_nf_gain_gb: noise function gain for green in blue pixels (0x0000006c)
//! Slice: DPF_NF_GAIN_GB:
//! Noise Function (NF) Gain that replaces the AWB gain for green pixels in a blue line. 
// 12 bit unsigned integer format: gain=1 -> 0x100
#define MRV_DPF_DPF_NF_GAIN_GB
#define MRV_DPF_DPF_NF_GAIN_GB_MASK 0x00000FFFU
#define MRV_DPF_DPF_NF_GAIN_GB_SHIFT 0U

//! Register: isp_dpf_nf_gain_b: noise function gain for blue pixels (0x00000070)
//! Slice: DPF_NF_GAIN_B:
//! Noise Function (NF) Gain that replaces the AWB gain for blue pixels. 
// 12 bit unsigned integer format: gain=1 -> 0x100
#define MRV_DPF_DPF_NF_GAIN_B
#define MRV_DPF_DPF_NF_GAIN_B_MASK 0x00000FFFU
#define MRV_DPF_DPF_NF_GAIN_B_SHIFT 0U

//! Register: isp_dpcc_mode: Mode control for DPCC detection unit (0x00000000)
//! Slice: STAGE1_ENABLE:
//! 1: enable  stage1 *Default*
// 0: bypass  stage1
#define MRV_DPCC_STAGE1_ENABLE
#define MRV_DPCC_STAGE1_ENABLE_MASK 0x00000004U
#define MRV_DPCC_STAGE1_ENABLE_SHIFT 2U
//! Slice: GRAYSCALE_MODE:
//! 1: enable gray scale data input from black and white sensors (without color filter array) 
// 0: BAYER DATA INPUT  *Default*
#define MRV_DPCC_GRAYSCALE_MODE
#define MRV_DPCC_GRAYSCALE_MODE_MASK 0x00000002U
#define MRV_DPCC_GRAYSCALE_MODE_SHIFT 1U
//! Slice: ISP_DPCC_enable:
//! 1: enable DPCC 
// 0: bypass DPCC  *Default*
#define MRV_DPCC_ISP_DPCC_ENABLE
#define MRV_DPCC_ISP_DPCC_ENABLE_MASK 0x00000001U
#define MRV_DPCC_ISP_DPCC_ENABLE_SHIFT 0U

//! Register: isp_dpcc_output_mode: Interpolation mode for correction unit (0x00000004)
//! Slice: STAGE1_RB_3x3:
//! 1: stage1 red/blue 9 pixel (3x3) output median  
// 0: stage1 red/blue 4 or 5 pixel output median  *Default*
#define MRV_DPCC_STAGE1_RB_3X3
#define MRV_DPCC_STAGE1_RB_3X3_MASK 0x00000008U
#define MRV_DPCC_STAGE1_RB_3X3_SHIFT 3U
//! Slice: STAGE1_G_3x3:
//! 1: stage1 green 9 pixel (3x3) output median  
// 0: stage1 green 4 or 5 pixel output median  *Default*
#define MRV_DPCC_STAGE1_G_3X3
#define MRV_DPCC_STAGE1_G_3X3_MASK 0x00000004U
#define MRV_DPCC_STAGE1_G_3X3_SHIFT 2U
//! Slice: STAGE1_INCL_RB_CENTER:
//! 1: stage1 include center pixel for red/blue output median 2x2+1 
// *Default* 0: stage1 do not include center pixel for red/blue output median 2x2
#define MRV_DPCC_STAGE1_INCL_RB_CENTER
#define MRV_DPCC_STAGE1_INCL_RB_CENTER_MASK 0x00000002U
#define MRV_DPCC_STAGE1_INCL_RB_CENTER_SHIFT 1U
//! Slice: STAGE1_INCL_GREEN_CENTER:
//! 1: stage1 include center pixel for green output median 2x2+1 *Default* 
// 0: stage1 do not include center pixel for green output median 2x2
#define MRV_DPCC_STAGE1_INCL_GREEN_CENTER
#define MRV_DPCC_STAGE1_INCL_GREEN_CENTER_MASK 0x00000001U
#define MRV_DPCC_STAGE1_INCL_GREEN_CENTER_SHIFT 0U

//! Register: isp_dpcc_set_use: DPCC methods set usage for detection (0x00000008)
//! Slice: STAGE1_USE_FIX_SET:
//! 1: stage1 use hard coded methods set *Default* 
// 0: stage1 do not use hard coded methods set
#define MRV_DPCC_STAGE1_USE_FIX_SET
#define MRV_DPCC_STAGE1_USE_FIX_SET_MASK 0x00000008U
#define MRV_DPCC_STAGE1_USE_FIX_SET_SHIFT 3U
//! Slice: STAGE1_USE_SET_3:
//! 1: stage1 use methods set 3  
// 0: stage1 do not use methods set 3 *Default*
#define MRV_DPCC_STAGE1_USE_SET_3
#define MRV_DPCC_STAGE1_USE_SET_3_MASK 0x00000004U
#define MRV_DPCC_STAGE1_USE_SET_3_SHIFT 2U
//! Slice: STAGE1_USE_SET_2:
//! 1: stage1 use methods set 2  
// 0: stage1 do not use methods set 2 *Default*
#define MRV_DPCC_STAGE1_USE_SET_2
#define MRV_DPCC_STAGE1_USE_SET_2_MASK 0x00000002U
#define MRV_DPCC_STAGE1_USE_SET_2_SHIFT 1U
//! Slice: STAGE1_USE_SET_1:
//! 1: stage1 use methods set 1  *Default* 
// 0: stage1 do not use methods set 1
#define MRV_DPCC_STAGE1_USE_SET_1
#define MRV_DPCC_STAGE1_USE_SET_1_MASK 0x00000001U
#define MRV_DPCC_STAGE1_USE_SET_1_SHIFT 0U

//! Register: isp_dpcc_methods_set_1: Methods enable bits for SET_1 (0x0000000c)
//! Slice: RG_RED_BLUE1_ENABLE:
//! 1: enable Rank Gradient check for red_blue  *Default* 
// 0: bypass Rank Gradient check for red_blue
#define MRV_DPCC_RG_RED_BLUE1_ENABLE
#define MRV_DPCC_RG_RED_BLUE1_ENABLE_MASK 0x00001000U
#define MRV_DPCC_RG_RED_BLUE1_ENABLE_SHIFT 12U
//! Slice: RND_RED_BLUE1_ENABLE:
//! 1: enable Rank Neighbor Difference check for red_blue  *Default* 
// 0: bypass Rank Neighbor Difference check for red_blue
#define MRV_DPCC_RND_RED_BLUE1_ENABLE
#define MRV_DPCC_RND_RED_BLUE1_ENABLE_MASK 0x00000800U
#define MRV_DPCC_RND_RED_BLUE1_ENABLE_SHIFT 11U
//! Slice: RO_RED_BLUE1_ENABLE:
//! 1: enable Rank Order check for red_blue  *Default* 
// 0: bypass Rank Order check for red_blue
#define MRV_DPCC_RO_RED_BLUE1_ENABLE
#define MRV_DPCC_RO_RED_BLUE1_ENABLE_MASK 0x00000400U
#define MRV_DPCC_RO_RED_BLUE1_ENABLE_SHIFT 10U
//! Slice: LC_RED_BLUE1_ENABLE:
//! 1: enable Line check for red_blue *Default*  
// 0: bypass Line check for red_blue
#define MRV_DPCC_LC_RED_BLUE1_ENABLE
#define MRV_DPCC_LC_RED_BLUE1_ENABLE_MASK 0x00000200U
#define MRV_DPCC_LC_RED_BLUE1_ENABLE_SHIFT 9U
//! Slice: PG_RED_BLUE1_ENABLE:
//! 1: enable Peak Gradient check for red_blue  *Default* 
// 0: bypass Peak Gradient check for red_blue
#define MRV_DPCC_PG_RED_BLUE1_ENABLE
#define MRV_DPCC_PG_RED_BLUE1_ENABLE_MASK 0x00000100U
#define MRV_DPCC_PG_RED_BLUE1_ENABLE_SHIFT 8U
//! Slice: RG_GREEN1_ENABLE:
//! 1: enable Rank Gradient check for green  *Default* 
// 0: bypass Rank Gradient check for green
#define MRV_DPCC_RG_GREEN1_ENABLE
#define MRV_DPCC_RG_GREEN1_ENABLE_MASK 0x00000010U
#define MRV_DPCC_RG_GREEN1_ENABLE_SHIFT 4U
//! Slice: RND_GREEN1_ENABLE:
//! 1: enable Rank Neighbor Difference check for green  *Default* 
// 0: bypass Rank Neighbor Difference check for green
#define MRV_DPCC_RND_GREEN1_ENABLE
#define MRV_DPCC_RND_GREEN1_ENABLE_MASK 0x00000008U
#define MRV_DPCC_RND_GREEN1_ENABLE_SHIFT 3U
//! Slice: RO_GREEN1_ENABLE:
//! 1: enable Rank Order check for green  *Default* 
// 0: bypass Rank Order check for green
#define MRV_DPCC_RO_GREEN1_ENABLE
#define MRV_DPCC_RO_GREEN1_ENABLE_MASK 0x00000004U
#define MRV_DPCC_RO_GREEN1_ENABLE_SHIFT 2U
//! Slice: LC_GREEN1_ENABLE:
//! 1: enable Line check for green *Default*  
// 0: bypass Line check for green
#define MRV_DPCC_LC_GREEN1_ENABLE
#define MRV_DPCC_LC_GREEN1_ENABLE_MASK 0x00000002U
#define MRV_DPCC_LC_GREEN1_ENABLE_SHIFT 1U
//! Slice: PG_GREEN1_ENABLE:
//! 1: enable Peak Gradient check for green  *Default* 
// 0: bypass Peak Gradient check for green
#define MRV_DPCC_PG_GREEN1_ENABLE
#define MRV_DPCC_PG_GREEN1_ENABLE_MASK 0x00000001U
#define MRV_DPCC_PG_GREEN1_ENABLE_SHIFT 0U

//! Register: isp_dpcc_methods_set_2: Methods enable bits for SET_2 (0x00000010)
//! Slice: RG_RED_BLUE2_ENABLE:
//! 1: enable Rank Gradient check for red_blue  *Default* 
// 0: bypass Rank Gradient check for red_blue
#define MRV_DPCC_RG_RED_BLUE2_ENABLE
#define MRV_DPCC_RG_RED_BLUE2_ENABLE_MASK 0x00001000U
#define MRV_DPCC_RG_RED_BLUE2_ENABLE_SHIFT 12U
//! Slice: RND_RED_BLUE2_ENABLE:
//! 1: enable Rank Neighbor Difference check for red_blue  *Default* 
// 0: bypass Rank Neighbor Difference check for red_blue
#define MRV_DPCC_RND_RED_BLUE2_ENABLE
#define MRV_DPCC_RND_RED_BLUE2_ENABLE_MASK 0x00000800U
#define MRV_DPCC_RND_RED_BLUE2_ENABLE_SHIFT 11U
//! Slice: RO_RED_BLUE2_ENABLE:
//! 1: enable Rank Order check for red_blue  *Default* 
// 0: bypass Rank Order check for red_blue
#define MRV_DPCC_RO_RED_BLUE2_ENABLE
#define MRV_DPCC_RO_RED_BLUE2_ENABLE_MASK 0x00000400U
#define MRV_DPCC_RO_RED_BLUE2_ENABLE_SHIFT 10U
//! Slice: LC_RED_BLUE2_ENABLE:
//! 1: enable Line check for red_blue 
// 0: bypass Line check for red_blue  *Default*
#define MRV_DPCC_LC_RED_BLUE2_ENABLE
#define MRV_DPCC_LC_RED_BLUE2_ENABLE_MASK 0x00000200U
#define MRV_DPCC_LC_RED_BLUE2_ENABLE_SHIFT 9U
//! Slice: PG_RED_BLUE2_ENABLE:
//! 1: enable Peak Gradient check for red_blue  *Default* 
// 0: bypass Peak Gradient check for red_blue
#define MRV_DPCC_PG_RED_BLUE2_ENABLE
#define MRV_DPCC_PG_RED_BLUE2_ENABLE_MASK 0x00000100U
#define MRV_DPCC_PG_RED_BLUE2_ENABLE_SHIFT 8U
//! Slice: RG_GREEN2_ENABLE:
//! 1: enable Rank Gradient check for green  *Default* 
// 0: bypass Rank Gradient check for green
#define MRV_DPCC_RG_GREEN2_ENABLE
#define MRV_DPCC_RG_GREEN2_ENABLE_MASK 0x00000010U
#define MRV_DPCC_RG_GREEN2_ENABLE_SHIFT 4U
//! Slice: RND_GREEN2_ENABLE:
//! 1: enable Rank Neighbor Difference check for green  *Default* 
// 0: bypass Rank Neighbor Difference check for green
#define MRV_DPCC_RND_GREEN2_ENABLE
#define MRV_DPCC_RND_GREEN2_ENABLE_MASK 0x00000008U
#define MRV_DPCC_RND_GREEN2_ENABLE_SHIFT 3U
//! Slice: RO_GREEN2_ENABLE:
//! 1: enable Rank Order check for green  *Default* 
// 0: bypass Rank Order check for green
#define MRV_DPCC_RO_GREEN2_ENABLE
#define MRV_DPCC_RO_GREEN2_ENABLE_MASK 0x00000004U
#define MRV_DPCC_RO_GREEN2_ENABLE_SHIFT 2U
//! Slice: LC_GREEN2_ENABLE:
//! 1: enable Line check for green 
// 0: bypass Line check for green  *Default*
#define MRV_DPCC_LC_GREEN2_ENABLE
#define MRV_DPCC_LC_GREEN2_ENABLE_MASK 0x00000002U
#define MRV_DPCC_LC_GREEN2_ENABLE_SHIFT 1U
//! Slice: PG_GREEN2_ENABLE:
//! 1: enable Peak Gradient check for green  *Default* 
// 0: bypass Peak Gradient check for green
#define MRV_DPCC_PG_GREEN2_ENABLE
#define MRV_DPCC_PG_GREEN2_ENABLE_MASK 0x00000001U
#define MRV_DPCC_PG_GREEN2_ENABLE_SHIFT 0U

//! Register: isp_dpcc_methods_set_3: Methods enable bits for SET_3 (0x00000014)
//! Slice: RG_RED_BLUE3_ENABLE:
//! 1: enable Rank Gradient check for red_blue 
// 0: bypass Rank Gradient check for red_blue  *Default*
#define MRV_DPCC_RG_RED_BLUE3_ENABLE
#define MRV_DPCC_RG_RED_BLUE3_ENABLE_MASK 0x00001000U
#define MRV_DPCC_RG_RED_BLUE3_ENABLE_SHIFT 12U
//! Slice: RND_RED_BLUE3_ENABLE:
//! 1: enable Rank Neighbor Difference check for red_blue 
// 0: bypass Rank Neighbor Difference check for red_blue  *Default*
#define MRV_DPCC_RND_RED_BLUE3_ENABLE
#define MRV_DPCC_RND_RED_BLUE3_ENABLE_MASK 0x00000800U
#define MRV_DPCC_RND_RED_BLUE3_ENABLE_SHIFT 11U
//! Slice: RO_RED_BLUE3_ENABLE:
//! 1: enable Rank Order check for red_blue  *Default* 
// 0: bypass Rank Order check for red_blue
#define MRV_DPCC_RO_RED_BLUE3_ENABLE
#define MRV_DPCC_RO_RED_BLUE3_ENABLE_MASK 0x00000400U
#define MRV_DPCC_RO_RED_BLUE3_ENABLE_SHIFT 10U
//! Slice: LC_RED_BLUE3_ENABLE:
//! 1: enable Line check for red_blue  *Default* 
// 0: bypass Line check for red_blue
#define MRV_DPCC_LC_RED_BLUE3_ENABLE
#define MRV_DPCC_LC_RED_BLUE3_ENABLE_MASK 0x00000200U
#define MRV_DPCC_LC_RED_BLUE3_ENABLE_SHIFT 9U
//! Slice: PG_RED_BLUE3_ENABLE:
//! 1: enable Peak Gradient check for red_blue  *Default* 
// 0: bypass Peak Gradient check for red_blue
#define MRV_DPCC_PG_RED_BLUE3_ENABLE
#define MRV_DPCC_PG_RED_BLUE3_ENABLE_MASK 0x00000100U
#define MRV_DPCC_PG_RED_BLUE3_ENABLE_SHIFT 8U
//! Slice: RG_GREEN3_ENABLE:
//! 1: enable Rank Gradient check for green 
// 0: bypass Rank Gradient check for green  *Default*
#define MRV_DPCC_RG_GREEN3_ENABLE
#define MRV_DPCC_RG_GREEN3_ENABLE_MASK 0x00000010U
#define MRV_DPCC_RG_GREEN3_ENABLE_SHIFT 4U
//! Slice: RND_GREEN3_ENABLE:
//! 1: enable Rank Neighbor Difference check for green 
// 0: bypass Rank Neighbor Difference check for green  *Default*
#define MRV_DPCC_RND_GREEN3_ENABLE
#define MRV_DPCC_RND_GREEN3_ENABLE_MASK 0x00000008U
#define MRV_DPCC_RND_GREEN3_ENABLE_SHIFT 3U
//! Slice: RO_GREEN3_ENABLE:
//! 1: enable Rank Order check for green  *Default* 
// 0: bypass Rank Order check for green
#define MRV_DPCC_RO_GREEN3_ENABLE
#define MRV_DPCC_RO_GREEN3_ENABLE_MASK 0x00000004U
#define MRV_DPCC_RO_GREEN3_ENABLE_SHIFT 2U
//! Slice: LC_GREEN3_ENABLE:
//! 1: enable Line check for green  *Default* 
// 0: bypass Line check for green
#define MRV_DPCC_LC_GREEN3_ENABLE
#define MRV_DPCC_LC_GREEN3_ENABLE_MASK 0x00000002U
#define MRV_DPCC_LC_GREEN3_ENABLE_SHIFT 1U
//! Slice: PG_GREEN3_ENABLE:
//! 1: enable Peak Gradient check for green  *Default* 
// 0: bypass Peak Gradient check for green
#define MRV_DPCC_PG_GREEN3_ENABLE
#define MRV_DPCC_PG_GREEN3_ENABLE_MASK 0x00000001U
#define MRV_DPCC_PG_GREEN3_ENABLE_SHIFT 0U

//! Register: isp_dpcc_line_thresh_1: Line threshold SET_1 (0x00000018)
//! Slice: LINE_THR_1_RB:
//! line threshold for set 1 red/blue
#define MRV_DPCC_LINE_THR_1_RB
#define MRV_DPCC_LINE_THR_1_RB_MASK 0x0000FF00U
#define MRV_DPCC_LINE_THR_1_RB_SHIFT 8U
//! Slice: LINE_THR_1_G:
//! line threshold for set 1 green
#define MRV_DPCC_LINE_THR_1_G
#define MRV_DPCC_LINE_THR_1_G_MASK 0x000000FFU
#define MRV_DPCC_LINE_THR_1_G_SHIFT 0U

//! Register: isp_dpcc_line_mad_fac_1: Mean Absolute Difference (MAD) factor for Line check set 1 (0x0000001c)
//! Slice: LINE_MAD_FAC_1_RB:
//! line MAD factor for set 1 red/blue
#define MRV_DPCC_LINE_MAD_FAC_1_RB
#define MRV_DPCC_LINE_MAD_FAC_1_RB_MASK 0x00003F00U
#define MRV_DPCC_LINE_MAD_FAC_1_RB_SHIFT 8U
//! Slice: LINE_MAD_FAC_1_G:
//! line MAD factor for set 1 green
#define MRV_DPCC_LINE_MAD_FAC_1_G
#define MRV_DPCC_LINE_MAD_FAC_1_G_MASK 0x0000003FU
#define MRV_DPCC_LINE_MAD_FAC_1_G_SHIFT 0U

//! Register: isp_dpcc_pg_fac_1: Peak gradient factor for set 1 (0x00000020)
//! Slice: PG_FAC_1_RB:
//! Peak gradient factor for set 1 red/blue
#define MRV_DPCC_PG_FAC_1_RB
#define MRV_DPCC_PG_FAC_1_RB_MASK 0x00003F00U
#define MRV_DPCC_PG_FAC_1_RB_SHIFT 8U
//! Slice: PG_FAC_1_G:
//! Peak gradient factor for set 1 green
#define MRV_DPCC_PG_FAC_1_G
#define MRV_DPCC_PG_FAC_1_G_MASK 0x0000003FU
#define MRV_DPCC_PG_FAC_1_G_SHIFT 0U

//! Register: isp_dpcc_rnd_thresh_1: Rank Neighbor Difference threshold for set 1 (0x00000024)
//! Slice: RND_THR_1_RB:
//! Rank Neighbor Difference threshold for set 1 red/blue
#define MRV_DPCC_RND_THR_1_RB
#define MRV_DPCC_RND_THR_1_RB_MASK 0x0000FF00U
#define MRV_DPCC_RND_THR_1_RB_SHIFT 8U
//! Slice: RND_THR_1_G:
//! Rank Neighbor Difference threshold for set 1 green
#define MRV_DPCC_RND_THR_1_G
#define MRV_DPCC_RND_THR_1_G_MASK 0x000000FFU
#define MRV_DPCC_RND_THR_1_G_SHIFT 0U

//! Register: isp_dpcc_rg_fac_1: Rank gradient factor for set 1 (0x00000028)
//! Slice: RG_FAC_1_RB:
//! Rank gradient factor for set 1 red/blue
#define MRV_DPCC_RG_FAC_1_RB
#define MRV_DPCC_RG_FAC_1_RB_MASK 0x00003F00U
#define MRV_DPCC_RG_FAC_1_RB_SHIFT 8U
//! Slice: RG_FAC_1_G:
//! Rank gradient factor for set 1 green
#define MRV_DPCC_RG_FAC_1_G
#define MRV_DPCC_RG_FAC_1_G_MASK 0x0000003FU
#define MRV_DPCC_RG_FAC_1_G_SHIFT 0U

//! Register: isp_dpcc_line_thresh_2: Line threshold set 2 (0x0000002c)
//! Slice: LINE_THR_2_RB:
//! line threshold for set 2 red/blue
#define MRV_DPCC_LINE_THR_2_RB
#define MRV_DPCC_LINE_THR_2_RB_MASK 0x0000FF00U
#define MRV_DPCC_LINE_THR_2_RB_SHIFT 8U
//! Slice: LINE_THR_2_G:
//! line threshold for set 2 green
#define MRV_DPCC_LINE_THR_2_G
#define MRV_DPCC_LINE_THR_2_G_MASK 0x000000FFU
#define MRV_DPCC_LINE_THR_2_G_SHIFT 0U

//! Register: isp_dpcc_line_mad_fac_2: Mean Absolute Difference (MAD) factor for Line check set 2 (0x00000030)
//! Slice: LINE_MAD_FAC_2_RB:
//! line MAD factor for set 2 red/blue
#define MRV_DPCC_LINE_MAD_FAC_2_RB
#define MRV_DPCC_LINE_MAD_FAC_2_RB_MASK 0x00003F00U
#define MRV_DPCC_LINE_MAD_FAC_2_RB_SHIFT 8U
//! Slice: LINE_MAD_FAC_2_G:
//! line MAD factor for set 2 green
#define MRV_DPCC_LINE_MAD_FAC_2_G
#define MRV_DPCC_LINE_MAD_FAC_2_G_MASK 0x0000003FU
#define MRV_DPCC_LINE_MAD_FAC_2_G_SHIFT 0U

//! Register: isp_dpcc_pg_fac_2: Peak gradient factor for set 2 (0x00000034)
//! Slice: PG_FAC_2_RB:
//! Peak gradient factor for set 2 red/blue
#define MRV_DPCC_PG_FAC_2_RB
#define MRV_DPCC_PG_FAC_2_RB_MASK 0x00003F00U
#define MRV_DPCC_PG_FAC_2_RB_SHIFT 8U
//! Slice: PG_FAC_2_G:
//! Peak gradient factor for set 2 green
#define MRV_DPCC_PG_FAC_2_G
#define MRV_DPCC_PG_FAC_2_G_MASK 0x0000003FU
#define MRV_DPCC_PG_FAC_2_G_SHIFT 0U

//! Register: isp_dpcc_rnd_thresh_2: Rank Neighbor Difference threshold for set 2 (0x00000038)
//! Slice: RND_THR_2_RB:
//! Rank Neighbor Difference threshold for set 2 red/blue
#define MRV_DPCC_RND_THR_2_RB
#define MRV_DPCC_RND_THR_2_RB_MASK 0x0000FF00U
#define MRV_DPCC_RND_THR_2_RB_SHIFT 8U
//! Slice: RND_THR_2_G:
//! Rank Neighbor Difference threshold for set 2 green
#define MRV_DPCC_RND_THR_2_G
#define MRV_DPCC_RND_THR_2_G_MASK 0x000000FFU
#define MRV_DPCC_RND_THR_2_G_SHIFT 0U

//! Register: isp_dpcc_rg_fac_2: Rank gradient factor for set 2 (0x0000003c)
//! Slice: RG_FAC_2_RB:
//! Rank gradient factor for set 2 red/blue
#define MRV_DPCC_RG_FAC_2_RB
#define MRV_DPCC_RG_FAC_2_RB_MASK 0x00003F00U
#define MRV_DPCC_RG_FAC_2_RB_SHIFT 8U
//! Slice: RG_FAC_2_G:
//! Rank gradient factor for set 2 green
#define MRV_DPCC_RG_FAC_2_G
#define MRV_DPCC_RG_FAC_2_G_MASK 0x0000003FU
#define MRV_DPCC_RG_FAC_2_G_SHIFT 0U

//! Register: isp_dpcc_line_thresh_3: Line threshold set 3 (0x00000040)
//! Slice: LINE_THR_3_RB:
//! line threshold for set 3 red/blue
#define MRV_DPCC_LINE_THR_3_RB
#define MRV_DPCC_LINE_THR_3_RB_MASK 0x0000FF00U
#define MRV_DPCC_LINE_THR_3_RB_SHIFT 8U
//! Slice: LINE_THR_3_G:
//! line threshold for set 3 green
#define MRV_DPCC_LINE_THR_3_G
#define MRV_DPCC_LINE_THR_3_G_MASK 0x000000FFU
#define MRV_DPCC_LINE_THR_3_G_SHIFT 0U

//! Register: isp_dpcc_line_mad_fac_3: Mean Absolute Difference (MAD) factor for Line check set 3 (0x00000044)
//! Slice: LINE_MAD_FAC_3_RB:
//! line MAD factor for set 3 red/blue
#define MRV_DPCC_LINE_MAD_FAC_3_RB
#define MRV_DPCC_LINE_MAD_FAC_3_RB_MASK 0x00003F00U
#define MRV_DPCC_LINE_MAD_FAC_3_RB_SHIFT 8U
//! Slice: LINE_MAD_FAC_3_G:
//! line MAD factor for set 3 green
#define MRV_DPCC_LINE_MAD_FAC_3_G
#define MRV_DPCC_LINE_MAD_FAC_3_G_MASK 0x0000003FU
#define MRV_DPCC_LINE_MAD_FAC_3_G_SHIFT 0U

//! Register: isp_dpcc_pg_fac_3: Peak gradient factor for set 3 (0x00000048)
//! Slice: PG_FAC_3_RB:
//! Peak gradient factor for set 3 red/blue
#define MRV_DPCC_PG_FAC_3_RB
#define MRV_DPCC_PG_FAC_3_RB_MASK 0x00003F00U
#define MRV_DPCC_PG_FAC_3_RB_SHIFT 8U
//! Slice: PG_FAC_3_G:
//! Peak gradient factor for set 3 green
#define MRV_DPCC_PG_FAC_3_G
#define MRV_DPCC_PG_FAC_3_G_MASK 0x0000003FU
#define MRV_DPCC_PG_FAC_3_G_SHIFT 0U

//! Register: isp_dpcc_rnd_thresh_3: Rank Neighbor Difference threshold for set 3 (0x0000004c)
//! Slice: RND_THR_3_RB:
//! Rank Neighbor Difference threshold for set 3 red/blue
#define MRV_DPCC_RND_THR_3_RB
#define MRV_DPCC_RND_THR_3_RB_MASK 0x0000FF00U
#define MRV_DPCC_RND_THR_3_RB_SHIFT 8U
//! Slice: RND_THR_3_G:
//! Rank Neighbor Difference threshold for set 3 green
#define MRV_DPCC_RND_THR_3_G
#define MRV_DPCC_RND_THR_3_G_MASK 0x000000FFU
#define MRV_DPCC_RND_THR_3_G_SHIFT 0U

//! Register: isp_dpcc_rg_fac_3: Rank gradient factor for set 3 (0x00000050)
//! Slice: RG_FAC_3_RB:
//! Rank gradient factor for set 3 red/blue
#define MRV_DPCC_RG_FAC_3_RB
#define MRV_DPCC_RG_FAC_3_RB_MASK 0x00003F00U
#define MRV_DPCC_RG_FAC_3_RB_SHIFT 8U
//! Slice: RG_FAC_3_G:
//! Rank gradient factor for set 3 green
#define MRV_DPCC_RG_FAC_3_G
#define MRV_DPCC_RG_FAC_3_G_MASK 0x0000003FU
#define MRV_DPCC_RG_FAC_3_G_SHIFT 0U

//! Register: isp_dpcc_ro_limits: Rank Order Limits (0x00000054)
//! Slice: RO_LIM_3_RB:
//! Rank order limit for set 3 red/blue
#define MRV_DPCC_RO_LIM_3_RB
#define MRV_DPCC_RO_LIM_3_RB_MASK 0x00000C00U
#define MRV_DPCC_RO_LIM_3_RB_SHIFT 10U
//! Slice: RO_LIM_3_G:
//! Rank order limit for set 3 green
#define MRV_DPCC_RO_LIM_3_G
#define MRV_DPCC_RO_LIM_3_G_MASK 0x00000300U
#define MRV_DPCC_RO_LIM_3_G_SHIFT 8U
//! Slice: RO_LIM_2_RB:
//! Rank order limit for set 2 red/blue
#define MRV_DPCC_RO_LIM_2_RB
#define MRV_DPCC_RO_LIM_2_RB_MASK 0x000000C0U
#define MRV_DPCC_RO_LIM_2_RB_SHIFT 6U
//! Slice: RO_LIM_2_G:
//! Rank order limit for set 2 green
#define MRV_DPCC_RO_LIM_2_G
#define MRV_DPCC_RO_LIM_2_G_MASK 0x00000030U
#define MRV_DPCC_RO_LIM_2_G_SHIFT 4U
//! Slice: RO_LIM_1_RB:
//! Rank order limit for set 1 red/blue
#define MRV_DPCC_RO_LIM_1_RB
#define MRV_DPCC_RO_LIM_1_RB_MASK 0x0000000CU
#define MRV_DPCC_RO_LIM_1_RB_SHIFT 2U
//! Slice: RO_LIM_1_G:
//! Rank order limit for set 1 green
#define MRV_DPCC_RO_LIM_1_G
#define MRV_DPCC_RO_LIM_1_G_MASK 0x00000003U
#define MRV_DPCC_RO_LIM_1_G_SHIFT 0U

//! Register: isp_dpcc_rnd_offs: Differential Rank Offsets for Rank Neighbor Difference (0x00000058)
//! Slice: RND_OFFS_3_RB:
//! Rank Offset to Neighbor for set 3 red/blue
#define MRV_DPCC_RND_OFFS_3_RB
#define MRV_DPCC_RND_OFFS_3_RB_MASK 0x00000C00U
#define MRV_DPCC_RND_OFFS_3_RB_SHIFT 10U
//! Slice: RND_OFFS_3_G:
//! Rank Offset to Neighbor for set 3 green
#define MRV_DPCC_RND_OFFS_3_G
#define MRV_DPCC_RND_OFFS_3_G_MASK 0x00000300U
#define MRV_DPCC_RND_OFFS_3_G_SHIFT 8U
//! Slice: RND_OFFS_2_RB:
//! Rank Offset to Neighbor for set 2 red/blue
#define MRV_DPCC_RND_OFFS_2_RB
#define MRV_DPCC_RND_OFFS_2_RB_MASK 0x000000C0U
#define MRV_DPCC_RND_OFFS_2_RB_SHIFT 6U
//! Slice: RND_OFFS_2_G:
//! Rank Offset to Neighbor for set 2 green
#define MRV_DPCC_RND_OFFS_2_G
#define MRV_DPCC_RND_OFFS_2_G_MASK 0x00000030U
#define MRV_DPCC_RND_OFFS_2_G_SHIFT 4U
//! Slice: RND_OFFS_1_RB:
//! Rank Offset to Neighbor for set 1 red/blue
#define MRV_DPCC_RND_OFFS_1_RB
#define MRV_DPCC_RND_OFFS_1_RB_MASK 0x0000000CU
#define MRV_DPCC_RND_OFFS_1_RB_SHIFT 2U
//! Slice: RND_OFFS_1_G:
//! Rank Offset to Neighbor for set 1 green
#define MRV_DPCC_RND_OFFS_1_G
#define MRV_DPCC_RND_OFFS_1_G_MASK 0x00000003U
#define MRV_DPCC_RND_OFFS_1_G_SHIFT 0U

//! Register: isp_dpcc_bpt_ctrl: bad pixel table settings (0x0000005c)
//! Slice: BPT_RB_3x3:
//! 1: if BPT active red/blue 9 pixel (3x3) output median  
// 0: if BPT active red/blue 4 or 5 pixel output median  *Default*
#define MRV_DPCC_BPT_RB_3X3
#define MRV_DPCC_BPT_RB_3X3_MASK 0x00000800U
#define MRV_DPCC_BPT_RB_3X3_SHIFT 11U
//! Slice: BPT_G_3x3:
//! 1: if BPT active green 9 pixel (3x3) output median  
// 0: if BPT active green 4 or 5 pixel output median  *Default*
#define MRV_DPCC_BPT_G_3X3
#define MRV_DPCC_BPT_G_3X3_MASK 0x00000400U
#define MRV_DPCC_BPT_G_3X3_SHIFT 10U
//! Slice: BPT_INCL_RB_CENTER:
//! 1: if BPT active include center pixel for red/blue output median 2x2+1 
// 0: if BPT active do not include center pixel for red/blue output median 2x2 *Default*
#define MRV_DPCC_BPT_INCL_RB_CENTER
#define MRV_DPCC_BPT_INCL_RB_CENTER_MASK 0x00000200U
#define MRV_DPCC_BPT_INCL_RB_CENTER_SHIFT 9U
//! Slice: BPT_INCL_GREEN_CENTER:
//! 1: if BPT active include center pixel for green output median 2x2+1 
// 0: if BPT active do not include center pixel for green output median 2x2 *Default*
#define MRV_DPCC_BPT_INCL_GREEN_CENTER
#define MRV_DPCC_BPT_INCL_GREEN_CENTER_MASK 0x00000100U
#define MRV_DPCC_BPT_INCL_GREEN_CENTER_SHIFT 8U
//! Slice: BPT_USE_FIX_SET:
//! 1: for BPT write use hard coded methods set 
// 0: for BPT write do not use hard coded methods set *Default*
#define MRV_DPCC_BPT_USE_FIX_SET
#define MRV_DPCC_BPT_USE_FIX_SET_MASK 0x00000080U
#define MRV_DPCC_BPT_USE_FIX_SET_SHIFT 7U
//! Slice: BPT_USE_SET_3:
//! 1: for BPT write use methods set 3  
// 0: for BPT write do not use methods set 3 *Default*
#define MRV_DPCC_BPT_USE_SET_3
#define MRV_DPCC_BPT_USE_SET_3_MASK 0x00000040U
#define MRV_DPCC_BPT_USE_SET_3_SHIFT 6U
//! Slice: BPT_USE_SET_2:
//! 1: for BPT write use methods set 2  
// 0: for BPT write do not use methods set 2 *Default*
#define MRV_DPCC_BPT_USE_SET_2
#define MRV_DPCC_BPT_USE_SET_2_MASK 0x00000020U
#define MRV_DPCC_BPT_USE_SET_2_SHIFT 5U
//! Slice: BPT_USE_SET_1:
//! 1: for BPT write use methods set 1  
// 0: for BPT write do not use methods set 1 *Default*
#define MRV_DPCC_BPT_USE_SET_1
#define MRV_DPCC_BPT_USE_SET_1_MASK 0x00000010U
#define MRV_DPCC_BPT_USE_SET_1_SHIFT 4U
//! Slice: bpt_cor_en:
//! table based correction enable 
// 1: table based correction is enabled 
// 0: table based correction is disabled
#define MRV_DPCC_BPT_COR_EN
#define MRV_DPCC_BPT_COR_EN_MASK 0x00000002U
#define MRV_DPCC_BPT_COR_EN_SHIFT 1U
//! Slice: bpt_det_en:
//! Bad pixel detection write enable 
// 1: bad pixel detection write to memory is enabled 
// 0: bad pixel detection write to memory is disabled
#define MRV_DPCC_BPT_DET_EN
#define MRV_DPCC_BPT_DET_EN_MASK 0x00000001U
#define MRV_DPCC_BPT_DET_EN_SHIFT 0U

//! Register: isp_dpcc_bpt_number: Number of entries for bad pixel table (table based correction) (0x00000060)
//! Slice: bp_number:
//! Number of current Bad Pixel entries in bad pixel table (BPT)
#define MRV_DPCC_BP_NUMBER
#define MRV_DPCC_BP_NUMBER_MASK 0x00000FFFU
#define MRV_DPCC_BP_NUMBER_SHIFT 0U

//! Register: isp_dpcc_bpt_addr: TABLE Start Address for table-based correction algorithm (0x00000064)
//! Slice: bp_table_addr:
//! Table RAM start address for read or write operations. The address counter is incremented at each read or write access to the data register (auto-increment mechanism).
#define MRV_DPCC_BP_TABLE_ADDR
#define MRV_DPCC_BP_TABLE_ADDR_MASK 0x000007FFU
#define MRV_DPCC_BP_TABLE_ADDR_SHIFT 0U

//! Register: isp_dpcc_bpt_data: TABLE DATA register for read and write access of table RAM (0x00000068)
//! Slice: bpt_v_addr:
//! Bad Pixel vertical address (pixel position)
#define MRV_DPCC_BPT_V_ADDR
#define MRV_DPCC_BPT_V_ADDR_MASK 0x0FFF0000U
#define MRV_DPCC_BPT_V_ADDR_SHIFT 16U
//! Slice: bpt_h_addr:
//! Bad Pixel horizontal address (pixel position)
#define MRV_DPCC_BPT_H_ADDR
#define MRV_DPCC_BPT_H_ADDR_MASK 0x00001FFFU
#define MRV_DPCC_BPT_H_ADDR_SHIFT 0U

//! Register: isp_wdr_ctrl: Control Bits for Wide Dynamic Range Unit (0x00000000)
//! Slice: WDR_RGB_FACTOR:
//! rgb_factor defines how much influence the RGBmax approach has in comparison to Y. The illumination reference Iref is calculated according to the following formula: 
// Iref = (WDR_RGB_FACTOR * RGBYmax_tr + (8 - WDR_RGB_FACTOR) * Y) / 8  
// So, rgb_factor = 0 means that the standard approach is used. Use of this factor requires that Iref has been selected, see WDR_USE_IREF. 
//Value range of rgb_factor: 0...8
#define MRV_WDR_RGB_FACTOR
#define MRV_WDR_RGB_FACTOR_MASK 0x00000F00U
#define MRV_WDR_RGB_FACTOR_SHIFT 8U
//! Slice: WDR_DISABLE_TRANSIENT:
//! 1: disable transient between Y and RGBY_max 
// 0: calculate transient between Y and RGBY_max (for noise reduction) *Default* 
// Use of this bit requires that Iref has been selected, see WDR_USE_IREF.
#define MRV_WDR_DISABLE_TRANSIENT
#define MRV_WDR_DISABLE_TRANSIENT_MASK 0x00000040U
#define MRV_WDR_DISABLE_TRANSIENT_SHIFT 6U
//! Slice: WDR_USE_RGB7_8:
//! 1: decrease RGBmax by 7/8 (for noise reduction)
// 0: do not modify RGBmax *Default* 
// Use of this bit requires that Iref has been selected, see WDR_USE_IREF.
#define MRV_WDR_USE_RGB7_8
#define MRV_WDR_USE_RGB7_8_MASK 0x00000020U
#define MRV_WDR_USE_RGB7_8_SHIFT 5U
//! Slice: WDR_USE_Y9_8:
//! 1: use R G B and Y*9/8 for maximum value calculation (for noise reduction) 
// 0: only use R G B for maximum value calculation (RGBYmax approach)  *Default* 
// Use of this bit requires that Iref has been selected, see WDR_USE_IREF.
#define MRV_WDR_USE_Y9_8
#define MRV_WDR_USE_Y9_8_MASK 0x00000010U
#define MRV_WDR_USE_Y9_8_SHIFT 4U
//! Slice: WDR_USE_IREF:
//! 1: use Iref (Illumination reference) instead of Y for ToneMapping and Gain calculation 
// 0: use Y for ToneMapping and Gain calculation  *Default* 
// Iref is calculated according to the following formula: 
// Iref = (WDR_RGB_FACTOR * RGBmax_tr + (8 - WDR_RGB_FACTOR) * Y) / 8
#define MRV_WDR_USE_IREF
#define MRV_WDR_USE_IREF_MASK 0x00000008U
#define MRV_WDR_USE_IREF_SHIFT 3U
//! Slice: WDR_CR_MAPPING_DISABLE:
//! 1: disable (bypass) Chrominance Mapping 
// 0: enable Chrominance Mapping  *Default* 
// requires that Luminance/chrominance color space has been selected
#define MRV_WDR_CR_MAPPING_DISABLE
#define MRV_WDR_CR_MAPPING_DISABLE_MASK 0x00000004U
#define MRV_WDR_CR_MAPPING_DISABLE_SHIFT 2U
//! Slice: WDR_COLOR_SPACE_SELECT:
//! 1: R, G, B color space 
// 0: Luminance/Chrominance color space  *Default*
#define MRV_WDR_COLOR_SPACE_SELECT
#define MRV_WDR_COLOR_SPACE_SELECT_MASK 0x00000002U
#define MRV_WDR_COLOR_SPACE_SELECT_SHIFT 1U
//! Slice: WDR_ENABLE:
//! 1: enable WDR 
// 0: bypass WDR  *Default*
#define MRV_WDR_ENABLE
#define MRV_WDR_ENABLE_MASK 0x00000001U
#define MRV_WDR_ENABLE_SHIFT 0U

//! Register: isp_wdr_tonecurve_1: Tone Curve sample points dYn definition (part 1) (0x00000004)
//! Slice: WDR_dY8:
//! Tone curve sample point definition dY8 on the horizontal axis (input)
#define MRV_WDR_DY8
#define MRV_WDR_DY8_MASK 0x70000000U
#define MRV_WDR_DY8_SHIFT 28U
//! Slice: WDR_dY7:
//! Tone curve sample point definition dY7 on the horizontal axis (input)
#define MRV_WDR_DY7
#define MRV_WDR_DY7_MASK 0x07000000U
#define MRV_WDR_DY7_SHIFT 24U
//! Slice: WDR_dY6:
//! Tone curve sample point definition dY6 on the horizontal axis (input)
#define MRV_WDR_DY6
#define MRV_WDR_DY6_MASK 0x00700000U
#define MRV_WDR_DY6_SHIFT 20U
//! Slice: WDR_dY5:
//! Tone curve sample point definition dY5 on the horizontal axis (input)
#define MRV_WDR_DY5
#define MRV_WDR_DY5_MASK 0x00070000U
#define MRV_WDR_DY5_SHIFT 16U
//! Slice: WDR_dY4:
//! Tone curve sample point definition dY4 on the horizontal axis (input)
#define MRV_WDR_DY4
#define MRV_WDR_DY4_MASK 0x00007000U
#define MRV_WDR_DY4_SHIFT 12U
//! Slice: WDR_dY3:
//! Tone curve sample point definition dY3 on the horizontal axis (input)
#define MRV_WDR_DY3
#define MRV_WDR_DY3_MASK 0x00000700U
#define MRV_WDR_DY3_SHIFT 8U
//! Slice: WDR_dY2:
//! Tone curve sample point definition dY2 on the horizontal axis (input)
#define MRV_WDR_DY2
#define MRV_WDR_DY2_MASK 0x00000070U
#define MRV_WDR_DY2_SHIFT 4U
//! Slice: WDR_dY1:
//! Tone curve sample point definition dY1 on the horizontal axis (input)
#define MRV_WDR_DY1
#define MRV_WDR_DY1_MASK 0x00000007U
#define MRV_WDR_DY1_SHIFT 0U

//! Register: isp_wdr_tonecurve_2: Tone Curve sample points dYn definition (part 2) (0x00000008)
//! Slice: WDR_dY16:
//! Tone curve sample point definition dY16 on the horizontal axis (input)
#define MRV_WDR_DY16
#define MRV_WDR_DY16_MASK 0x70000000U
#define MRV_WDR_DY16_SHIFT 28U
//! Slice: WDR_dY15:
//! Tone curve sample point definition dY15 on the horizontal axis (input)
#define MRV_WDR_DY15
#define MRV_WDR_DY15_MASK 0x07000000U
#define MRV_WDR_DY15_SHIFT 24U
//! Slice: WDR_dY14:
//! Tone curve sample point definition dY14 on the horizontal axis (input)
#define MRV_WDR_DY14
#define MRV_WDR_DY14_MASK 0x00700000U
#define MRV_WDR_DY14_SHIFT 20U
//! Slice: WDR_dY13:
//! Tone curve sample point definition dY13 on the horizontal axis (input)
#define MRV_WDR_DY13
#define MRV_WDR_DY13_MASK 0x00070000U
#define MRV_WDR_DY13_SHIFT 16U
//! Slice: WDR_dY12:
//! Tone curve sample point definition dY12 on the horizontal axis (input)
#define MRV_WDR_DY12
#define MRV_WDR_DY12_MASK 0x00007000U
#define MRV_WDR_DY12_SHIFT 12U
//! Slice: WDR_dY11:
//! Tone curve sample point definition dY11 on the horizontal axis (input)
#define MRV_WDR_DY11
#define MRV_WDR_DY11_MASK 0x00000700U
#define MRV_WDR_DY11_SHIFT 8U
//! Slice: WDR_dY10:
//! Tone curve sample point definition dY10 on the horizontal axis (input)
#define MRV_WDR_DY10
#define MRV_WDR_DY10_MASK 0x00000070U
#define MRV_WDR_DY10_SHIFT 4U
//! Slice: WDR_dY9:
//! Tone curve sample point definition dY9 on the horizontal axis (input)
#define MRV_WDR_DY9
#define MRV_WDR_DY9_MASK 0x00000007U
#define MRV_WDR_DY9_SHIFT 0U

//! Register: isp_wdr_tonecurve_3: Tone Curve sample points dYn definition (part 3) (0x0000000c)
//! Slice: WDR_dY24:
//! Tone curve sample point definition dY24 on the horizontal axis (input)
#define MRV_WDR_DY24
#define MRV_WDR_DY24_MASK 0x70000000U
#define MRV_WDR_DY24_SHIFT 28U
//! Slice: WDR_dY23:
//! Tone curve sample point definition dY23 on the horizontal axis (input)
#define MRV_WDR_DY23
#define MRV_WDR_DY23_MASK 0x07000000U
#define MRV_WDR_DY23_SHIFT 24U
//! Slice: WDR_dY22:
//! Tone curve sample point definition dY22 on the horizontal axis (input)
#define MRV_WDR_DY22
#define MRV_WDR_DY22_MASK 0x00700000U
#define MRV_WDR_DY22_SHIFT 20U
//! Slice: WDR_dY21:
//! Tone curve sample point definition dY21 on the horizontal axis (input)
#define MRV_WDR_DY21
#define MRV_WDR_DY21_MASK 0x00070000U
#define MRV_WDR_DY21_SHIFT 16U
//! Slice: WDR_dY20:
//! Tone curve sample point definition dY20 on the horizontal axis (input)
#define MRV_WDR_DY20
#define MRV_WDR_DY20_MASK 0x00007000U
#define MRV_WDR_DY20_SHIFT 12U
//! Slice: WDR_dY19:
//! Tone curve sample point definition dY19 on the horizontal axis (input)
#define MRV_WDR_DY19
#define MRV_WDR_DY19_MASK 0x00000700U
#define MRV_WDR_DY19_SHIFT 8U
//! Slice: WDR_dY18:
//! Tone curve sample point definition dY18 on the horizontal axis (input)
#define MRV_WDR_DY18
#define MRV_WDR_DY18_MASK 0x00000070U
#define MRV_WDR_DY18_SHIFT 4U
//! Slice: WDR_dY17:
//! Tone curve sample point definition dY17 on the horizontal axis (input)
#define MRV_WDR_DY17
#define MRV_WDR_DY17_MASK 0x00000007U
#define MRV_WDR_DY17_SHIFT 0U

//! Register: isp_wdr_tonecurve_4: Tone Curve sample points dYn definition (part 4) (0x00000010)
//! Slice: WDR_dY32:
//! Tone curve sample point definition dY32 on the horizontal axis (input)
#define MRV_WDR_DY32
#define MRV_WDR_DY32_MASK 0x70000000U
#define MRV_WDR_DY32_SHIFT 28U
//! Slice: WDR_dY31:
//! Tone curve sample point definition dY31 on the horizontal axis (input)
#define MRV_WDR_DY31
#define MRV_WDR_DY31_MASK 0x07000000U
#define MRV_WDR_DY31_SHIFT 24U
//! Slice: WDR_dY30:
//! Tone curve sample point definition dY30 on the horizontal axis (input)
#define MRV_WDR_DY30
#define MRV_WDR_DY30_MASK 0x00700000U
#define MRV_WDR_DY30_SHIFT 20U
//! Slice: WDR_dY29:
//! Tone curve sample point definition dY29 on the horizontal axis (input)
#define MRV_WDR_DY29
#define MRV_WDR_DY29_MASK 0x00070000U
#define MRV_WDR_DY29_SHIFT 16U
//! Slice: WDR_dY28:
//! Tone curve sample point definition dY28 on the horizontal axis (input)
#define MRV_WDR_DY28
#define MRV_WDR_DY28_MASK 0x00007000U
#define MRV_WDR_DY28_SHIFT 12U
//! Slice: WDR_dY27:
//! Tone curve sample point definition dY27 on the horizontal axis (input)
#define MRV_WDR_DY27
#define MRV_WDR_DY27_MASK 0x00000700U
#define MRV_WDR_DY27_SHIFT 8U
//! Slice: WDR_dY26:
//! Tone curve sample point definition dY26 on the horizontal axis (input)
#define MRV_WDR_DY26
#define MRV_WDR_DY26_MASK 0x00000070U
#define MRV_WDR_DY26_SHIFT 4U
//! Slice: WDR_dY25:
//! Tone curve sample point definition dY25 on the horizontal axis (input)
#define MRV_WDR_DY25
#define MRV_WDR_DY25_MASK 0x00000007U
#define MRV_WDR_DY25_SHIFT 0U

//! Register array: isp_wdr_tonecurve_ym: Tonemapping curve coefficient Ym_ (0x0028 + n*0x4 (n=0..32))
//! Slice: tonecurve_ym_n:
// Tone curve value definition y-axis (output) of WDR unit
#define MRV_WDR_TONECURVE_YM_N
#define MRV_WDR_TONECURVE_YM_N_MASK 0x00001FFFU
#define MRV_WDR_TONECURVE_YM_N_SHIFT 0U

//! Register: isp_wdr_offset: Offset values for RGB path (0x00000098)
//! Slice: LUM_OFFSET:
//! Luminance Offset value (a) for RGB operation mode 
// unsigned 12 bit value
#define MRV_WDR_LUM_OFFSET
#define MRV_WDR_LUM_OFFSET_MASK 0x0FFF0000U
#define MRV_WDR_LUM_OFFSET_SHIFT 16U
//! Slice: RGB_OFFSET:
//! RGB Offset value (b) for RGB operation mode 
// unsigned 12 bit value
#define MRV_WDR_RGB_OFFSET
#define MRV_WDR_RGB_OFFSET_MASK 0x00000FFFU
#define MRV_WDR_RGB_OFFSET_SHIFT 0U

//! Register: isp_wdr_deltamin: DeltaMin Threshold and Strength factor (0x0000009c)
//! Slice: DMIN_STRENGTH:
//! strength factor for DMIN 
// unsigned 5 bit value, range 0x00...0x10
#define MRV_WDR_DMIN_STRENGTH
#define MRV_WDR_DMIN_STRENGTH_MASK 0x001F0000U
#define MRV_WDR_DMIN_STRENGTH_SHIFT 16U
//! Slice: DMIN_THRESH:
//! Lower threshold for deltaMin value 
// unsigned 12 bit value
#define MRV_WDR_DMIN_THRESH
#define MRV_WDR_DMIN_THRESH_MASK 0x00000FFFU
#define MRV_WDR_DMIN_THRESH_SHIFT 0U

//! Register: isp_wdr_tonecurve_1_shd: Tone Curve sample points dYn definition shadow register (part 1) (0x000000a0)
//! Slice: WDR_dY8:
//! Tone curve sample point definition dY8 on the horizontal axis (input)
#define MRV_WDR_DY8
#define MRV_WDR_DY8_MASK 0x70000000U
#define MRV_WDR_DY8_SHIFT 28U
//! Slice: WDR_dY7:
//! Tone curve sample point definition dY7 on the horizontal axis (input)
#define MRV_WDR_DY7
#define MRV_WDR_DY7_MASK 0x07000000U
#define MRV_WDR_DY7_SHIFT 24U
//! Slice: WDR_dY6:
//! Tone curve sample point definition dY6 on the horizontal axis (input)
#define MRV_WDR_DY6
#define MRV_WDR_DY6_MASK 0x00700000U
#define MRV_WDR_DY6_SHIFT 20U
//! Slice: WDR_dY5:
//! Tone curve sample point definition dY5 on the horizontal axis (input)
#define MRV_WDR_DY5
#define MRV_WDR_DY5_MASK 0x00070000U
#define MRV_WDR_DY5_SHIFT 16U
//! Slice: WDR_dY4:
//! Tone curve sample point definition dY4 on the horizontal axis (input)
#define MRV_WDR_DY4
#define MRV_WDR_DY4_MASK 0x00007000U
#define MRV_WDR_DY4_SHIFT 12U
//! Slice: WDR_dY3:
//! Tone curve sample point definition dY3 on the horizontal axis (input)
#define MRV_WDR_DY3
#define MRV_WDR_DY3_MASK 0x00000700U
#define MRV_WDR_DY3_SHIFT 8U
//! Slice: WDR_dY2:
//! Tone curve sample point definition dY2 on the horizontal axis (input)
#define MRV_WDR_DY2
#define MRV_WDR_DY2_MASK 0x00000070U
#define MRV_WDR_DY2_SHIFT 4U
//! Slice: WDR_dY1:
//! Tone curve sample point definition dY1 on the horizontal axis (input)
#define MRV_WDR_DY1
#define MRV_WDR_DY1_MASK 0x00000007U
#define MRV_WDR_DY1_SHIFT 0U

//! Register: isp_wdr_tonecurve_2_shd: Tone Curve sample points dYn definition shadow register (part 2) (0x000000a4)
//! Slice: WDR_dY16:
//! Tone curve sample point definition dY16 on the horizontal axis (input)
#define MRV_WDR_DY16
#define MRV_WDR_DY16_MASK 0x70000000U
#define MRV_WDR_DY16_SHIFT 28U
//! Slice: WDR_dY15:
//! Tone curve sample point definition dY15 on the horizontal axis (input)
#define MRV_WDR_DY15
#define MRV_WDR_DY15_MASK 0x07000000U
#define MRV_WDR_DY15_SHIFT 24U
//! Slice: WDR_dY14:
//! Tone curve sample point definition dY14 on the horizontal axis (input)
#define MRV_WDR_DY14
#define MRV_WDR_DY14_MASK 0x00700000U
#define MRV_WDR_DY14_SHIFT 20U
//! Slice: WDR_dY13:
//! Tone curve sample point definition dY13 on the horizontal axis (input)
#define MRV_WDR_DY13
#define MRV_WDR_DY13_MASK 0x00070000U
#define MRV_WDR_DY13_SHIFT 16U
//! Slice: WDR_dY12:
//! Tone curve sample point definition dY12 on the horizontal axis (input)
#define MRV_WDR_DY12
#define MRV_WDR_DY12_MASK 0x00007000U
#define MRV_WDR_DY12_SHIFT 12U
//! Slice: WDR_dY11:
//! Tone curve sample point definition dY11 on the horizontal axis (input)
#define MRV_WDR_DY11
#define MRV_WDR_DY11_MASK 0x00000700U
#define MRV_WDR_DY11_SHIFT 8U
//! Slice: WDR_dY10:
//! Tone curve sample point definition dY10 on the horizontal axis (input)
#define MRV_WDR_DY10
#define MRV_WDR_DY10_MASK 0x00000070U
#define MRV_WDR_DY10_SHIFT 4U
//! Slice: WDR_dY9:
//! Tone curve sample point definition dY9 on the horizontal axis (input)
#define MRV_WDR_DY9
#define MRV_WDR_DY9_MASK 0x00000007U
#define MRV_WDR_DY9_SHIFT 0U

//! Register: isp_wdr_tonecurve_3_shd: Tone Curve sample points dYn definition shadow register (part 3) (0x000000a8)
//! Slice: WDR_dY24:
//! Tone curve sample point definition dY24 on the horizontal axis (input)
#define MRV_WDR_DY24
#define MRV_WDR_DY24_MASK 0x70000000U
#define MRV_WDR_DY24_SHIFT 28U
//! Slice: WDR_dY23:
//! Tone curve sample point definition dY23 on the horizontal axis (input)
#define MRV_WDR_DY23
#define MRV_WDR_DY23_MASK 0x07000000U
#define MRV_WDR_DY23_SHIFT 24U
//! Slice: WDR_dY22:
//! Tone curve sample point definition dY22 on the horizontal axis (input)
#define MRV_WDR_DY22
#define MRV_WDR_DY22_MASK 0x00700000U
#define MRV_WDR_DY22_SHIFT 20U
//! Slice: WDR_dY21:
//! Tone curve sample point definition dY21 on the horizontal axis (input)
#define MRV_WDR_DY21
#define MRV_WDR_DY21_MASK 0x00070000U
#define MRV_WDR_DY21_SHIFT 16U
//! Slice: WDR_dY20:
//! Tone curve sample point definition dY20 on the horizontal axis (input)
#define MRV_WDR_DY20
#define MRV_WDR_DY20_MASK 0x00007000U
#define MRV_WDR_DY20_SHIFT 12U
//! Slice: WDR_dY19:
//! Tone curve sample point definition dY19 on the horizontal axis (input)
#define MRV_WDR_DY19
#define MRV_WDR_DY19_MASK 0x00000700U
#define MRV_WDR_DY19_SHIFT 8U
//! Slice: WDR_dY18:
//! Tone curve sample point definition dY18 on the horizontal axis (input)
#define MRV_WDR_DY18
#define MRV_WDR_DY18_MASK 0x00000070U
#define MRV_WDR_DY18_SHIFT 4U
//! Slice: WDR_dY17:
//! Tone curve sample point definition dY17 on the horizontal axis (input)
#define MRV_WDR_DY17
#define MRV_WDR_DY17_MASK 0x00000007U
#define MRV_WDR_DY17_SHIFT 0U

//! Register: isp_wdr_tonecurve_4_shd: Tone Curve sample points dYn definition shadow register(part 4) (0x000000ac)
//! Slice: WDR_dY32:
//! Tone curve sample point definition dY32 on the horizontal axis (input)
#define MRV_WDR_DY32
#define MRV_WDR_DY32_MASK 0x70000000U
#define MRV_WDR_DY32_SHIFT 28U
//! Slice: WDR_dY31:
//! Tone curve sample point definition dY31 on the horizontal axis (input)
#define MRV_WDR_DY31
#define MRV_WDR_DY31_MASK 0x07000000U
#define MRV_WDR_DY31_SHIFT 24U
//! Slice: WDR_dY30:
//! Tone curve sample point definition dY30 on the horizontal axis (input)
#define MRV_WDR_DY30
#define MRV_WDR_DY30_MASK 0x00700000U
#define MRV_WDR_DY30_SHIFT 20U
//! Slice: WDR_dY29:
//! Tone curve sample point definition dY29 on the horizontal axis (input)
#define MRV_WDR_DY29
#define MRV_WDR_DY29_MASK 0x00070000U
#define MRV_WDR_DY29_SHIFT 16U
//! Slice: WDR_dY28:
//! Tone curve sample point definition dY28 on the horizontal axis (input)
#define MRV_WDR_DY28
#define MRV_WDR_DY28_MASK 0x00007000U
#define MRV_WDR_DY28_SHIFT 12U
//! Slice: WDR_dY27:
//! Tone curve sample point definition dY27 on the horizontal axis (input)
#define MRV_WDR_DY27
#define MRV_WDR_DY27_MASK 0x00000700U
#define MRV_WDR_DY27_SHIFT 8U
//! Slice: WDR_dY26:
//! Tone curve sample point definition dY26 on the horizontal axis (input)
#define MRV_WDR_DY26
#define MRV_WDR_DY26_MASK 0x00000070U
#define MRV_WDR_DY26_SHIFT 4U
//! Slice: WDR_dY25:
//! Tone curve sample point definition dY25 on the horizontal axis (input)
#define MRV_WDR_DY25
#define MRV_WDR_DY25_MASK 0x00000007U
#define MRV_WDR_DY25_SHIFT 0U

//! Register array: isp_wdr_tonecurve_ym_shd: Tonemapping curve coefficient shadow register (0x0160 + n*0x4 (n=0..32))
//! Slice: tonecurve_ym_n_shd:
// Tone curve value definition y-axis (output) of WDR unit 
// shadow register.
#define MRV_WDR_TONECURVE_YM_N_SHD
#define MRV_WDR_TONECURVE_YM_N_SHD_MASK 0x00001FFFU
#define MRV_WDR_TONECURVE_YM_N_SHD_SHIFT 0U

//! Register: awb_meas_mode: AWB Measure Mode (0x00000000)
//! Slice: AWB_union_e5_and_e8:
//! unite ellipse 5 with ellipse 8. Accu and count for ellipse 8.
#define ISP_AWB_UNION_E5_AND_E8
#define ISP_AWB_UNION_E5_AND_E8_MASK 0x00000200U
#define ISP_AWB_UNION_E5_AND_E8_SHIFT 9U
//! Slice: AWB_union_e5_and_e7:
//! unite ellipse 5 with ellipse 7. Accu and count for ellipse 7.
#define ISP_AWB_UNION_E5_AND_E7
#define ISP_AWB_UNION_E5_AND_E7_MASK 0x00000100U
#define ISP_AWB_UNION_E5_AND_E7_SHIFT 8U
//! Slice: AWB_union_e5_and_e6:
//! unite ellipse 5 with ellipse 6. Accu and count for ellipse 6.
#define ISP_AWB_UNION_E5_AND_E6
#define ISP_AWB_UNION_E5_AND_E6_MASK 0x00000080U
#define ISP_AWB_UNION_E5_AND_E6_SHIFT 7U
//! Slice: AWB_union_e1_and_e4:
//! unite ellipse 1 with ellipse 4. Accu and count for ellipse 4.
#define ISP_AWB_UNION_E1_AND_E4
#define ISP_AWB_UNION_E1_AND_E4_MASK 0x00000040U
#define ISP_AWB_UNION_E1_AND_E4_SHIFT 6U
//! Slice: AWB_union_e1_and_e3:
//! unite ellipse 1 with ellipse 3. Accu and count for ellipse 3.
#define ISP_AWB_UNION_E1_AND_E3
#define ISP_AWB_UNION_E1_AND_E3_MASK 0x00000020U
#define ISP_AWB_UNION_E1_AND_E3_SHIFT 5U
//! Slice: AWB_union_e1_and_e2:
//! unite ellipse 1 with ellipse 2. Accu and count for ellipse 2.
#define ISP_AWB_UNION_E1_AND_E2
#define ISP_AWB_UNION_E1_AND_E2_MASK 0x00000010U
#define ISP_AWB_UNION_E1_AND_E2_SHIFT 4U
//! Slice: AWB_meas_chrom_switch:
//! Accumulates Q1 and Q2 chromaticies instead of R, G, B color signals. Results are written on AWB_ACCU registers as well.
#define ISP_AWB_MEAS_CHROM_SWITCH
#define ISP_AWB_MEAS_CHROM_SWITCH_MASK 0x00000008U
#define ISP_AWB_MEAS_CHROM_SWITCH_SHIFT 3U
//! Slice: AWB_meas_irq_enable:
//! AWB measure done IRQ enable.
#define ISP_AWB_MEAS_IRQ_ENABLE
#define ISP_AWB_MEAS_IRQ_ENABLE_MASK 0x00000004U
#define ISP_AWB_MEAS_IRQ_ENABLE_SHIFT 2U
//! Slice: AWB_pre_filt_en:
//! median pre filter enable.
#define ISP_AWB_PRE_FILT_EN
#define ISP_AWB_PRE_FILT_EN_MASK 0x00000002U
#define ISP_AWB_PRE_FILT_EN_SHIFT 1U
//! Slice: AWB_meas_en:
//! enable measure.
#define ISP_AWB_MEAS_EN
#define ISP_AWB_MEAS_EN_MASK 0x00000001U
#define ISP_AWB_MEAS_EN_SHIFT 0U

//! Register: awb_meas_h_offs: AWB window horizontal offset (0x00000004)
//! Slice: AWB_h_offset:
//! Horizontal offset in pixels.
#define ISP_AWB_H_OFFSET
#define ISP_AWB_H_OFFSET_MASK 0x00001FFFU
#define ISP_AWB_H_OFFSET_SHIFT 0U

//! Register: awb_meas_v_offs: AWB window vertical offset (0x00000008)
//! Slice: AWB_v_offset:
//! Vertical offset in pixels.
#define ISP_AWB_V_OFFSET
#define ISP_AWB_V_OFFSET_MASK 0x00001FFFU
#define ISP_AWB_V_OFFSET_SHIFT 0U

//! Register: awb_meas_h_size: Horizontal window size (0x0000000c)
//! Slice: AWB_h_size:
//! Horizontal size in pixels.
#define ISP_AWB_H_SIZE
#define ISP_AWB_H_SIZE_MASK 0x00003FFFU
#define ISP_AWB_H_SIZE_SHIFT 0U

//! Register: awb_meas_v_size: Vertical window size (0x00000010)
//! Slice: AWB_v_size:
//! Vertical size.
#define ISP_AWB_V_SIZE
#define ISP_AWB_V_SIZE_MASK 0x00003FFFU
#define ISP_AWB_V_SIZE_SHIFT 0U

//! Register: awb_meas_r_min_max: Min Max Compare Red (0x00000014)
//! Slice: r_max:
//! max red value
#define ISP_AWB_R_MAX
#define ISP_AWB_R_MAX_MASK 0x0000FF00U
#define ISP_AWB_R_MAX_SHIFT 8U
//! Slice: r_min:
//! min red value
#define ISP_AWB_R_MIN
#define ISP_AWB_R_MIN_MASK 0x000000FFU
#define ISP_AWB_R_MIN_SHIFT 0U

//! Register: awb_meas_g_min_max: Min Max Compare Green (0x00000018)
//! Slice: g_max:
//! max green value
#define ISP_AWB_G_MAX
#define ISP_AWB_G_MAX_MASK 0x0000FF00U
#define ISP_AWB_G_MAX_SHIFT 8U
//! Slice: g_min:
//! min green value
#define ISP_AWB_G_MIN
#define ISP_AWB_G_MIN_MASK 0x000000FFU
#define ISP_AWB_G_MIN_SHIFT 0U

//! Register: awb_meas_b_min_max: Min Max Compare Blue (0x0000001c)
//! Slice: b_max:
//! max blue value
#define ISP_AWB_B_MAX
#define ISP_AWB_B_MAX_MASK 0x0000FF00U
#define ISP_AWB_B_MAX_SHIFT 8U
//! Slice: b_min:
//! min blue value
#define ISP_AWB_B_MIN
#define ISP_AWB_B_MIN_MASK 0x000000FFU
#define ISP_AWB_B_MIN_SHIFT 0U

//! Register: awb_meas_divider_min: Min Compare Divider (0x00000020)
//! Slice: div_min:
//! min divider value unsigned integer with 10 fractional Bits range 0 to 0.999
#define ISP_AWB_DIV_MIN
#define ISP_AWB_DIV_MIN_MASK 0x000003FFU
#define ISP_AWB_DIV_MIN_SHIFT 0U

//! Register: awb_meas_csc_coeff_0: Color conversion coefficient 0 (0x00000024)
//! Slice: cc_coeff_0:
//! coefficient 0 for color space conversion
#define ISP_AWB_CC_COEFF_0
#define ISP_AWB_CC_COEFF_0_MASK 0x000007FFU
#define ISP_AWB_CC_COEFF_0_SHIFT 0U

//! Register: awb_meas_csc_coeff_1: Color conversion coefficient 1 (0x00000028)
//! Slice: cc_coeff_1:
//! coefficient 1 for color space conversion
#define ISP_AWB_CC_COEFF_1
#define ISP_AWB_CC_COEFF_1_MASK 0x000007FFU
#define ISP_AWB_CC_COEFF_1_SHIFT 0U

//! Register: awb_meas_csc_coeff_2: Color conversion coefficient 2 (0x0000002c)
//! Slice: cc_coeff_2:
//! coefficient 2 for color space conversion
#define ISP_AWB_CC_COEFF_2
#define ISP_AWB_CC_COEFF_2_MASK 0x000007FFU
#define ISP_AWB_CC_COEFF_2_SHIFT 0U

//! Register: awb_meas_csc_coeff_3: Color conversion coefficient 3 (0x00000030)
//! Slice: cc_coeff_3:
//! coefficient 3 for color space conversion
#define ISP_AWB_CC_COEFF_3
#define ISP_AWB_CC_COEFF_3_MASK 0x000007FFU
#define ISP_AWB_CC_COEFF_3_SHIFT 0U

//! Register: awb_meas_csc_coeff_4: Color conversion coefficient 4 (0x00000034)
//! Slice: cc_coeff_4:
//! coefficient 4 for color space conversion
#define ISP_AWB_CC_COEFF_4
#define ISP_AWB_CC_COEFF_4_MASK 0x000007FFU
#define ISP_AWB_CC_COEFF_4_SHIFT 0U

//! Register: awb_meas_csc_coeff_5: Color conversion coefficient 5 (0x00000038)
//! Slice: cc_coeff_5:
//! coefficient 5 for color space conversion
#define ISP_AWB_CC_COEFF_5
#define ISP_AWB_CC_COEFF_5_MASK 0x000007FFU
#define ISP_AWB_CC_COEFF_5_SHIFT 0U

//! Register: awb_meas_csc_coeff_6: Color conversion coefficient 6 (0x0000003c)
//! Slice: cc_coeff_6:
//! coefficient 6 for color space conversion
#define ISP_AWB_CC_COEFF_6
#define ISP_AWB_CC_COEFF_6_MASK 0x000007FFU
#define ISP_AWB_CC_COEFF_6_SHIFT 0U

//! Register: awb_meas_csc_coeff_7: Color conversion coefficient 7 (0x00000040)
//! Slice: cc_coeff_7:
//! coefficient 7 for color space conversion
#define ISP_AWB_CC_COEFF_7
#define ISP_AWB_CC_COEFF_7_MASK 0x000007FFU
#define ISP_AWB_CC_COEFF_7_SHIFT 0U

//! Register: awb_meas_csc_coeff_8: Color conversion coefficient 8 (0x00000044)
//! Slice: cc_coeff_8:
//! coefficient 8 for color space conversion
#define ISP_AWB_CC_COEFF_8
#define ISP_AWB_CC_COEFF_8_MASK 0x000007FFU
#define ISP_AWB_CC_COEFF_8_SHIFT 0U

//! Register: awb_meas_ellip1_cen_x: Ellipse 1 Center X (0x00000048)
//! Slice: ellip1_cen_x:
//! Ellipse 1 Center X signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP1_CEN_X
#define ISP_AWB_ELLIP1_CEN_X_MASK 0x000003FFU
#define ISP_AWB_ELLIP1_CEN_X_SHIFT 0U

//! Register: awb_meas_ellip1_cen_y: Ellipse 1 Center Y (0x0000004c)
//! Slice: ellip1_cen_y:
//! Ellipse 1 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP1_CEN_Y
#define ISP_AWB_ELLIP1_CEN_Y_MASK 0x000003FFU
#define ISP_AWB_ELLIP1_CEN_Y_SHIFT 0U

//! Register: awb_meas_ellip2_cen_x: Ellipse 2 Center X (0x00000050)
//! Slice: ellip2_cen_x:
//! Ellipse 2 Center X signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP2_CEN_X
#define ISP_AWB_ELLIP2_CEN_X_MASK 0x000003FFU
#define ISP_AWB_ELLIP2_CEN_X_SHIFT 0U

//! Register: awb_meas_ellip2_cen_y: Ellipse 2 Center Y (0x00000054)
//! Slice: ellip2_cen_y:
//! Ellipse 2 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP2_CEN_Y
#define ISP_AWB_ELLIP2_CEN_Y_MASK 0x000003FFU
#define ISP_AWB_ELLIP2_CEN_Y_SHIFT 0U

//! Register: awb_meas_ellip3_cen_x: Ellipse 3 Center X (0x00000058)
//! Slice: ellip3_cen_x:
//! Ellipse 3 Center X signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP3_CEN_X
#define ISP_AWB_ELLIP3_CEN_X_MASK 0x000003FFU
#define ISP_AWB_ELLIP3_CEN_X_SHIFT 0U

//! Register: awb_meas_ellip3_cen_y: Ellipse 3 Center Y (0x0000005c)
//! Slice: ellip3_cen_y:
//! Ellipse 3 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP3_CEN_Y
#define ISP_AWB_ELLIP3_CEN_Y_MASK 0x000003FFU
#define ISP_AWB_ELLIP3_CEN_Y_SHIFT 0U

//! Register: awb_meas_ellip4_cen_x: Ellipse 4 Center X (0x00000060)
//! Slice: ellip4_cen_x:
//! Ellipse 4 Center X signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP4_CEN_X
#define ISP_AWB_ELLIP4_CEN_X_MASK 0x000003FFU
#define ISP_AWB_ELLIP4_CEN_X_SHIFT 0U

//! Register: awb_meas_ellip4_cen_y: Ellipse 4 Center Y (0x00000064)
//! Slice: ellip4_cen_y:
//! Ellipse 4 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP4_CEN_Y
#define ISP_AWB_ELLIP4_CEN_Y_MASK 0x000003FFU
#define ISP_AWB_ELLIP4_CEN_Y_SHIFT 0U

//! Register: awb_meas_ellip5_cen_x: Ellipse 5 Center X (0x00000068)
//! Slice: ellip5_cen_x:
//! Ellipse 5 Center X signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP5_CEN_X
#define ISP_AWB_ELLIP5_CEN_X_MASK 0x000003FFU
#define ISP_AWB_ELLIP5_CEN_X_SHIFT 0U

//! Register: awb_meas_ellip5_cen_y: Ellipse 5 Center Y (0x0000006c)
//! Slice: ellip5_cen_y:
//! Ellipse 5 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP5_CEN_Y
#define ISP_AWB_ELLIP5_CEN_Y_MASK 0x000003FFU
#define ISP_AWB_ELLIP5_CEN_Y_SHIFT 0U

//! Register: awb_meas_ellip6_cen_x: Ellipse 6 Center X (0x00000070)
//! Slice: ellip6_cen_x:
//! Ellipse 6 Center X signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP6_CEN_X
#define ISP_AWB_ELLIP6_CEN_X_MASK 0x000003FFU
#define ISP_AWB_ELLIP6_CEN_X_SHIFT 0U

//! Register: awb_meas_ellip6_cen_y: Ellipse 6 Center Y (0x00000074)
//! Slice: ellip6_cen_y:
//! Ellipse 6 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP6_CEN_Y
#define ISP_AWB_ELLIP6_CEN_Y_MASK 0x000003FFU
#define ISP_AWB_ELLIP6_CEN_Y_SHIFT 0U

//! Register: awb_meas_ellip7_cen_x: Ellipse 7 Center X (0x00000078)
//! Slice: ellip7_cen_x:
//! Ellipse 7 Center X signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP7_CEN_X
#define ISP_AWB_ELLIP7_CEN_X_MASK 0x000003FFU
#define ISP_AWB_ELLIP7_CEN_X_SHIFT 0U

//! Register: awb_meas_ellip7_cen_y: Ellipse 7 Center Y (0x0000007c)
//! Slice: ellip7_cen_y:
//! Ellipse 7 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP7_CEN_Y
#define ISP_AWB_ELLIP7_CEN_Y_MASK 0x000003FFU
#define ISP_AWB_ELLIP7_CEN_Y_SHIFT 0U

//! Register: awb_meas_ellip8_cen_x: Ellipse 8 Center X (0x00000080)
//! Slice: ellip8_cen_x:
//! Ellipse 8 Center X signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP8_CEN_X
#define ISP_AWB_ELLIP8_CEN_X_MASK 0x000003FFU
#define ISP_AWB_ELLIP8_CEN_X_SHIFT 0U

//! Register: awb_meas_ellip8_cen_y: Ellipse 8 Center Y (0x00000084)
//! Slice: ellip8_cen_y:
//! Ellipse 8 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998
#define ISP_AWB_ELLIP8_CEN_Y
#define ISP_AWB_ELLIP8_CEN_Y_MASK 0x000003FFU
#define ISP_AWB_ELLIP8_CEN_Y_SHIFT 0U

//! Register: awb_meas_ellip1_a1: Ellipse 1 coefficient a1 (0x00000088)
//! Slice: ellip1_a1:
//! Ellipse 1 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP1_A1
#define ISP_AWB_ELLIP1_A1_MASK 0x00000FFFU
#define ISP_AWB_ELLIP1_A1_SHIFT 0U

//! Register: awb_meas_ellip1_a2: Ellipse 1 coefficient a2 (0x0000008c)
//! Slice: ellip1_a2:
//! Ellipse 1 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP1_A2
#define ISP_AWB_ELLIP1_A2_MASK 0x000001FFU
#define ISP_AWB_ELLIP1_A2_SHIFT 0U

//! Register: awb_meas_ellip1_a3: Ellipse 1 coefficient a3 (0x00000090)
//! Slice: ellip1_a3:
//! Ellipse 1 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP1_A3
#define ISP_AWB_ELLIP1_A3_MASK 0x00000FFFU
#define ISP_AWB_ELLIP1_A3_SHIFT 0U

//! Register: awb_meas_ellip1_a4: Ellipse 1 coefficient a4 (0x00000094)
//! Slice: ellip1_a4:
//! Ellipse 1 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP1_A4
#define ISP_AWB_ELLIP1_A4_MASK 0x000001FFU
#define ISP_AWB_ELLIP1_A4_SHIFT 0U

//! Register: awb_meas_ellip2_a1: Ellipse 2 coefficient a1 (0x00000098)
//! Slice: ellip2_a1:
//! Ellipse 2 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP2_A1
#define ISP_AWB_ELLIP2_A1_MASK 0x00000FFFU
#define ISP_AWB_ELLIP2_A1_SHIFT 0U

//! Register: awb_meas_ellip2_a2: Ellipse 2 coefficient a2 (0x0000009c)
//! Slice: ellip2_a2:
//! Ellipse 2 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP2_A2
#define ISP_AWB_ELLIP2_A2_MASK 0x000001FFU
#define ISP_AWB_ELLIP2_A2_SHIFT 0U

//! Register: awb_meas_ellip2_a3: Ellipse 2 coefficient a3 (0x000000a0)
//! Slice: ellip2_a3:
//! Ellipse 2 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP2_A3
#define ISP_AWB_ELLIP2_A3_MASK 0x00000FFFU
#define ISP_AWB_ELLIP2_A3_SHIFT 0U

//! Register: awb_meas_ellip2_a4: Ellipse 2 coefficient a4 (0x000000a4)
//! Slice: ellip2_a4:
//! Ellipse 2 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP2_A4
#define ISP_AWB_ELLIP2_A4_MASK 0x000001FFU
#define ISP_AWB_ELLIP2_A4_SHIFT 0U

//! Register: awb_meas_ellip3_a1: Ellipse 3 coefficient a1 (0x000000a8)
//! Slice: ellip3_a1:
//! Ellipse 3 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP3_A1
#define ISP_AWB_ELLIP3_A1_MASK 0x00000FFFU
#define ISP_AWB_ELLIP3_A1_SHIFT 0U

//! Register: awb_meas_ellip3_a2: Ellipse 3 coefficient a2 (0x000000ac)
//! Slice: ellip3_a2:
//! Ellipse 3 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP3_A2
#define ISP_AWB_ELLIP3_A2_MASK 0x000001FFU
#define ISP_AWB_ELLIP3_A2_SHIFT 0U

//! Register: awb_meas_ellip3_a3: Ellipse 3 coefficient a3 (0x000000b0)
//! Slice: ellip3_a3:
//! Ellipse 3 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP3_A3
#define ISP_AWB_ELLIP3_A3_MASK 0x00000FFFU
#define ISP_AWB_ELLIP3_A3_SHIFT 0U

//! Register: awb_meas_ellip3_a4: Ellipse 3 coefficient a4 (0x000000b4)
//! Slice: ellip3_a4:
//! Ellipse 3 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP3_A4
#define ISP_AWB_ELLIP3_A4_MASK 0x000001FFU
#define ISP_AWB_ELLIP3_A4_SHIFT 0U

//! Register: awb_meas_ellip4_a1: Ellipse 4 coefficient a1 (0x000000b8)
//! Slice: ellip4_a1:
//! Ellipse 4 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP4_A1
#define ISP_AWB_ELLIP4_A1_MASK 0x00000FFFU
#define ISP_AWB_ELLIP4_A1_SHIFT 0U

//! Register: awb_meas_ellip4_a2: Ellipse 4 coefficient a2 (0x000000bc)
//! Slice: ellip4_a2:
//! Ellipse 4 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP4_A2
#define ISP_AWB_ELLIP4_A2_MASK 0x000001FFU
#define ISP_AWB_ELLIP4_A2_SHIFT 0U

//! Register: awb_meas_ellip4_a3: Ellipse 4 coefficient a3 (0x000000c0)
//! Slice: ellip4_a3:
//! Ellipse 4 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP4_A3
#define ISP_AWB_ELLIP4_A3_MASK 0x00000FFFU
#define ISP_AWB_ELLIP4_A3_SHIFT 0U

//! Register: awb_meas_ellip4_a4: Ellipse 4 coefficient a4 (0x000000c4)
//! Slice: ellip4_a4:
//! Ellipse 4 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP4_A4
#define ISP_AWB_ELLIP4_A4_MASK 0x000001FFU
#define ISP_AWB_ELLIP4_A4_SHIFT 0U

//! Register: awb_meas_ellip5_a1: Ellipse 5 coefficient a1 (0x000000c8)
//! Slice: ellip5_a1:
//! Ellipse 5 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP5_A1
#define ISP_AWB_ELLIP5_A1_MASK 0x00000FFFU
#define ISP_AWB_ELLIP5_A1_SHIFT 0U

//! Register: awb_meas_ellip5_a2: Ellipse 5 coefficient a2 (0x000000cc)
//! Slice: ellip5_a2:
//! Ellipse 5 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP5_A2
#define ISP_AWB_ELLIP5_A2_MASK 0x000001FFU
#define ISP_AWB_ELLIP5_A2_SHIFT 0U

//! Register: awb_meas_ellip5_a3: Ellipse 5 coefficient a3 (0x000000d0)
//! Slice: ellip5_a3:
//! Ellipse 5 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP5_A3
#define ISP_AWB_ELLIP5_A3_MASK 0x00000FFFU
#define ISP_AWB_ELLIP5_A3_SHIFT 0U

//! Register: awb_meas_ellip5_a4: Ellipse 5 coefficient a4 (0x000000d4)
//! Slice: ellip5_a4:
//! Ellipse 5 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP5_A4
#define ISP_AWB_ELLIP5_A4_MASK 0x000001FFU
#define ISP_AWB_ELLIP5_A4_SHIFT 0U

//! Register: awb_meas_ellip6_a1: Ellipse 6 coefficient a1 (0x000000d8)
//! Slice: ellip6_a1:
//! Ellipse 6 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP6_A1
#define ISP_AWB_ELLIP6_A1_MASK 0x00000FFFU
#define ISP_AWB_ELLIP6_A1_SHIFT 0U

//! Register: awb_meas_ellip6_a2: Ellipse 6 coefficient a2 (0x000000dc)
//! Slice: ellip6_a2:
//! Ellipse 6 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP6_A2
#define ISP_AWB_ELLIP6_A2_MASK 0x000001FFU
#define ISP_AWB_ELLIP6_A2_SHIFT 0U

//! Register: awb_meas_ellip6_a3: Ellipse 6 coefficient a3 (0x000000e0)
//! Slice: ellip6_a3:
//! Ellipse 6 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP6_A3
#define ISP_AWB_ELLIP6_A3_MASK 0x00000FFFU
#define ISP_AWB_ELLIP6_A3_SHIFT 0U

//! Register: awb_meas_ellip6_a4: Ellipse 6 coefficient a4 (0x000000e4)
//! Slice: ellip6_a4:
//! Ellipse 6 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP6_A4
#define ISP_AWB_ELLIP6_A4_MASK 0x000001FFU
#define ISP_AWB_ELLIP6_A4_SHIFT 0U

//! Register: awb_meas_ellip7_a1: Ellipse 7 coefficient a1 (0x000000e8)
//! Slice: ellip7_a1:
//! Ellipse 7 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP7_A1
#define ISP_AWB_ELLIP7_A1_MASK 0x00000FFFU
#define ISP_AWB_ELLIP7_A1_SHIFT 0U

//! Register: awb_meas_ellip7_a2: Ellipse 7 coefficient a2 (0x000000ec)
//! Slice: ellip7_a2:
//! Ellipse 7 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP7_A2
#define ISP_AWB_ELLIP7_A2_MASK 0x000001FFU
#define ISP_AWB_ELLIP7_A2_SHIFT 0U

//! Register: awb_meas_ellip7_a3: Ellipse 7 coefficient a3 (0x000000f0)
//! Slice: ellip7_a3:
//! Ellipse 7 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP7_A3
#define ISP_AWB_ELLIP7_A3_MASK 0x00000FFFU
#define ISP_AWB_ELLIP7_A3_SHIFT 0U

//! Register: awb_meas_ellip7_a4: Ellipse 7 coefficient a4 (0x000000f4)
//! Slice: ellip7_a4:
//! Ellipse 7 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP7_A4
#define ISP_AWB_ELLIP7_A4_MASK 0x000001FFU
#define ISP_AWB_ELLIP7_A4_SHIFT 0U

//! Register: awb_meas_ellip8_a1: Ellipse 8 coefficient a1 (0x000000f8)
//! Slice: ellip8_a1:
//! Ellipse 8 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP8_A1
#define ISP_AWB_ELLIP8_A1_MASK 0x00000FFFU
#define ISP_AWB_ELLIP8_A1_SHIFT 0U

//! Register: awb_meas_ellip8_a2: Ellipse 8 coefficient a2 (0x000000fc)
//! Slice: ellip8_a2:
//! Ellipse 8 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP8_A2
#define ISP_AWB_ELLIP8_A2_MASK 0x000001FFU
#define ISP_AWB_ELLIP8_A2_SHIFT 0U

//! Register: awb_meas_ellip8_a3: Ellipse 8 coefficient a3 (0x00000100)
//! Slice: ellip8_a3:
//! Ellipse 8 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996
#define ISP_AWB_ELLIP8_A3
#define ISP_AWB_ELLIP8_A3_MASK 0x00000FFFU
#define ISP_AWB_ELLIP8_A3_SHIFT 0U

//! Register: awb_meas_ellip8_a4: Ellipse 8 coefficient a4 (0x00000104)
//! Slice: ellip8_a4:
//! Ellipse 8 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996
#define ISP_AWB_ELLIP8_A4
#define ISP_AWB_ELLIP8_A4_MASK 0x000001FFU
#define ISP_AWB_ELLIP8_A4_SHIFT 0U

//! Register: awb_meas_ellip1_rmax: Ellipse 1 r_max (0x00000108)
//! Slice: ellip1_rmax:
//! Ellipse 1 max radius square compare value
#define ISP_AWB_ELLIP1_RMAX
#define ISP_AWB_ELLIP1_RMAX_MASK 0x00FFFFFFU
#define ISP_AWB_ELLIP1_RMAX_SHIFT 0U

//! Register: awb_meas_ellip2_rmax: Ellipse 2 r_max (0x0000010c)
//! Slice: ellip2_rmax:
//! Ellipse 2 max radius square compare value
#define ISP_AWB_ELLIP2_RMAX
#define ISP_AWB_ELLIP2_RMAX_MASK 0x00FFFFFFU
#define ISP_AWB_ELLIP2_RMAX_SHIFT 0U

//! Register: awb_meas_ellip3_rmax: Ellipse 3 r_max (0x00000110)
//! Slice: ellip3_rmax:
//! Ellipse 3 max radius square compare value
#define ISP_AWB_ELLIP3_RMAX
#define ISP_AWB_ELLIP3_RMAX_MASK 0x00FFFFFFU
#define ISP_AWB_ELLIP3_RMAX_SHIFT 0U

//! Register: awb_meas_ellip4_rmax: Ellipse 4 r_max (0x00000114)
//! Slice: ellip4_rmax:
//! Ellipse 4 max radius square compare value
#define ISP_AWB_ELLIP4_RMAX
#define ISP_AWB_ELLIP4_RMAX_MASK 0x00FFFFFFU
#define ISP_AWB_ELLIP4_RMAX_SHIFT 0U

//! Register: awb_meas_ellip5_rmax: Ellipse 5 r_max (0x00000118)
//! Slice: ellip5_rmax:
//! Ellipse 5 max radius square compare value
#define ISP_AWB_ELLIP5_RMAX
#define ISP_AWB_ELLIP5_RMAX_MASK 0x00FFFFFFU
#define ISP_AWB_ELLIP5_RMAX_SHIFT 0U

//! Register: awb_meas_ellip6_rmax: Ellipse 6 r_max (0x0000011c)
//! Slice: ellip6_rmax:
//! Ellipse 6 max radius square compare value
#define ISP_AWB_ELLIP6_RMAX
#define ISP_AWB_ELLIP6_RMAX_MASK 0x00FFFFFFU
#define ISP_AWB_ELLIP6_RMAX_SHIFT 0U

//! Register: awb_meas_ellip7_rmax: Ellipse 7 r_max (0x00000120)
//! Slice: ellip7_rmax:
//! Ellipse 7 max radius square compare value
#define ISP_AWB_ELLIP7_RMAX
#define ISP_AWB_ELLIP7_RMAX_MASK 0x00FFFFFFU
#define ISP_AWB_ELLIP7_RMAX_SHIFT 0U

//! Register: awb_meas_ellip8_rmax: Ellipse 8 r_max (0x00000124)
//! Slice: ellip8_rmax:
//! Ellipse 8 max radius square compare value
#define ISP_AWB_ELLIP8_RMAX
#define ISP_AWB_ELLIP8_RMAX_MASK 0x00FFFFFFU
#define ISP_AWB_ELLIP8_RMAX_SHIFT 0U

//! Register: awb_meas_counter_1: AWB Counter 1 (0x00000128)
//! Slice: count_1:
//! counted Pixels of Ellipse 1
#define ISP_AWB_COUNT_1
#define ISP_AWB_COUNT_1_MASK 0x00FFFFFFU
#define ISP_AWB_COUNT_1_SHIFT 0U

//! Register: awb_meas_counter_2: AWB Counter 2 (0x0000012c)
//! Slice: count_2:
//! counted Pixels of Ellipse 2
#define ISP_AWB_COUNT_2
#define ISP_AWB_COUNT_2_MASK 0x00FFFFFFU
#define ISP_AWB_COUNT_2_SHIFT 0U

//! Register: awb_meas_counter_3: AWB Counter 3 (0x00000130)
//! Slice: count_3:
//! counted Pixels of Ellipse 3
#define ISP_AWB_COUNT_3
#define ISP_AWB_COUNT_3_MASK 0x00FFFFFFU
#define ISP_AWB_COUNT_3_SHIFT 0U

//! Register: awb_meas_counter_4: AWB Counter 4 (0x00000134)
//! Slice: count_4:
//! counted Pixels of Ellipse 4
#define ISP_AWB_COUNT_4
#define ISP_AWB_COUNT_4_MASK 0x00FFFFFFU
#define ISP_AWB_COUNT_4_SHIFT 0U

//! Register: awb_meas_counter_5: AWB Counter 5 (0x00000138)
//! Slice: count_5:
//! counted Pixels of Ellipse 5
#define ISP_AWB_COUNT_5
#define ISP_AWB_COUNT_5_MASK 0x00FFFFFFU
#define ISP_AWB_COUNT_5_SHIFT 0U

//! Register: awb_meas_counter_6: AWB Counter 6 (0x0000013c)
//! Slice: count_6:
//! counted Pixels of Ellipse 6
#define ISP_AWB_COUNT_6
#define ISP_AWB_COUNT_6_MASK 0x00FFFFFFU
#define ISP_AWB_COUNT_6_SHIFT 0U

//! Register: awb_meas_counter_7: AWB Counter 7 (0x00000140)
//! Slice: count_7:
//! counted Pixels of Ellipse 7
#define ISP_AWB_COUNT_7
#define ISP_AWB_COUNT_7_MASK 0x00FFFFFFU
#define ISP_AWB_COUNT_7_SHIFT 0U

//! Register: awb_meas_counter_8: AWB Counter 8 (0x00000144)
//! Slice: count_8:
//! counted Pixels of Ellipse 8
#define ISP_AWB_COUNT_8
#define ISP_AWB_COUNT_8_MASK 0x00FFFFFFU
#define ISP_AWB_COUNT_8_SHIFT 0U

//! Register array: awb_meas_accu: AWB Accu Read (0x290 + n*0x4 (n=0..23))
//! Slice: read_accu:
// measured sum[34:3] of RGB values.
#define ISP_AWB_READ_ACCU
#define ISP_AWB_READ_ACCU_MASK 0xFFFFFFFFU
#define ISP_AWB_READ_ACCU_SHIFT 0U

//! Register: isp64_hist_ctrl: Histogram control (0x00000000)
//! Slice: hist_update_enable:
//! 0: automatic register update at end of measuement ot frame denied 
// 1: automatic register update at end of measuement ot frame enabled.
#define MRV_HIST_UPDATE_ENABLE
#define MRV_HIST_UPDATE_ENABLE_MASK 0x00000001U
#define MRV_HIST_UPDATE_ENABLE_SHIFT 0U

//! Register: isp64_hist_prop: Histogram properties (0x00000004)
//! Slice: channel_select:
//! select 1 out of max. 8 input channels 
// 7: channel 7 
// 6: channel 6 
// 5: channel 5 
// 4: channel 4 
// 3: channel 3 
// 2: channel 2 
// 1: channel 1 
// 0: channel 0 
// The channels might be RGB or Bayer channels. Each channel provides 3 subchannels for tranfer the RGB component data. However if the channel operates in bayer mode only subchannel 0 is used transferring the interleaved bayer pattern data. Check with top level specification to discover the channel type.
#define MRV_HIST_CHANNEL_SELECT
#define MRV_HIST_CHANNEL_SELECT_MASK 0x00000038U
#define MRV_HIST_CHANNEL_SELECT_SHIFT 3U
//! Slice: hist_mode:
//! histogram mode (RGB/Bayer)
// 7, 6: reserved 
// 5: bayer Gb histogram 
// 4: bayer B histogram 
// 3: bayer Gr histogram 
// 2: bayer R histogram 
// 1: Y/R/G/B histogram controlled via coefficients coeff_r/g/b 
// 0: disable, no measurements 
// With histogram mode 1 all three subchannels are used. Modes 2...5 use only th subchannel 0 which transfers the bayer pattern data. Check with top level specification to discover the channel type.
#define MRV_HIST_MODE
#define MRV_HIST_MODE_MASK 0x00000007U
#define MRV_HIST_MODE_SHIFT 0U

//! Register: isp64_hist_subsampling: Subsampling properties (0x00000008)
//! Slice: v_stepsize:
//! histogram veritcal predivider, process every (stepsize)th line, all other lines are skipped 
// RGB mode: 
// 0: not allowed 
// 1: process every input line 
// 2: process every second line 
// 3: process every third input line 
// 4: process every fourth input line 
// ... 
// 7FH: process every 127th line 
// Bayer mode: 
// 0: not allowed 
// 1: process every second input line 
// 2: process every fourth line 
// 3: process every sixth input line 
// 4: process every eighth input line 
// ... 
// 7FH: process every 254th line 
// In bayer mode vertical subsampling will start at the 1st input line which contain the bayer component selected in ISP64_HIST_PROP::hist_mode.
#define MRV_HIST_V_STEPSIZE
#define MRV_HIST_V_STEPSIZE_MASK 0x7F000000U
#define MRV_HIST_V_STEPSIZE_SHIFT 24U
//! Slice: h_step_inc:
//! horizontal subsampling step counter increment. 
// In RGB mode the subsampling counter cnt is incremented by h_step_inc with every input pixel (cnt %= cnt + h_step_inc). A valid subsampling position is reached when cnt would result in a value %= 2^16. In this case the new counter value is cnt = cnt + h_step_inc - 2^16. For example if every incoming pixel shall be selected configure h_step_inc = 2^16. 
// In Bayer mode the behaviour is similar but for the fact that cnt is only incremented for pixels which belong to the bayer component selected in ISP64_HIST_PROP::hist_mode.
#define MRV_HIST_H_STEP_INC
#define MRV_HIST_H_STEP_INC_MASK 0x0001FFFFU
#define MRV_HIST_H_STEP_INC_SHIFT 0U

//! Register: isp64_hist_coeff_r: Color conversion coefficient for red (0x0000000c)
//! Slice: coeff_r:
//! coefficient for red for weighted component sum: out_sample = coeff_r * red + coeff_g*green + coeff_b * blue.
#define MRV_HIST_COEFF_R
#define MRV_HIST_COEFF_R_MASK 0x000000FFU
#define MRV_HIST_COEFF_R_SHIFT 0U

//! Register: isp64_hist_coeff_g: Color conversion coefficient for green (0x00000010)
//! Slice: coeff_g:
//! coefficient for green for weighted component sum: out_sample = coeff_r * red + coeff_g*green + coeff_b * blue.
#define MRV_HIST_COEFF_G
#define MRV_HIST_COEFF_G_MASK 0x000000FFU
#define MRV_HIST_COEFF_G_SHIFT 0U

//! Register: isp64_hist_coeff_b: Color conversion coefficient for blue (0x00000014)
//! Slice: coeff_b:
//! coefficient for blue for weighted component sum: out_sample = coeff_r * red + coeff_g*green + coeff_b * blue.
#define MRV_HIST_COEFF_B
#define MRV_HIST_COEFF_B_MASK 0x000000FFU
#define MRV_HIST_COEFF_B_SHIFT 0U

//! Register: isp64_hist_h_offs: Histogram window horizontal offset for first window of 25 sub-windows (0x00000018)
//! Slice: hist_h_offset:
//! Horizontal offset of first window in pixels.
#define MRV_HIST_H_OFFSET
#define MRV_HIST_H_OFFSET_MASK 0x00001FFFU
#define MRV_HIST_H_OFFSET_SHIFT 0U

//! Register: isp64_hist_v_offs: Histogram window vertical offset for first window of 25 sub-windows (0x0000001c)
//! Slice: hist_v_offset:
//! Vertical offset of first window in pixels.
#define MRV_HIST_V_OFFSET
#define MRV_HIST_V_OFFSET_MASK 0x00001FFFU
#define MRV_HIST_V_OFFSET_SHIFT 0U

//! Register: isp64_hist_h_size: Horizontal (sub-)window size (0x00000020)
//! Slice: hist_h_size:
//! Horizontal size in pixels of one sub-window.
#define MRV_HIST_H_SIZE
#define MRV_HIST_H_SIZE_MASK 0x000007FFU
#define MRV_HIST_H_SIZE_SHIFT 0U

//! Register: isp64_hist_v_size: Vertical (sub-)window size (0x00000024)
//! Slice: hist_v_size:
//! Vertical size in lines of one sub-window.
#define MRV_HIST_V_SIZE
#define MRV_HIST_V_SIZE_MASK 0x000007FFU
#define MRV_HIST_V_SIZE_SHIFT 0U

//! Register: isp64_hist_sample_range: Weighting factor for sub-windows (0x00000028)
//! Slice: sample_shift:
//! sample (left) shift will be executed after offset subtraction and prior to histogram evaluation
#define MRV_HIST_SAMPLE_SHIFT
#define MRV_HIST_SAMPLE_SHIFT_MASK 0x00070000U
#define MRV_HIST_SAMPLE_SHIFT_SHIFT 16U
//! Slice: sample_offset:
//! sample offset will be subtracted from input sample prior to shift and histogram evaluation
#define MRV_HIST_SAMPLE_OFFSET
#define MRV_HIST_SAMPLE_OFFSET_MASK 0x00000FFFU
#define MRV_HIST_SAMPLE_OFFSET_SHIFT 0U

//! Register: isp64_hist_weight_00to30: Weighting factor for sub-windows (0x0000002c)
//! Slice: hist_weight_30:
//! weighting factor for sub-window 30
#define MRV_HIST_WEIGHT_30
#define MRV_HIST_WEIGHT_30_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_30_SHIFT 24U
//! Slice: hist_weight_20:
//! weighting factor for sub-window 20
#define MRV_HIST_WEIGHT_20
#define MRV_HIST_WEIGHT_20_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_20_SHIFT 16U
//! Slice: hist_weight_10:
//! weighting factor for sub-window 10
#define MRV_HIST_WEIGHT_10
#define MRV_HIST_WEIGHT_10_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_10_SHIFT 8U
//! Slice: hist_weight_00:
//! weighting factor for sub-window 00
#define MRV_HIST_WEIGHT_00
#define MRV_HIST_WEIGHT_00_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_00_SHIFT 0U

//! Register: isp64_hist_weight_40to21: Weighting factor for sub-windows (0x00000030)
//! Slice: hist_weight_21:
//! weighting factor for sub-window 21
#define MRV_HIST_WEIGHT_21
#define MRV_HIST_WEIGHT_21_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_21_SHIFT 24U
//! Slice: hist_weight_11:
//! weighting factor for sub-window 11
#define MRV_HIST_WEIGHT_11
#define MRV_HIST_WEIGHT_11_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_11_SHIFT 16U
//! Slice: hist_weight_01:
//! weighting factor for sub-window 01
#define MRV_HIST_WEIGHT_01
#define MRV_HIST_WEIGHT_01_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_01_SHIFT 8U
//! Slice: hist_weight_40:
//! weighting factor for sub-window 40
#define MRV_HIST_WEIGHT_40
#define MRV_HIST_WEIGHT_40_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_40_SHIFT 0U

//! Register: isp64_hist_weight_31to12: Weighting factor for sub-windows (0x00000034)
//! Slice: hist_weight_12:
//! weighting factor for sub-window 12
#define MRV_HIST_WEIGHT_12
#define MRV_HIST_WEIGHT_12_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_12_SHIFT 24U
//! Slice: hist_weight_02:
//! weighting factor for sub-window 02
#define MRV_HIST_WEIGHT_02
#define MRV_HIST_WEIGHT_02_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_02_SHIFT 16U
//! Slice: hist_weight_41:
//! weighting factor for sub-window 41
#define MRV_HIST_WEIGHT_41
#define MRV_HIST_WEIGHT_41_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_41_SHIFT 8U
//! Slice: hist_weight_31:
//! weighting factor for sub-window 31
#define MRV_HIST_WEIGHT_31
#define MRV_HIST_WEIGHT_31_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_31_SHIFT 0U

//! Register: isp64_hist_weight_22to03: Weighting factor for sub-windows (0x00000038)
//! Slice: hist_weight_03:
//! weighting factor for sub-window 03
#define MRV_HIST_WEIGHT_03
#define MRV_HIST_WEIGHT_03_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_03_SHIFT 24U
//! Slice: hist_weight_42:
//! weighting factor for sub-window 42
#define MRV_HIST_WEIGHT_42
#define MRV_HIST_WEIGHT_42_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_42_SHIFT 16U
//! Slice: hist_weight_32:
//! weighting factor for sub-window 32
#define MRV_HIST_WEIGHT_32
#define MRV_HIST_WEIGHT_32_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_32_SHIFT 8U
//! Slice: hist_weight_22:
//! weighting factor for sub-window 22
#define MRV_HIST_WEIGHT_22
#define MRV_HIST_WEIGHT_22_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_22_SHIFT 0U

//! Register: isp64_hist_weight_13to43: Weighting factor for sub-windows (0x0000003c)
//! Slice: hist_weight_43:
//! weighting factor for sub-window 43
#define MRV_HIST_WEIGHT_43
#define MRV_HIST_WEIGHT_43_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_43_SHIFT 24U
//! Slice: hist_weight_33:
//! weighting factor for sub-window 33
#define MRV_HIST_WEIGHT_33
#define MRV_HIST_WEIGHT_33_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_33_SHIFT 16U
//! Slice: hist_weight_23:
//! weighting factor for sub-window 23
#define MRV_HIST_WEIGHT_23
#define MRV_HIST_WEIGHT_23_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_23_SHIFT 8U
//! Slice: hist_weight_13:
//! weighting factor for sub-window 13
#define MRV_HIST_WEIGHT_13
#define MRV_HIST_WEIGHT_13_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_13_SHIFT 0U

//! Register: isp64_hist_weight_04to34: Weighting factor for sub-windows (0x00000040)
//! Slice: hist_weight_34:
//! weighting factor for sub-window 34
#define MRV_HIST_WEIGHT_34
#define MRV_HIST_WEIGHT_34_MASK 0x1F000000U
#define MRV_HIST_WEIGHT_34_SHIFT 24U
//! Slice: hist_weight_24:
//! weighting factor for sub-window 24
#define MRV_HIST_WEIGHT_24
#define MRV_HIST_WEIGHT_24_MASK 0x001F0000U
#define MRV_HIST_WEIGHT_24_SHIFT 16U
//! Slice: hist_weight_14:
//! weighting factor for sub-window 14
#define MRV_HIST_WEIGHT_14
#define MRV_HIST_WEIGHT_14_MASK 0x00001F00U
#define MRV_HIST_WEIGHT_14_SHIFT 8U
//! Slice: hist_weight_04:
//! weighting factor for sub-window 04
#define MRV_HIST_WEIGHT_04
#define MRV_HIST_WEIGHT_04_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_04_SHIFT 0U

//! Register: isp64_hist_weight_44: Weighting factor for sub-windows (0x00000044)
//! Slice: hist_weight_44:
//! weighting factor for sub-window 44
#define MRV_HIST_WEIGHT_44
#define MRV_HIST_WEIGHT_44_MASK 0x0000001FU
#define MRV_HIST_WEIGHT_44_SHIFT 0U

//! Register: isp64_hist_forced_upd_start_line: Forced update start line limit (0x00000048)
//! Slice: forced_upd_start_line:
//! start line for histogram calculation in case of forced update. histogram is started as soon as current line < forced_upd_start_line. Used start line will be given in ISP64_HIST_VSTART_STATUS.
#define MRV_HIST_FORCED_UPD_START_LINE
#define MRV_HIST_FORCED_UPD_START_LINE_MASK 0x00001FFFU
#define MRV_HIST_FORCED_UPD_START_LINE_SHIFT 0U

//! Register: isp64_hist_forced_update: Histogram forced update (0x0000004c)
//! Slice: forced_upd:
//! 0: no effect 
// 1: forcing register update.
#define MRV_HIST_FORCED_UPD
#define MRV_HIST_FORCED_UPD_MASK 0x00000001U
#define MRV_HIST_FORCED_UPD_SHIFT 0U

//! Register: isp64_hist_vstart_status: Forced update start line status (0x00000050)
//! Slice: hist_vstart_status:
//! start line for histogram. Important in case of backward switching because 1st histogram after switch might not cover the complete image.
#define MRV_HIST_VSTART_STATUS
#define MRV_HIST_VSTART_STATUS_MASK 0x00001FFFU
#define MRV_HIST_VSTART_STATUS_SHIFT 0U

//! Register array: isp64_hist_bin: histogram measurement result bin (0x0A8 + n*0x4 (n=0..31))
//! Slice: hist_bin:
// measured bin count as 16-bit unsigned integer value plus 4 bit fractional part
#define MRV_HIST_BIN
#define MRV_HIST_BIN_MASK 0x000FFFFFU
#define MRV_HIST_BIN_SHIFT 0U

//! Register: isp_vsm_mode: VS Measure Mode (0x00000000)
//! Slice: vsm_meas_irq_enable:
//! 1: VS measure done IRQ enable.
#define ISP_VSM_MEAS_IRQ_ENABLE
#define ISP_VSM_MEAS_IRQ_ENABLE_MASK 0x00000002U
#define ISP_VSM_MEAS_IRQ_ENABLE_SHIFT 1U
//! Slice: vsm_meas_en:
//! 1: enable measure.
#define ISP_VSM_MEAS_EN
#define ISP_VSM_MEAS_EN_MASK 0x00000001U
#define ISP_VSM_MEAS_EN_SHIFT 0U

//! Register: isp_vsm_h_offs: VSM window horizontal offset (0x00000004)
//! Slice: vsm_h_offset:
//! Horizontal offset in pixels.
#define ISP_VSM_H_OFFSET
#define ISP_VSM_H_OFFSET_MASK 0x00001FFFU
#define ISP_VSM_H_OFFSET_SHIFT 0U

//! Register: isp_vsm_v_offs: VSM window vertical offset (0x00000008)
//! Slice: vsm_v_offset:
//! Vertical offset in pixels.
#define ISP_VSM_V_OFFSET
#define ISP_VSM_V_OFFSET_MASK 0x00001FFFU
#define ISP_VSM_V_OFFSET_SHIFT 0U

//! Register: isp_vsm_h_size: Horizontal measure window size (0x0000000c)
//! Slice: vsm_h_size:
//! Horizontal size in pixels. Range 64..1920
#define ISP_VSM_H_SIZE
#define ISP_VSM_H_SIZE_MASK 0x000007FEU
#define ISP_VSM_H_SIZE_SHIFT 1U

//! Register: isp_vsm_v_size: Vertical measure window size (0x00000010)
//! Slice: vsm_v_size:
//! Vertical size. Range 64..1088
#define ISP_VSM_V_SIZE
#define ISP_VSM_V_SIZE_MASK 0x000007FEU
#define ISP_VSM_V_SIZE_SHIFT 1U

//! Register: isp_vsm_h_segments: Iteration 1 horizontal segments (0x00000014)
//! Slice: vsm_h_segments:
//! number of 16 point wide segments enclosed by the first iteration sample points in horizontal direction. Range: 1 ... 128
#define ISP_VSM_H_SEGMENTS
#define ISP_VSM_H_SEGMENTS_MASK 0x000000FFU
#define ISP_VSM_H_SEGMENTS_SHIFT 0U

//! Register: isp_vsm_v_segments: Iteration 1 vertical segments (0x00000018)
//! Slice: vsm_v_segments:
//! number of 16 point wide segments enclosed by the first iteration sample points in vertical direction. Range: 1 ... 128
#define ISP_VSM_V_SEGMENTS
#define ISP_VSM_V_SEGMENTS_MASK 0x000000FFU
#define ISP_VSM_V_SEGMENTS_SHIFT 0U

//! Register: isp_vsm_delta_h: estimated horizontal displacement (0x0000001c)
//! Slice: delta_h:
//! estimated horizontal displacement 12Bit two's complement. positive values indicate a displacement of the image from right to left (camera turns right)
#define ISP_VSM_DELTA_H
#define ISP_VSM_DELTA_H_MASK 0x00000FFFU
#define ISP_VSM_DELTA_H_SHIFT 0U

//! Register: isp_vsm_delta_v: estimated vertical displacement (0x00000020)
//! Slice: delta_v:
//! estimated vertical displacement 12Bit two's complement. positive values indicate a displacement of the image from bottom to top (camera turns down)
#define ISP_VSM_DELTA_V
#define ISP_VSM_DELTA_V_MASK 0x00000FFFU
#define ISP_VSM_DELTA_V_SHIFT 0U


/////////////////////////////////////////  
//add Version defines  
/////////////////////////////////////////  
//#define MRV_LITE_VERSION                1
#define MRV_IMAGE_EFFECTS_VERSION       1  
#define MRV_SUPER_IMPOSE_VERSION        1  
#define MRV_BLACK_LEVEL_VERSION         1
#define MRV_AUTO_EXPOSURE_VERSION       1
#define MRV_OUTPUT_FORMATTER_VERSION    1  
#define MRV_GAMMA_OUT_VERSION           1
#define MRV_FLASH_LIGHT_VERSION         1
#define MRV_SHUTTER_VERSION             1
#define MRV_MAINPATH_SCALER_VERSION     1  
#define MRV_SELFPATH_SCALER_VERSION     1  
#define MRV_MI_VERSION                  2  
//#define MRV_JPE_VERSION                 0//1  
#define MRV_SMIA_VERSION                1
#define MRV_MIPI_VERSION                1
#define MRV_AUTOFOCUS_VERSION           1
#define MRV_LSC_VERSION                 1
#define MRV_IS_VERSION                  1
#define MRV_HISTOGRAM_VERSION           1
#define MRV_FILTER_VERSION              1
#define MRV_CAC_VERSION                 1
#define MRV_DPF_VERSION                 1
#define MRV_DPCC_VERSION                1
#define MRV_WDR_VERSION                 1
#define MRV_CSM_VERSION                 1
#define MRV_AWB_VERSION                 1
#define MRV_GAMMA_IN_VERSION            1
#define MRV_SHUTTER_CTRL_VERSION        1
#define MRV_CT_VERSION                  1
#define MRV_COLOR_PROCESSING_VERSION    1
#define MRV_2xMIPI_VERSION              1
#define MRV_VSM_VERSION                 1
#define MRV_DUAL_CROP_VERSION           1

#endif // _MRV_ALL_REGS_H
